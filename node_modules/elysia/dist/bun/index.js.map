{
  "version": 3,
  "sources": ["../../node_modules/eventemitter3/index.js", "../../node_modules/fast-decode-uri-component/index.js", "../../node_modules/fast-querystring/lib/parse.js", "../../node_modules/fast-querystring/lib/internals/querystring.js", "../../node_modules/fast-querystring/lib/stringify.js", "../../node_modules/fast-querystring/lib/index.js", "../../node_modules/memoirist/dist/index.js", "../../node_modules/eventemitter3/index.mjs", "../../node_modules/eventemitter3/index.mjs", "../../src/trace.ts", "../../src/sucrose.ts", "../../src/sucrose.ts", "../../src/error.ts", "../../src/utils.ts", "../../node_modules/cookie/index.js", "../../src/cookies.ts", "../../src/cookies.ts", "../../src/handler.ts", "../../src/utils.ts", "../../src/error.ts", "../../src/ws/index.ts", "../../src/compose.ts", "../../src/compose.ts", "../../src/compose.ts", "../../src/dynamic-handle.ts", "../../src/dynamic-handle.ts", "../../src/type-system.ts", "../../src/formats.ts", "../../src/type-system.ts", "../../src/index.ts"],
  "sourcesContent": [
    "'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n",
  "'use strict'\n\nvar UTF8_ACCEPT = 12\nvar UTF8_REJECT = 0\nvar UTF8_DATA = [\n  // The first part of the table maps bytes to character to a transition.\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n  4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n  6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7,\n  10, 9, 9, 9, 11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n\n  // The second part of the table maps a state to a new state when adding a\n  // transition.\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  12, 0, 0, 0, 0, 24, 36, 48, 60, 72, 84, 96,\n  0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 24, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 48, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\n  // The third part maps the current transition to a mask that needs to apply\n  // to the byte.\n  0x7F, 0x3F, 0x3F, 0x3F, 0x00, 0x1F, 0x0F, 0x0F, 0x0F, 0x07, 0x07, 0x07\n]\n\nfunction decodeURIComponent (uri) {\n  var percentPosition = uri.indexOf('%')\n  if (percentPosition === -1) return uri\n\n  var length = uri.length\n  var decoded = ''\n  var last = 0\n  var codepoint = 0\n  var startOfOctets = percentPosition\n  var state = UTF8_ACCEPT\n\n  while (percentPosition > -1 && percentPosition < length) {\n    var high = hexCodeToInt(uri[percentPosition + 1], 4)\n    var low = hexCodeToInt(uri[percentPosition + 2], 0)\n    var byte = high | low\n    var type = UTF8_DATA[byte]\n    state = UTF8_DATA[256 + state + type]\n    codepoint = (codepoint << 6) | (byte & UTF8_DATA[364 + type])\n\n    if (state === UTF8_ACCEPT) {\n      decoded += uri.slice(last, startOfOctets)\n\n      decoded += (codepoint <= 0xFFFF)\n        ? String.fromCharCode(codepoint)\n        : String.fromCharCode(\n          (0xD7C0 + (codepoint >> 10)),\n          (0xDC00 + (codepoint & 0x3FF))\n        )\n\n      codepoint = 0\n      last = percentPosition + 3\n      percentPosition = startOfOctets = uri.indexOf('%', last)\n    } else if (state === UTF8_REJECT) {\n      return null\n    } else {\n      percentPosition += 3\n      if (percentPosition < length && uri.charCodeAt(percentPosition) === 37) continue\n      return null\n    }\n  }\n\n  return decoded + uri.slice(last)\n}\n\nvar HEX = {\n  '0': 0,\n  '1': 1,\n  '2': 2,\n  '3': 3,\n  '4': 4,\n  '5': 5,\n  '6': 6,\n  '7': 7,\n  '8': 8,\n  '9': 9,\n  'a': 10,\n  'A': 10,\n  'b': 11,\n  'B': 11,\n  'c': 12,\n  'C': 12,\n  'd': 13,\n  'D': 13,\n  'e': 14,\n  'E': 14,\n  'f': 15,\n  'F': 15\n}\n\nfunction hexCodeToInt (c, shift) {\n  var i = HEX[c]\n  return i === undefined ? 255 : i << shift\n}\n\nmodule.exports = decodeURIComponent\n",
  "\"use strict\";\n\nconst fastDecode = require(\"fast-decode-uri-component\");\n\nconst plusRegex = /\\+/g;\nconst Empty = function () {};\nEmpty.prototype = Object.create(null);\n\n/**\n * @callback parse\n * @param {string} input\n */\nfunction parse(input) {\n  // Optimization: Use new Empty() instead of Object.create(null) for performance\n  // v8 has a better optimization for initializing functions compared to Object\n  const result = new Empty();\n\n  if (typeof input !== \"string\") {\n    return result;\n  }\n\n  let inputLength = input.length;\n  let key = \"\";\n  let value = \"\";\n  let startingIndex = -1;\n  let equalityIndex = -1;\n  let shouldDecodeKey = false;\n  let shouldDecodeValue = false;\n  let keyHasPlus = false;\n  let valueHasPlus = false;\n  let hasBothKeyValuePair = false;\n  let c = 0;\n\n  // Have a boundary of input.length + 1 to access last pair inside the loop.\n  for (let i = 0; i < inputLength + 1; i++) {\n    c = i !== inputLength ? input.charCodeAt(i) : 38;\n\n    // Handle '&' and end of line to pass the current values to result\n    if (c === 38) {\n      hasBothKeyValuePair = equalityIndex > startingIndex;\n\n      // Optimization: Reuse equality index to store the end of key\n      if (!hasBothKeyValuePair) {\n        equalityIndex = i;\n      }\n\n      key = input.slice(startingIndex + 1, equalityIndex);\n\n      // Add key/value pair only if the range size is greater than 1; a.k.a. contains at least \"=\"\n      if (hasBothKeyValuePair || key.length > 0) {\n        // Optimization: Replace '+' with space\n        if (keyHasPlus) {\n          key = key.replace(plusRegex, \" \");\n        }\n\n        // Optimization: Do not decode if it's not necessary.\n        if (shouldDecodeKey) {\n          key = fastDecode(key) || key;\n        }\n\n        if (hasBothKeyValuePair) {\n          value = input.slice(equalityIndex + 1, i);\n\n          if (valueHasPlus) {\n            value = value.replace(plusRegex, \" \");\n          }\n\n          if (shouldDecodeValue) {\n            value = fastDecode(value) || value;\n          }\n        }\n        const currentValue = result[key];\n\n        if (currentValue === undefined) {\n          result[key] = value;\n        } else {\n          // Optimization: value.pop is faster than Array.isArray(value)\n          if (currentValue.pop) {\n            currentValue.push(value);\n          } else {\n            result[key] = [currentValue, value];\n          }\n        }\n      }\n\n      // Reset reading key value pairs\n      value = \"\";\n      startingIndex = i;\n      equalityIndex = i;\n      shouldDecodeKey = false;\n      shouldDecodeValue = false;\n      keyHasPlus = false;\n      valueHasPlus = false;\n    }\n    // Check '='\n    else if (c === 61) {\n      if (equalityIndex <= startingIndex) {\n        equalityIndex = i;\n      }\n      // If '=' character occurs again, we should decode the input.\n      else {\n        shouldDecodeValue = true;\n      }\n    }\n    // Check '+', and remember to replace it with empty space.\n    else if (c === 43) {\n      if (equalityIndex > startingIndex) {\n        valueHasPlus = true;\n      } else {\n        keyHasPlus = true;\n      }\n    }\n    // Check '%' character for encoding\n    else if (c === 37) {\n      if (equalityIndex > startingIndex) {\n        shouldDecodeValue = true;\n      } else {\n        shouldDecodeKey = true;\n      }\n    }\n  }\n\n  return result;\n}\n\nmodule.exports = parse;\n",
  "// This file is taken from Node.js project.\n// Full implementation can be found from https://github.com/nodejs/node/blob/main/lib/internal/querystring.js\n\nconst hexTable = Array.from(\n  { length: 256 },\n  (_, i) => \"%\" + ((i < 16 ? \"0\" : \"\") + i.toString(16)).toUpperCase(),\n);\n\n// These characters do not need escaping when generating query strings:\n// ! - . _ ~\n// ' ( ) *\n// digits\n// alpha (uppercase)\n// alpha (lowercase)\n// rome-ignore format: the array should not be formatted\nconst noEscape = new Int8Array([\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\n  0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, // 32 - 47\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, // 80 - 95\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, // 112 - 127\n]);\n\n/**\n * @param {string} str\n * @returns {string}\n */\nfunction encodeString(str) {\n  const len = str.length;\n  if (len === 0) return \"\";\n\n  let out = \"\";\n  let lastPos = 0;\n  let i = 0;\n\n  outer: for (; i < len; i++) {\n    let c = str.charCodeAt(i);\n\n    // ASCII\n    while (c < 0x80) {\n      if (noEscape[c] !== 1) {\n        if (lastPos < i) out += str.slice(lastPos, i);\n        lastPos = i + 1;\n        out += hexTable[c];\n      }\n\n      if (++i === len) break outer;\n\n      c = str.charCodeAt(i);\n    }\n\n    if (lastPos < i) out += str.slice(lastPos, i);\n\n    // Multi-byte characters ...\n    if (c < 0x800) {\n      lastPos = i + 1;\n      out += hexTable[0xc0 | (c >> 6)] + hexTable[0x80 | (c & 0x3f)];\n      continue;\n    }\n    if (c < 0xd800 || c >= 0xe000) {\n      lastPos = i + 1;\n      out +=\n        hexTable[0xe0 | (c >> 12)] +\n        hexTable[0x80 | ((c >> 6) & 0x3f)] +\n        hexTable[0x80 | (c & 0x3f)];\n      continue;\n    }\n    // Surrogate pair\n    ++i;\n\n    // This branch should never happen because all URLSearchParams entries\n    // should already be converted to USVString. But, included for\n    // completion's sake anyway.\n    if (i >= len) {\n      throw new Error(\"URI malformed\");\n    }\n\n    const c2 = str.charCodeAt(i) & 0x3ff;\n\n    lastPos = i + 1;\n    c = 0x10000 + (((c & 0x3ff) << 10) | c2);\n    out +=\n      hexTable[0xf0 | (c >> 18)] +\n      hexTable[0x80 | ((c >> 12) & 0x3f)] +\n      hexTable[0x80 | ((c >> 6) & 0x3f)] +\n      hexTable[0x80 | (c & 0x3f)];\n  }\n  if (lastPos === 0) return str;\n  if (lastPos < len) return out + str.slice(lastPos);\n  return out;\n}\n\nmodule.exports = { encodeString };\n",
  "\"use strict\";\n\nconst { encodeString } = require(\"./internals/querystring\");\n\nfunction getAsPrimitive(value) {\n  const type = typeof value;\n\n  if (type === \"string\") {\n    // Length check is handled inside encodeString function\n    return encodeString(value);\n  } else if (type === \"bigint\") {\n    return value.toString();\n  } else if (type === \"boolean\") {\n    return value ? \"true\" : \"false\";\n  } else if (type === \"number\" && Number.isFinite(value)) {\n    return value < 1e21 ? \"\" + value : encodeString(\"\" + value);\n  }\n\n  return \"\";\n}\n\n/**\n * @param {Record<string, string | number | boolean\n * | ReadonlyArray<string | number | boolean> | null>} input\n * @returns {string}\n */\nfunction stringify(input) {\n  let result = \"\";\n\n  if (input === null || typeof input !== \"object\") {\n    return result;\n  }\n\n  const separator = \"&\";\n  const keys = Object.keys(input);\n  const keyLength = keys.length;\n  let valueLength = 0;\n\n  for (let i = 0; i < keyLength; i++) {\n    const key = keys[i];\n    const value = input[key];\n    const encodedKey = encodeString(key) + \"=\";\n\n    if (i) {\n      result += separator;\n    }\n\n    if (Array.isArray(value)) {\n      valueLength = value.length;\n      for (let j = 0; j < valueLength; j++) {\n        if (j) {\n          result += separator;\n        }\n\n        // Optimization: Dividing into multiple lines improves the performance.\n        // Since v8 does not need to care about the '+' character if it was one-liner.\n        result += encodedKey;\n        result += getAsPrimitive(value[j]);\n      }\n    } else {\n      result += encodedKey;\n      result += getAsPrimitive(value);\n    }\n  }\n\n  return result;\n}\n\nmodule.exports = stringify;\n",
  "\"use strict\";\n\nconst parse = require(\"./parse\");\nconst stringify = require(\"./stringify\");\n\nconst fastQuerystring = {\n  parse,\n  stringify,\n};\n\n/**\n * Enable TS and JS support\n *\n * - `const qs = require('fast-querystring')`\n * - `import qs from 'fast-querystring'`\n */\nmodule.exports = fastQuerystring;\nmodule.exports.default = fastQuerystring;\nmodule.exports.parse = parse;\nmodule.exports.stringify = stringify;\n",
  "let e=(e,t)=>({part:e,store:null,inert:void 0!==t?new Map(t.map(e=>[e.part.charCodeAt(0),e])):null,params:null,wildcardStore:null}),t=(e,t)=>({...e,part:t}),r=e=>({paramName:e,store:null,inert:null});export class Memoirist{root={};history=[];static regex={static:/:.+?(?=\\/|$)/,params:/:.+?(?=\\/|$)/g};add(a,l,i){let s;if(\"string\"!=typeof l)throw TypeError(\"Route path must be a string\");\"\"===l?l=\"/\":\"/\"!==l[0]&&(l=`/${l}`),this.history.push([a,l,i]);let n=\"*\"===l[l.length-1];n&&(l=l.slice(0,-1));let o=l.split(Memoirist.regex.static),u=l.match(Memoirist.regex.params)||[];\"\"===o[o.length-1]&&o.pop(),s=this.root[a]?this.root[a]:this.root[a]=e(\"/\");let p=0;for(let a=0;a<o.length;++a){let i=o[a];if(a>0){let t=u[p++].slice(1);if(null===s.params)s.params=r(t);else if(s.params.paramName!==t)throw Error(`Cannot create route \"${l}\" with parameter \"${t}\" because a route already exists with a different parameter name (\"${s.params.paramName}\") in the same location`);let a=s.params;if(null===a.inert){s=a.inert=e(i);continue}s=a.inert}for(let r=0;;){if(r===i.length){if(r<s.part.length){let a=t(s,s.part.slice(r));Object.assign(s,e(i,[a]))}break}if(r===s.part.length){if(null===s.inert)s.inert=new Map;else if(s.inert.has(i.charCodeAt(r))){s=s.inert.get(i.charCodeAt(r)),i=i.slice(r),r=0;continue}let t=e(i.slice(r));s.inert.set(i.charCodeAt(r),t),s=t;break}if(i[r]!==s.part[r]){let a=t(s,s.part.slice(r)),l=e(i.slice(r));Object.assign(s,e(s.part.slice(0,r),[a,l])),s=l;break}++r}}if(p<u.length){let e=u[p],t=e.slice(1);if(null===s.params)s.params=r(t);else if(s.params.paramName!==t)throw Error(`Cannot create route \"${l}\" with parameter \"${t}\" because a route already exists with a different parameter name (\"${s.params.paramName}\") in the same location`);return null===s.params.store&&(s.params.store=i),s.params.store}return n?(null===s.wildcardStore&&(s.wildcardStore=i),s.wildcardStore):(null===s.store&&(s.store=i),s.store)}find(e,t){let r=this.root[e];return r?a(t,t.length,r,0):null}}let a=(e,t,r,l)=>{let i=r?.part,s=l+i.length;if(i.length>1){if(s>t)return null;if(i.length<15){for(let t=1,r=l+1;t<i.length;++t,++r)if(i.charCodeAt(t)!==e.charCodeAt(r))return null}else if(e.substring(l,s)!==i)return null}if(s===t)return null!==r.store?{store:r.store,params:{}}:null!==r.wildcardStore?{store:r.wildcardStore,params:{\"*\":\"\"}}:null;if(null!==r.inert){let l=r.inert.get(e.charCodeAt(s));if(void 0!==l){let r=a(e,t,l,s);if(null!==r)return r}}if(null!==r.params){let l=r.params,i=e.indexOf(\"/\",s);if(i!==s){if(-1===i||i>=t){if(null!==l.store){let r={};return r[l.paramName]=e.substring(s,t),{store:l.store,params:r}}}else if(null!==l.inert){let r=a(e,t,l.inert,i);if(null!==r)return r.params[l.paramName]=e.substring(s,i),r}}}return null!==r.wildcardStore?{store:r.wildcardStore,params:{\"*\":e.substring(s,t)}}:null};export default Memoirist;",
  "import EventEmitter from './index.js'\n\nexport { EventEmitter }\nexport default EventEmitter\n",
  "import EventEmitter from './index.js'\n\nexport { EventEmitter }\nexport default EventEmitter\n",
  "import type {\n\tHookContainer,\n\tTraceHandler,\n\tTraceProcess,\n\tTraceReporter,\n\tTraceStream\n} from './types'\n\nconst resolver = <T>() => {\n\tlet resolve: (a: T) => any\n\tconst promise = new Promise<T>((r) => {\n\t\tresolve = r\n\t})\n\n\treturn [promise, resolve!] as const\n}\n\ntype TraceResolver = [\n\tstart: (value: TraceProcess<'begin'>) => any,\n\tend: (value: TraceProcess<'end'>) => any\n]\n\nconst createSignal = () => {\n\tconst [start, resolveStart] = resolver<TraceProcess<'begin'>>()\n\tconst [end, resolveEnd] = resolver<TraceProcess<'end'>>()\n\n\tconst children: Promise<TraceProcess<'begin'>>[] = []\n\tconst resolvers: TraceResolver[] = []\n\n\treturn {\n\t\tsignal: start,\n\t\tconsume: (trace: TraceStream) => {\n\t\t\tswitch (trace.type) {\n\t\t\t\tcase 'begin':\n\t\t\t\t\tif (trace.unit && children.length === 0)\n\t\t\t\t\t\tfor (let i = 0; i < trace.unit; i++) {\n\t\t\t\t\t\t\tconst [start, resolveStart] =\n\t\t\t\t\t\t\t\tresolver<TraceProcess<'begin'>>()\n\t\t\t\t\t\t\tconst [end, resolveEnd] =\n\t\t\t\t\t\t\t\tresolver<TraceProcess<'end'>>()\n\n\t\t\t\t\t\t\tchildren.push(start)\n\t\t\t\t\t\t\tresolvers.push([\n\t\t\t\t\t\t\t\t(trace) => {\n\t\t\t\t\t\t\t\t\tresolveStart({\n\t\t\t\t\t\t\t\t\t\tchildren: [],\n\t\t\t\t\t\t\t\t\t\tend,\n\t\t\t\t\t\t\t\t\t\tname: trace.name ?? '',\n\t\t\t\t\t\t\t\t\t\tskip: false,\n\t\t\t\t\t\t\t\t\t\ttime: trace.time\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t(time) => {\n\t\t\t\t\t\t\t\t\tresolveEnd(time)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t])\n\t\t\t\t\t\t}\n\n\t\t\t\t\tresolveStart({\n\t\t\t\t\t\tchildren,\n\t\t\t\t\t\tend,\n\t\t\t\t\t\tname: trace.name ?? '',\n\t\t\t\t\t\tskip: false,\n\t\t\t\t\t\ttime: trace.time\n\t\t\t\t\t})\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'end':\n\t\t\t\t\tresolveEnd(trace.time)\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t},\n\t\tconsumeChild(trace: TraceStream) {\n\t\t\tswitch (trace.type) {\n\t\t\t\tcase 'begin':\n\t\t\t\t\tif (!resolvers[0]) return\n\t\t\t\t\tconst [resolveStart] = resolvers[0]\n\n\t\t\t\t\tresolveStart({\n\t\t\t\t\t\tchildren: [],\n\t\t\t\t\t\tend,\n\t\t\t\t\t\tname: trace.name ?? '',\n\t\t\t\t\t\tskip: false,\n\t\t\t\t\t\ttime: trace.time\n\t\t\t\t\t})\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'end':\n\t\t\t\t\tconst child = resolvers.shift()\n\t\t\t\t\tif (!child) return\n\n\t\t\t\t\tchild[1](trace.time)\n\t\t\t}\n\t\t},\n\t\tresolve() {\n\t\t\tresolveStart({\n\t\t\t\tchildren: [],\n\t\t\t\tend: new Promise((resolve) => resolve(0)),\n\t\t\t\tname: '',\n\t\t\t\tskip: true,\n\t\t\t\ttime: 0\n\t\t\t})\n\n\t\t\tfor (const [resolveStart, resolveEnd] of resolvers) {\n\t\t\t\tresolveStart({\n\t\t\t\t\tchildren: [],\n\t\t\t\t\tend: new Promise((resolve) => resolve(0)),\n\t\t\t\t\tname: '',\n\t\t\t\t\tskip: true,\n\t\t\t\t\ttime: 0\n\t\t\t\t})\n\n\t\t\t\tresolveEnd(0)\n\t\t\t}\n\n\t\t\tresolveEnd(0)\n\t\t}\n\t}\n}\n\nexport const createTraceListener = (\n\tgetReporter: () => TraceReporter,\n\ttotalListener: number,\n\thandler: TraceHandler<any, any> | HookContainer<TraceHandler<any, any>>\n) => {\n\tif (typeof handler === 'object') handler = handler.fn\n\n\treturn async function trace(trace: TraceStream) {\n\t\tif (trace.event !== 'request' || trace.type !== 'begin') return\n\n\t\tconst id = trace.id\n\t\tconst reporter = getReporter()\n\n\t\tconst request = createSignal()\n\t\tconst parse = createSignal()\n\t\tconst transform = createSignal()\n\t\tconst beforeHandle = createSignal()\n\t\tconst handle = createSignal()\n\t\tconst afterHandle = createSignal()\n\t\tconst error = createSignal()\n\t\tconst response = createSignal()\n\n\t\trequest.consume(trace)\n\n\t\tconst reducer = (event: TraceStream) => {\n\t\t\tif (event.id === id)\n\t\t\t\tswitch (event.event) {\n\t\t\t\t\tcase 'request':\n\t\t\t\t\t\trequest.consume(event)\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'request.unit':\n\t\t\t\t\t\trequest.consumeChild(event)\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'parse':\n\t\t\t\t\t\tparse.consume(event)\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'parse.unit':\n\t\t\t\t\t\tparse.consumeChild(event)\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'transform':\n\t\t\t\t\t\ttransform.consume(event)\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'transform.unit':\n\t\t\t\t\t\ttransform.consumeChild(event)\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'beforeHandle':\n\t\t\t\t\t\tbeforeHandle.consume(event)\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'beforeHandle.unit':\n\t\t\t\t\t\tbeforeHandle.consumeChild(event)\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'handle':\n\t\t\t\t\t\thandle.consume(event)\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'afterHandle':\n\t\t\t\t\t\tafterHandle.consume(event)\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'afterHandle.unit':\n\t\t\t\t\t\tafterHandle.consumeChild(event)\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'error':\n\t\t\t\t\t\terror.consume(event)\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'error.unit':\n\t\t\t\t\t\terror.consumeChild(event)\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'response':\n\t\t\t\t\t\tif (event.type === 'begin') {\n\t\t\t\t\t\t\trequest.resolve()\n\t\t\t\t\t\t\tparse.resolve()\n\t\t\t\t\t\t\ttransform.resolve()\n\t\t\t\t\t\t\tbeforeHandle.resolve()\n\t\t\t\t\t\t\thandle.resolve()\n\t\t\t\t\t\t\tafterHandle.resolve()\n\t\t\t\t\t\t\terror.resolve()\n\t\t\t\t\t\t} else reporter.off('event', reducer)\n\n\t\t\t\t\t\tresponse.consume(event)\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'response.unit':\n\t\t\t\t\t\tresponse.consumeChild(event)\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'exit':\n\t\t\t\t\t\trequest.resolve()\n\t\t\t\t\t\tparse.resolve()\n\t\t\t\t\t\ttransform.resolve()\n\t\t\t\t\t\tbeforeHandle.resolve()\n\t\t\t\t\t\thandle.resolve()\n\t\t\t\t\t\tafterHandle.resolve()\n\t\t\t\t\t\terror.resolve()\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t}\n\n\t\treporter.on('event', reducer)\n\n\t\tawait handler({\n\t\t\tid,\n\t\t\t// @ts-ignore\n\t\t\tcontext: trace.ctx,\n\t\t\t// @ts-ignore\n\t\t\tset: trace.ctx?.set,\n\t\t\t// @ts-ignore\n\t\t\tstore: trace.ctx?.store,\n\t\t\ttime: trace.time,\n\t\t\trequest: request.signal as any,\n\t\t\tparse: parse.signal as any,\n\t\t\ttransform: transform.signal as any,\n\t\t\tbeforeHandle: beforeHandle.signal as any,\n\t\t\thandle: handle.signal as any,\n\t\t\tafterHandle: afterHandle.signal as any,\n\t\t\terror: error.signal,\n\t\t\tresponse: response.signal as any\n\t\t})\n\n\t\treporter.emit(`res${id}.${totalListener}`, undefined)\n\t}\n}\n",
  "/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable no-constant-condition */\nimport type { Handler, LifeCycleStore, TraceHandler } from './types'\n\nexport namespace Sucrose {\n\texport interface Inference {\n\t\tqueries: string[]\n\t\tunknownQueries: boolean\n\t\tquery: boolean\n\t\theaders: boolean\n\t\tbody: boolean\n\t\tcookie: boolean\n\t\tset: boolean\n\t}\n\n\texport interface LifeCycle extends Partial<LifeCycleStore> {\n\t\thandler?: Handler\n\t}\n\n\texport interface TraceInference {\n\t\trequest: boolean\n\t\tparse: boolean\n\t\ttransform: boolean\n\t\thandle: boolean\n\t\tbeforeHandle: boolean\n\t\tafterHandle: boolean\n\t\terror: boolean\n\t\tcontext: boolean\n\t\tstore: boolean\n\t\tset: boolean\n\t}\n}\n\n/**\n * Separate stringified function body and paramter\n *\n * @example\n * ```typescript\n * separateFunction('async ({ hello }) => { return hello }') // => ['({ hello })', '{ return hello }']\n * ```\n */\nexport const separateFunction = (\n\tcode: string\n): [string, string, { isArrowReturn: boolean }] => {\n\tif (code.startsWith('async')) code = code.slice(6)\n\n\tlet index = -1\n\n\t// Starts with '(', is an arrow function\n\tif (code.charCodeAt(0) === 40) {\n\t\t// ? arrow function\n\t\tindex = code.indexOf(') => {\\n')\n\t\tif (index !== -1)\n\t\t\treturn [\n\t\t\t\tcode.slice(1, index),\n\t\t\t\tcode.slice(index + 5),\n\t\t\t\t{ isArrowReturn: false }\n\t\t\t]\n\n\t\t// ? Arrow return\n\t\tindex = code.indexOf(') => ')\n\t\tif (index !== -1)\n\t\t\treturn [\n\t\t\t\tcode.slice(1, index),\n\t\t\t\tcode.slice(index + 5),\n\t\t\t\t{ isArrowReturn: true }\n\t\t\t]\n\t}\n\n\t// Using function keyword\n\tif (code.startsWith('function')) {\n\t\tindex = code.indexOf('(')\n\t\tconst end = code.indexOf(')')\n\n\t\treturn [\n\t\t\tcode.slice(index + 1, end),\n\t\t\tcode.slice(end + 2),\n\t\t\t{\n\t\t\t\tisArrowReturn: false\n\t\t\t}\n\t\t]\n\t}\n\n\t// Probably Declare as method\n\tconst start = code.indexOf('(')\n\n\tif (start !== -1) {\n\t\tconst [parameter, body] = code.split('\\n', 2)\n\t\tconst end = parameter.lastIndexOf(')') + 1\n\n\t\treturn [\n\t\t\tparameter.slice(start, end),\n\t\t\t'{' + body,\n\t\t\t{\n\t\t\t\tisArrowReturn: false\n\t\t\t}\n\t\t]\n\t}\n\n\t// Unknown case\n\tconst x = code.split('\\n', 2)\n\n\treturn [x[0], x[1], { isArrowReturn: false }]\n}\n\n/**\n * Get range between bracket pair\n *\n * @example\n * ```typescript\n * bracketPairRange('hello: { world: { a } }, elysia') // [6, 20]\n * ```\n */\nexport const bracketPairRange = (parameter: string): [number, number] => {\n\tconst start = parameter.indexOf('{')\n\tif (start === -1) return [-1, 0]\n\n\tlet end = start + 1\n\tlet deep = 1\n\n\tfor (; end < parameter.length; end++) {\n\t\tconst char = parameter.charCodeAt(end)\n\n\t\t// Open bracket\n\t\tif (char === 123) deep++\n\t\t// Close bracket\n\t\telse if (char === 125) deep--\n\n\t\tif (deep === 0) break\n\t}\n\n\tif (deep !== 0) return [0, parameter.length]\n\n\treturn [start, end + 1]\n}\n\n/**\n * Similar to `bracketPairRange` but in reverse order\n * Get range between bracket pair from end to beginning\n *\n * @example\n * ```typescript\n * bracketPairRange('hello: { world: { a } }, elysia') // [6, 20]\n * ```\n */\nexport const bracketPairRangeReverse = (\n\tparameter: string\n): [number, number] => {\n\tconst end = parameter.lastIndexOf('}')\n\tif (end === -1) return [-1, 0]\n\n\tlet start = end - 1\n\tlet deep = 1\n\n\tfor (; start >= 0; start--) {\n\t\tconst char = parameter.charCodeAt(start)\n\n\t\t// Open bracket\n\t\tif (char === 125) deep++\n\t\t// Close bracket\n\t\telse if (char === 123) deep--\n\n\t\tif (deep === 0) break\n\t}\n\n\tif (deep !== 0) return [-1, 0]\n\n\treturn [start, end + 1]\n}\n\n/**\n * Retrieve only root paramters of a function\n *\n * @example\n * ```typescript\n * retrieveRootParameters('({ hello: { world: { a } }, elysia })') // => 'hello elysia'\n * ```\n */\nexport const retrieveRootParamters = (parameter: string) => {\n\t// Remove () and {}\n\tif (parameter.charCodeAt(0) === 40) parameter = parameter.slice(1, -1)\n\t// Using 2 because of the space\n\tif (parameter.charCodeAt(0) === 123) parameter = parameter.slice(2, -2)\n\n\twhile (true) {\n\t\tconst [start, end] = bracketPairRange(parameter)\n\t\tif (start === -1) break\n\n\t\tparameter = parameter.slice(0, start - 2) + parameter.slice(end + 1)\n\t}\n\n\treturn parameter.replace(/:/g, '').trim()\n}\n\n/**\n * Find inference from parameter\n *\n * @param parameter stringified parameter\n */\nexport const findParameterReference = (\n\tparameter: string,\n\tinference: Sucrose.Inference\n) => {\n\tconst root = retrieveRootParamters(parameter)\n\n\tif (!inference.query && root.includes('query')) inference.query = true\n\tif (!inference.headers && root.includes('headers')) inference.headers = true\n\tif (!inference.body && root.includes('body')) inference.body = true\n\tif (!inference.cookie && root.includes('cookie')) inference.cookie = true\n\tif (!inference.set && root.includes('set')) inference.set = true\n\n\treturn root\n}\n\n/**\n * Find inference from parameter\n *\n * @param parameter stringified parameter\n */\nexport const findTraceParameterReference = (\n\tparameter: string,\n\tinference: Sucrose.TraceInference\n) => {\n\tconst root = retrieveRootParamters(parameter)\n\n\tif (!inference.request && root.includes('request')) inference.request = true\n\tif (!inference.parse && root.includes('parse')) inference.parse = true\n\tif (!inference.transform && root.includes('transform'))\n\t\tinference.transform = true\n\tif (!inference.handle && root.includes('handle')) inference.handle = true\n\tif (!inference.beforeHandle && root.includes('beforeHandle'))\n\t\tinference.beforeHandle = true\n\tif (!inference.afterHandle && root.includes('afterHandle'))\n\t\tinference.afterHandle = true\n\tif (!inference.error && root.includes('error')) inference.error = true\n\tif (!inference.context && root.includes('context')) inference.context = true\n\tif (!inference.store && root.includes('store')) inference.store = true\n\tif (!inference.set && root.includes('set')) inference.set = true\n\n\treturn root\n}\n\nconst findEndIndex = (\n\ttype: string,\n\tcontent: string,\n\tindex?: number | undefined\n) => {\n\tconst newLineIndex = content.indexOf(type + '\\n', index)\n\tconst newTabIndex = content.indexOf(type + '\\t', index)\n\tconst commaIndex = content.indexOf(type + ',', index)\n\tconst semicolonIndex = content.indexOf(type + ';', index)\n\tconst emptyIndex = content.indexOf(type + ' ', index)\n\n\t// Pick the smallest index that is not -1 or 0\n\treturn (\n\t\t[newLineIndex, newTabIndex, commaIndex, semicolonIndex, emptyIndex]\n\t\t\t.filter((i) => i > 0)\n\t\t\t.sort((a, b) => a - b)[0] || -1\n\t)\n}\n\nconst findEndQueryBracketIndex = (\n\ttype: string,\n\tcontent: string,\n\tindex?: number | undefined\n) => {\n\tconst bracketEndIndex = content.indexOf(type + ']', index)\n\tconst singleQuoteIndex = content.indexOf(type + \"'\", index)\n\tconst doubleQuoteIndex = content.indexOf(type + '\"', index)\n\n\t// Pick the smallest index that is not -1 or 0\n\treturn (\n\t\t[bracketEndIndex, singleQuoteIndex, doubleQuoteIndex]\n\t\t\t.filter((i) => i > 0)\n\t\t\t.sort((a, b) => a - b)[0] || -1\n\t)\n}\n\n/**\n * Find alias of variable from function body\n *\n * @example\n * ```typescript\n * findAlias('body', '{ const a = body, b = body }') // => ['a', 'b']\n * ```\n */\nexport const findAlias = (type: string, body: string, depth = 0) => {\n\tif (depth > 5) return []\n\n\tconst aliases: string[] = []\n\n\tlet content = body\n\n\twhile (true) {\n\t\tlet index = findEndIndex(' = ' + type, content)\n\n\t\tif (index === -1) {\n\t\t\t/**\n\t\t\t * Check if pattern is at the end of the string\n\t\t\t *\n\t\t\t * @example\n\t\t\t * ```typescript\n\t\t\t * 'const a = body' // true\n\t\t\t * ```\n\t\t\t **/\n\t\t\tconst lastIndex = content.indexOf(' = ' + type)\n\n\t\t\tif (lastIndex + 3 + type.length !== content.length) break\n\n\t\t\tindex = lastIndex\n\t\t}\n\n\t\tconst part = content.slice(0, index)\n\t\t/**\n\t\t * aliased variable last character\n\t\t *\n\t\t * @example\n\t\t * ```typescript\n\t\t * const { hello } = body // } is the last character\n\t\t * ```\n\t\t **/\n\t\tlet variable = part.slice(part.lastIndexOf(' ') + 1)\n\n\t\t// Variable is using object destructuring, find the bracket pair\n\t\tif (variable === '}') {\n\t\t\tconst [start, end] = bracketPairRangeReverse(part)\n\n\t\t\taliases.push(content.slice(start, end))\n\n\t\t\tcontent = content.slice(index + 3 + type.length)\n\n\t\t\tcontinue\n\t\t}\n\n\t\t// Remove comma\n\t\twhile (variable.charCodeAt(0) === 44) variable = variable.slice(1)\n\t\twhile (variable.charCodeAt(0) === 9) variable = variable.slice(1)\n\n\t\taliases.push(variable)\n\t\tcontent = content.slice(index + 3 + type.length)\n\t}\n\n\tfor (const alias of aliases) {\n\t\tif (alias.charCodeAt(0) === 123) continue\n\n\t\tconst deepAlias = findAlias(alias, body)\n\t\tif (deepAlias.length > 0) aliases.push(...deepAlias)\n\t}\n\n\treturn aliases\n}\n\n// ? This is normalized to dot notation in Bun\n// const accessor = <T extends string, P extends string>(parent: T, prop: P) =>\n// \t[\n// \t\tparent + '.' + prop,\n// \t\tparent + '[\"' + prop + '\"]',\n// \t\tparent + \"['\" + prop + \"']\"\n// \t] as const\n\nexport const extractMainParameter = (parameter: string) => {\n\tif (!parameter) return\n\n\tconst hasComma = parameter.includes(',')\n\tif (!hasComma) {\n\t\t// This happens when spread operator is used as the only parameter\n\t\tif (parameter.includes('...'))\n\t\t\treturn parameter.slice(parameter.indexOf('...') + 3)\n\n\t\treturn parameter\n\t}\n\n\tconst spreadIndex = parameter.indexOf('...')\n\tif (spreadIndex === -1) return\n\n\t// Spread parameter is always the last parameter, no need for further checking\n\treturn parameter.slice(spreadIndex + 3).trimEnd()\n}\n\n/**\n * Analyze if context is mentioned in body\n */\nexport const inferBodyReference = (\n\tcode: string,\n\taliases: string[],\n\tinference: Sucrose.Inference\n) => {\n\tconst access = (type: string, alias: string) =>\n\t\tcode.includes(alias + '.' + type) ||\n\t\tcode.includes(alias + '[\"' + type + '\"]') ||\n\t\tcode.includes(alias + \"['\" + type + \"']\")\n\n\tfor (let alias of aliases) {\n\t\tif (!alias) continue\n\n\t\tif (alias.charCodeAt(0) === 123) {\n\t\t\talias = retrieveRootParamters(alias)\n\n\t\t\tif (!inference.query && alias.includes('query'))\n\t\t\t\tinference.query = true\n\n\t\t\tif (!inference.headers && alias.includes('headers'))\n\t\t\t\tinference.headers = true\n\n\t\t\tif (!inference.body && alias.includes('body')) inference.body = true\n\n\t\t\tif (!inference.cookie && alias.includes('cookie'))\n\t\t\t\tinference.cookie = true\n\n\t\t\tif (!inference.set && alias.includes('set')) inference.set = true\n\n\t\t\tcontinue\n\t\t}\n\n\t\t// ! Function is passed to another function, assume as all is accessed\n\t\tif (code.includes('(' + alias + ')')) {\n\t\t\tinference.query = true\n\t\t\tinference.headers = true\n\t\t\tinference.body = true\n\t\t\tinference.cookie = true\n\t\t\tinference.set = true\n\t\t\tinference.queries = []\n\t\t\tinference.unknownQueries = true\n\n\t\t\tbreak\n\t\t}\n\n\t\tif (!inference.query && access('query', alias)) inference.query = true\n\n\t\tif (\n\t\t\tcode.includes('return ' + alias) ||\n\t\t\tcode.includes('return ' + alias + '.query')\n\t\t) {\n\t\t\tinference.query = true\n\t\t\tinference.unknownQueries = true\n\t\t\tinference.queries = []\n\t\t}\n\n\t\tif (!inference.unknownQueries && inference.query) {\n\t\t\tlet keyword = alias + '.'\n\n\t\t\t// ? It's unlikely that user will use separate variable between c.query and query\n\t\t\tif (code.includes(keyword + 'query')) keyword = alias + '.query'\n\n\t\t\twhile (true) {\n\t\t\t\tlet start = code.indexOf(keyword)\n\n\t\t\t\t// ? This is normalized to dot notation in Bun\n\t\t\t\t// if (start === -1) {\n\t\t\t\t// \tisBracket = true\n\t\t\t\t// \tstart = code.indexOf(alias + '[\"')\n\t\t\t\t// }\n\n\t\t\t\t// if (start === -1) {\n\t\t\t\t// \tisBracket = true\n\t\t\t\t// \tstart = code.indexOf(alias + \"['\")\n\t\t\t\t// }\n\n\t\t\t\tif (start === -1 && code.indexOf(alias + '[') !== -1) {\n\t\t\t\t\t// ! Query is accessed using dynamic key, skip static parsing\n\t\t\t\t\tinference.queries = []\n\t\t\t\t\tinference.unknownQueries = true\n\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\tif (start !== -1) {\n\t\t\t\t\tlet end: number | undefined = findEndIndex(\n\t\t\t\t\t\t'',\n\t\t\t\t\t\tcode,\n\t\t\t\t\t\tstart + keyword.length + 1\n\t\t\t\t\t)\n\n\t\t\t\t\t// ? Do not remove, might need to use on other runtime\n\t\t\t\t\t// If need, replace above code with this one\n\t\t\t\t\t// let end: number | undefined = isBracket\n\t\t\t\t\t// \t? findEndQueryBracketIndex(\n\t\t\t\t\t// \t\t\t'',\n\t\t\t\t\t// \t\t\tcode,\n\t\t\t\t\t// \t\t\tstart + keyword.length + 1\n\t\t\t\t\t// \t  )\n\t\t\t\t\t// \t: findEndIndex('', code, start + keyword.length + 1)\n\n\t\t\t\t\tif (end === -1) end = undefined\n\n\t\t\t\t\tconst index = start + alias.length + 1\n\t\t\t\t\tcode = code.slice(start + alias.length + 1)\n\t\t\t\t\tlet query = code.slice(0, end ? end - index : end).trimEnd()\n\n\t\t\t\t\t// Remove nested dot\n\t\t\t\t\twhile (start !== -1) {\n\t\t\t\t\t\tstart = query.indexOf('.')\n\n\t\t\t\t\t\tif (start !== -1) query = query.slice(start + 1)\n\t\t\t\t\t}\n\n\t\t\t\t\t// Remove semi-colon\n\t\t\t\t\tif (query.charCodeAt(query.length - 1) === 59)\n\t\t\t\t\t\tquery = query.slice(0, -1)\n\n\t\t\t\t\t// Remove comma\n\t\t\t\t\tif (query.charCodeAt(query.length - 1) === 44)\n\t\t\t\t\t\tquery = query.slice(0, -1)\n\n\t\t\t\t\t// Remove closing square bracket\n\t\t\t\t\tif (query.charCodeAt(query.length - 1) === 93)\n\t\t\t\t\t\tquery = query.slice(0, -1)\n\n\t\t\t\t\t// Remove closing bracket\n\t\t\t\t\tif (query.charCodeAt(query.length - 1) === 41)\n\t\t\t\t\t\tquery = query.slice(0, -1)\n\n\t\t\t\t\t// ? Do not remove, might need to use on other runtime\n\t\t\t\t\t// if (isBracket) query = query.replaceAll(/(\"|')/g, '')\n\n\t\t\t\t\tif (query && !inference.queries.includes(query)) {\n\t\t\t\t\t\tinference.queries.push(query)\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif (!inference.headers && access('headers', alias))\n\t\t\tinference.headers = true\n\n\t\tif (!inference.body && access('body', alias)) inference.body = true\n\n\t\tif (!inference.cookie && access('cookie', alias))\n\t\t\tinference.cookie = true\n\n\t\tif (!inference.set && access('set', alias)) inference.set = true\n\n\t\tif (\n\t\t\tinference.query &&\n\t\t\tinference.headers &&\n\t\t\tinference.body &&\n\t\t\tinference.cookie &&\n\t\t\tinference.set\n\t\t)\n\t\t\tbreak\n\t}\n\n\treturn aliases\n}\n\nexport const removeDefaultParameter = (parameter: string) => {\n\twhile (true) {\n\t\tconst index = parameter.indexOf('=')\n\t\tif (index === -1) break\n\n\t\tconst commaIndex = parameter.indexOf(',', index)\n\t\tconst bracketIndex = parameter.indexOf('}', index)\n\n\t\tconst end =\n\t\t\t[commaIndex, bracketIndex]\n\t\t\t\t.filter((i) => i > 0)\n\t\t\t\t.sort((a, b) => a - b)[0] || -1\n\n\t\tif (end === -1) {\n\t\t\tparameter = parameter.slice(0, index)\n\n\t\t\tbreak\n\t\t}\n\n\t\tparameter = parameter.slice(0, index) + parameter.slice(end)\n\t}\n\n\treturn parameter\n\t\t.split(',')\n\t\t.map((i) => i.trim())\n\t\t.join(', ')\n}\n\nexport const validateInferencedQueries = (queries: string[]) => {\n\tfor (const query of queries) {\n\t\tif (query.charCodeAt(0) === 123) return false\n\t\tif (query.indexOf(\"'\") !== -1) return false\n\t\tif (query.indexOf('\"') !== -1) return false\n\t\tif (query.indexOf('\\n') !== -1) return false\n\t\tif (query.indexOf('\\t') !== -1) return false\n\t}\n\n\treturn true\n}\n\n/**\n * Analyze if context is mentioned in body\n */\nexport const inferTraceBodyReference = (\n\tcode: string,\n\taliases: string[],\n\tinference: Sucrose.TraceInference\n) => {\n\tconst access = (type: string, alias: string) =>\n\t\tcode.includes(type + '.' + alias) ||\n\t\tcode.includes(type + '[\"' + alias + '\"]') ||\n\t\tcode.includes(type + \"['\" + alias + \"']\")\n\n\tfor (let alias of aliases) {\n\t\tif (alias.charCodeAt(0) === 123) {\n\t\t\talias = retrieveRootParamters(alias)\n\n\t\t\tif (!inference.request && alias.includes('request'))\n\t\t\t\tinference.request = true\n\n\t\t\tif (!inference.parse && alias.includes('parse'))\n\t\t\t\tinference.parse = true\n\n\t\t\tif (!inference.transform && alias.includes('transform'))\n\t\t\t\tinference.transform = true\n\n\t\t\tif (!inference.handle && alias.includes('handle'))\n\t\t\t\tinference.handle = true\n\n\t\t\tif (!inference.beforeHandle && alias.includes('beforeHandle'))\n\t\t\t\tinference.beforeHandle = true\n\n\t\t\tif (!inference.afterHandle && alias.includes('afterHandle'))\n\t\t\t\tinference.afterHandle = true\n\n\t\t\tif (!inference.error && alias.includes('error'))\n\t\t\t\tinference.error = true\n\n\t\t\tif (!inference.context && alias.includes('context'))\n\t\t\t\tinference.context = true\n\n\t\t\tif (!inference.store && alias.includes('store'))\n\t\t\t\tinference.store = true\n\n\t\t\tif (!inference.set && alias.includes('set')) inference.set = true\n\n\t\t\tcontinue\n\t\t}\n\n\t\t// ! Function is passed to another function, assume as all is accessed\n\t\tif (code.includes('(' + alias + ')')) {\n\t\t\tinference.request = true\n\t\t\tinference.parse = true\n\t\t\tinference.transform = true\n\t\t\tinference.handle = true\n\t\t\tinference.beforeHandle = true\n\t\t\tinference.afterHandle = true\n\t\t\tinference.error = true\n\t\t\tinference.context = true\n\t\t\tinference.store = true\n\t\t\tinference.set = true\n\n\t\t\tbreak\n\t\t}\n\n\t\tif (!inference.request && access('request', alias))\n\t\t\tinference.request = true\n\n\t\tif (!inference.parse && access('parse', alias)) inference.parse = true\n\n\t\tif (!inference.transform && access('transform', alias))\n\t\t\tinference.transform = true\n\n\t\tif (!inference.handle && access('handle', alias))\n\t\t\tinference.handle = true\n\n\t\tif (!inference.beforeHandle && access('beforeHandle', alias))\n\t\t\tinference.beforeHandle = true\n\n\t\tif (!inference.afterHandle && access('afterHandle', alias))\n\t\t\tinference.afterHandle = true\n\n\t\tif (!inference.error && access('error', alias)) inference.error = true\n\n\t\tif (!inference.context && access('context', alias))\n\t\t\tinference.context = true\n\n\t\tif (!inference.store && access('store', alias)) inference.store = true\n\n\t\tif (!inference.set && access('set', alias)) inference.set = true\n\n\t\tif (\n\t\t\tinference.request &&\n\t\t\tinference.parse &&\n\t\t\tinference.transform &&\n\t\t\tinference.handle &&\n\t\t\tinference.beforeHandle &&\n\t\t\tinference.afterHandle &&\n\t\t\tinference.error &&\n\t\t\tinference.context &&\n\t\t\tinference.store &&\n\t\t\tinference.set\n\t\t)\n\t\t\tbreak\n\t}\n\n\treturn aliases\n}\n\nexport const sucrose = (\n\tlifeCycle: Sucrose.LifeCycle,\n\tinference: Sucrose.Inference = {\n\t\tqueries: [],\n\t\tquery: false,\n\t\theaders: false,\n\t\tbody: false,\n\t\tcookie: false,\n\t\tset: false,\n\t\tunknownQueries: false\n\t}\n): Sucrose.Inference => {\n\tconst events = []\n\n\tif (lifeCycle.handler && typeof lifeCycle.handler === 'function')\n\t\tevents.push(lifeCycle.handler)\n\n\tif (lifeCycle.beforeHandle?.length) events.push(...lifeCycle.beforeHandle)\n\tif (lifeCycle.parse?.length) events.push(...lifeCycle.parse)\n\tif (lifeCycle.error?.length) events.push(...lifeCycle.error)\n\tif (lifeCycle.transform?.length) events.push(...lifeCycle.transform)\n\tif (lifeCycle.afterHandle?.length) events.push(...lifeCycle.afterHandle)\n\tif (lifeCycle.mapResponse?.length) events.push(...lifeCycle.mapResponse)\n\tif (lifeCycle.request?.length) events.push(...lifeCycle.request)\n\tif (lifeCycle.onResponse?.length) events.push(...lifeCycle.onResponse)\n\n\tfor (const e of events) {\n\t\tif (!e) continue\n\n\t\tconst event = 'fn' in e ? e.fn : e\n\n\t\tconst [parameter, body, { isArrowReturn }] = separateFunction(\n\t\t\tevent.toString()\n\t\t)\n\n\t\tconst rootParameters = findParameterReference(parameter, inference)\n\t\tconst mainParameter = extractMainParameter(rootParameters)\n\n\t\tif (\n\t\t\tisArrowReturn &&\n\t\t\t(body === 'query' ||\n\t\t\t\t(rootParameters && body.startsWith(rootParameters + '.query')))\n\t\t) {\n\t\t\tinference.query = true\n\t\t\tinference.unknownQueries = true\n\t\t\tinference.queries = []\n\t\t}\n\n\t\tif (mainParameter) {\n\t\t\tconst aliases = findAlias(mainParameter, body)\n\t\t\taliases.splice(0, -1, mainParameter)\n\n\t\t\tinferBodyReference(body, aliases, inference)\n\t\t}\n\n\t\tconst context = rootParameters || mainParameter\n\t\tif (context && body.includes('return ' + context + '.query')) {\n\t\t\tinference.query = true\n\t\t\tinference.unknownQueries = true\n\t\t\tinference.queries = []\n\t\t}\n\n\t\tif (inference.query) {\n\t\t\tinferBodyReference(body, ['query'], inference)\n\n\t\t\tconst queryIndex = parameter.indexOf('query: {')\n\n\t\t\tif (queryIndex !== -1) {\n\t\t\t\tconst part = parameter.slice(queryIndex + 7)\n\t\t\t\tconst [start, end] = bracketPairRange(part)\n\n\t\t\t\tconst queryBracket = removeDefaultParameter(\n\t\t\t\t\tpart.slice(start, end)\n\t\t\t\t)\n\n\t\t\t\tfor (let query of queryBracket.slice(1, -1).split(',')) {\n\t\t\t\t\tconst index = query.indexOf(':')\n\n\t\t\t\t\t// Remove variable name casting: { a: b } should be b\n\t\t\t\t\tif (index !== -1) query = query.slice(0, index)\n\n\t\t\t\t\tquery = query.trim()\n\n\t\t\t\t\tif (query && !inference.queries.includes(query))\n\t\t\t\t\t\tinference.queries.push(query.trim())\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (\n\t\t\tinference.query &&\n\t\t\tinference.headers &&\n\t\t\tinference.body &&\n\t\t\tinference.cookie &&\n\t\t\tinference.set\n\t\t)\n\t\t\tbreak\n\t}\n\n\tif (!validateInferencedQueries(inference.queries)) {\n\t\tinference.unknownQueries = true\n\t\tinference.queries = []\n\t}\n\n\treturn inference\n}\n\n/**\n * Analyze if context is mentioned in body in a trace\n */\nexport const sucroseTrace = (\n\ttraces: TraceHandler[],\n\tinference: Sucrose.TraceInference = {\n\t\trequest: false,\n\t\tparse: false,\n\t\ttransform: false,\n\t\thandle: false,\n\t\tbeforeHandle: false,\n\t\tafterHandle: false,\n\t\terror: false,\n\t\tcontext: false,\n\t\tstore: false,\n\t\tset: false\n\t}\n) => {\n\tfor (const handler of traces) {\n\t\tconst [parameter, body] = separateFunction(handler.toString())\n\n\t\tconst rootParameters = findTraceParameterReference(parameter, inference)\n\t\tconst mainParameter = extractMainParameter(rootParameters)\n\n\t\tif (mainParameter) {\n\t\t\tconst aliases = findAlias(mainParameter, body)\n\t\t\taliases.splice(0, -1, mainParameter)\n\n\t\t\tinferTraceBodyReference(body, aliases, inference)\n\n\t\t\tcontinue\n\t\t}\n\n\t\tif (\n\t\t\tinference.request &&\n\t\t\tinference.parse &&\n\t\t\tinference.transform &&\n\t\t\tinference.handle &&\n\t\t\tinference.beforeHandle &&\n\t\t\tinference.afterHandle &&\n\t\t\tinference.error &&\n\t\t\tinference.context &&\n\t\t\tinference.store &&\n\t\t\tinference.set\n\t\t)\n\t\t\tbreak\n\t}\n\n\treturn inference\n}\n",
  "/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable no-constant-condition */\nimport type { Handler, LifeCycleStore, TraceHandler } from './types'\n\nexport namespace Sucrose {\n\texport interface Inference {\n\t\tqueries: string[]\n\t\tunknownQueries: boolean\n\t\tquery: boolean\n\t\theaders: boolean\n\t\tbody: boolean\n\t\tcookie: boolean\n\t\tset: boolean\n\t}\n\n\texport interface LifeCycle extends Partial<LifeCycleStore> {\n\t\thandler?: Handler\n\t}\n\n\texport interface TraceInference {\n\t\trequest: boolean\n\t\tparse: boolean\n\t\ttransform: boolean\n\t\thandle: boolean\n\t\tbeforeHandle: boolean\n\t\tafterHandle: boolean\n\t\terror: boolean\n\t\tcontext: boolean\n\t\tstore: boolean\n\t\tset: boolean\n\t}\n}\n\n/**\n * Separate stringified function body and paramter\n *\n * @example\n * ```typescript\n * separateFunction('async ({ hello }) => { return hello }') // => ['({ hello })', '{ return hello }']\n * ```\n */\nexport const separateFunction = (\n\tcode: string\n): [string, string, { isArrowReturn: boolean }] => {\n\tif (code.startsWith('async')) code = code.slice(6)\n\n\tlet index = -1\n\n\t// Starts with '(', is an arrow function\n\tif (code.charCodeAt(0) === 40) {\n\t\t// ? arrow function\n\t\tindex = code.indexOf(') => {\\n')\n\t\tif (index !== -1)\n\t\t\treturn [\n\t\t\t\tcode.slice(1, index),\n\t\t\t\tcode.slice(index + 5),\n\t\t\t\t{ isArrowReturn: false }\n\t\t\t]\n\n\t\t// ? Arrow return\n\t\tindex = code.indexOf(') => ')\n\t\tif (index !== -1)\n\t\t\treturn [\n\t\t\t\tcode.slice(1, index),\n\t\t\t\tcode.slice(index + 5),\n\t\t\t\t{ isArrowReturn: true }\n\t\t\t]\n\t}\n\n\t// Using function keyword\n\tif (code.startsWith('function')) {\n\t\tindex = code.indexOf('(')\n\t\tconst end = code.indexOf(')')\n\n\t\treturn [\n\t\t\tcode.slice(index + 1, end),\n\t\t\tcode.slice(end + 2),\n\t\t\t{\n\t\t\t\tisArrowReturn: false\n\t\t\t}\n\t\t]\n\t}\n\n\t// Probably Declare as method\n\tconst start = code.indexOf('(')\n\n\tif (start !== -1) {\n\t\tconst [parameter, body] = code.split('\\n', 2)\n\t\tconst end = parameter.lastIndexOf(')') + 1\n\n\t\treturn [\n\t\t\tparameter.slice(start, end),\n\t\t\t'{' + body,\n\t\t\t{\n\t\t\t\tisArrowReturn: false\n\t\t\t}\n\t\t]\n\t}\n\n\t// Unknown case\n\tconst x = code.split('\\n', 2)\n\n\treturn [x[0], x[1], { isArrowReturn: false }]\n}\n\n/**\n * Get range between bracket pair\n *\n * @example\n * ```typescript\n * bracketPairRange('hello: { world: { a } }, elysia') // [6, 20]\n * ```\n */\nexport const bracketPairRange = (parameter: string): [number, number] => {\n\tconst start = parameter.indexOf('{')\n\tif (start === -1) return [-1, 0]\n\n\tlet end = start + 1\n\tlet deep = 1\n\n\tfor (; end < parameter.length; end++) {\n\t\tconst char = parameter.charCodeAt(end)\n\n\t\t// Open bracket\n\t\tif (char === 123) deep++\n\t\t// Close bracket\n\t\telse if (char === 125) deep--\n\n\t\tif (deep === 0) break\n\t}\n\n\tif (deep !== 0) return [0, parameter.length]\n\n\treturn [start, end + 1]\n}\n\n/**\n * Similar to `bracketPairRange` but in reverse order\n * Get range between bracket pair from end to beginning\n *\n * @example\n * ```typescript\n * bracketPairRange('hello: { world: { a } }, elysia') // [6, 20]\n * ```\n */\nexport const bracketPairRangeReverse = (\n\tparameter: string\n): [number, number] => {\n\tconst end = parameter.lastIndexOf('}')\n\tif (end === -1) return [-1, 0]\n\n\tlet start = end - 1\n\tlet deep = 1\n\n\tfor (; start >= 0; start--) {\n\t\tconst char = parameter.charCodeAt(start)\n\n\t\t// Open bracket\n\t\tif (char === 125) deep++\n\t\t// Close bracket\n\t\telse if (char === 123) deep--\n\n\t\tif (deep === 0) break\n\t}\n\n\tif (deep !== 0) return [-1, 0]\n\n\treturn [start, end + 1]\n}\n\n/**\n * Retrieve only root paramters of a function\n *\n * @example\n * ```typescript\n * retrieveRootParameters('({ hello: { world: { a } }, elysia })') // => 'hello elysia'\n * ```\n */\nexport const retrieveRootParamters = (parameter: string) => {\n\t// Remove () and {}\n\tif (parameter.charCodeAt(0) === 40) parameter = parameter.slice(1, -1)\n\t// Using 2 because of the space\n\tif (parameter.charCodeAt(0) === 123) parameter = parameter.slice(2, -2)\n\n\twhile (true) {\n\t\tconst [start, end] = bracketPairRange(parameter)\n\t\tif (start === -1) break\n\n\t\tparameter = parameter.slice(0, start - 2) + parameter.slice(end + 1)\n\t}\n\n\treturn parameter.replace(/:/g, '').trim()\n}\n\n/**\n * Find inference from parameter\n *\n * @param parameter stringified parameter\n */\nexport const findParameterReference = (\n\tparameter: string,\n\tinference: Sucrose.Inference\n) => {\n\tconst root = retrieveRootParamters(parameter)\n\n\tif (!inference.query && root.includes('query')) inference.query = true\n\tif (!inference.headers && root.includes('headers')) inference.headers = true\n\tif (!inference.body && root.includes('body')) inference.body = true\n\tif (!inference.cookie && root.includes('cookie')) inference.cookie = true\n\tif (!inference.set && root.includes('set')) inference.set = true\n\n\treturn root\n}\n\n/**\n * Find inference from parameter\n *\n * @param parameter stringified parameter\n */\nexport const findTraceParameterReference = (\n\tparameter: string,\n\tinference: Sucrose.TraceInference\n) => {\n\tconst root = retrieveRootParamters(parameter)\n\n\tif (!inference.request && root.includes('request')) inference.request = true\n\tif (!inference.parse && root.includes('parse')) inference.parse = true\n\tif (!inference.transform && root.includes('transform'))\n\t\tinference.transform = true\n\tif (!inference.handle && root.includes('handle')) inference.handle = true\n\tif (!inference.beforeHandle && root.includes('beforeHandle'))\n\t\tinference.beforeHandle = true\n\tif (!inference.afterHandle && root.includes('afterHandle'))\n\t\tinference.afterHandle = true\n\tif (!inference.error && root.includes('error')) inference.error = true\n\tif (!inference.context && root.includes('context')) inference.context = true\n\tif (!inference.store && root.includes('store')) inference.store = true\n\tif (!inference.set && root.includes('set')) inference.set = true\n\n\treturn root\n}\n\nconst findEndIndex = (\n\ttype: string,\n\tcontent: string,\n\tindex?: number | undefined\n) => {\n\tconst newLineIndex = content.indexOf(type + '\\n', index)\n\tconst newTabIndex = content.indexOf(type + '\\t', index)\n\tconst commaIndex = content.indexOf(type + ',', index)\n\tconst semicolonIndex = content.indexOf(type + ';', index)\n\tconst emptyIndex = content.indexOf(type + ' ', index)\n\n\t// Pick the smallest index that is not -1 or 0\n\treturn (\n\t\t[newLineIndex, newTabIndex, commaIndex, semicolonIndex, emptyIndex]\n\t\t\t.filter((i) => i > 0)\n\t\t\t.sort((a, b) => a - b)[0] || -1\n\t)\n}\n\nconst findEndQueryBracketIndex = (\n\ttype: string,\n\tcontent: string,\n\tindex?: number | undefined\n) => {\n\tconst bracketEndIndex = content.indexOf(type + ']', index)\n\tconst singleQuoteIndex = content.indexOf(type + \"'\", index)\n\tconst doubleQuoteIndex = content.indexOf(type + '\"', index)\n\n\t// Pick the smallest index that is not -1 or 0\n\treturn (\n\t\t[bracketEndIndex, singleQuoteIndex, doubleQuoteIndex]\n\t\t\t.filter((i) => i > 0)\n\t\t\t.sort((a, b) => a - b)[0] || -1\n\t)\n}\n\n/**\n * Find alias of variable from function body\n *\n * @example\n * ```typescript\n * findAlias('body', '{ const a = body, b = body }') // => ['a', 'b']\n * ```\n */\nexport const findAlias = (type: string, body: string, depth = 0) => {\n\tif (depth > 5) return []\n\n\tconst aliases: string[] = []\n\n\tlet content = body\n\n\twhile (true) {\n\t\tlet index = findEndIndex(' = ' + type, content)\n\n\t\tif (index === -1) {\n\t\t\t/**\n\t\t\t * Check if pattern is at the end of the string\n\t\t\t *\n\t\t\t * @example\n\t\t\t * ```typescript\n\t\t\t * 'const a = body' // true\n\t\t\t * ```\n\t\t\t **/\n\t\t\tconst lastIndex = content.indexOf(' = ' + type)\n\n\t\t\tif (lastIndex + 3 + type.length !== content.length) break\n\n\t\t\tindex = lastIndex\n\t\t}\n\n\t\tconst part = content.slice(0, index)\n\t\t/**\n\t\t * aliased variable last character\n\t\t *\n\t\t * @example\n\t\t * ```typescript\n\t\t * const { hello } = body // } is the last character\n\t\t * ```\n\t\t **/\n\t\tlet variable = part.slice(part.lastIndexOf(' ') + 1)\n\n\t\t// Variable is using object destructuring, find the bracket pair\n\t\tif (variable === '}') {\n\t\t\tconst [start, end] = bracketPairRangeReverse(part)\n\n\t\t\taliases.push(content.slice(start, end))\n\n\t\t\tcontent = content.slice(index + 3 + type.length)\n\n\t\t\tcontinue\n\t\t}\n\n\t\t// Remove comma\n\t\twhile (variable.charCodeAt(0) === 44) variable = variable.slice(1)\n\t\twhile (variable.charCodeAt(0) === 9) variable = variable.slice(1)\n\n\t\taliases.push(variable)\n\t\tcontent = content.slice(index + 3 + type.length)\n\t}\n\n\tfor (const alias of aliases) {\n\t\tif (alias.charCodeAt(0) === 123) continue\n\n\t\tconst deepAlias = findAlias(alias, body)\n\t\tif (deepAlias.length > 0) aliases.push(...deepAlias)\n\t}\n\n\treturn aliases\n}\n\n// ? This is normalized to dot notation in Bun\n// const accessor = <T extends string, P extends string>(parent: T, prop: P) =>\n// \t[\n// \t\tparent + '.' + prop,\n// \t\tparent + '[\"' + prop + '\"]',\n// \t\tparent + \"['\" + prop + \"']\"\n// \t] as const\n\nexport const extractMainParameter = (parameter: string) => {\n\tif (!parameter) return\n\n\tconst hasComma = parameter.includes(',')\n\tif (!hasComma) {\n\t\t// This happens when spread operator is used as the only parameter\n\t\tif (parameter.includes('...'))\n\t\t\treturn parameter.slice(parameter.indexOf('...') + 3)\n\n\t\treturn parameter\n\t}\n\n\tconst spreadIndex = parameter.indexOf('...')\n\tif (spreadIndex === -1) return\n\n\t// Spread parameter is always the last parameter, no need for further checking\n\treturn parameter.slice(spreadIndex + 3).trimEnd()\n}\n\n/**\n * Analyze if context is mentioned in body\n */\nexport const inferBodyReference = (\n\tcode: string,\n\taliases: string[],\n\tinference: Sucrose.Inference\n) => {\n\tconst access = (type: string, alias: string) =>\n\t\tcode.includes(alias + '.' + type) ||\n\t\tcode.includes(alias + '[\"' + type + '\"]') ||\n\t\tcode.includes(alias + \"['\" + type + \"']\")\n\n\tfor (let alias of aliases) {\n\t\tif (!alias) continue\n\n\t\tif (alias.charCodeAt(0) === 123) {\n\t\t\talias = retrieveRootParamters(alias)\n\n\t\t\tif (!inference.query && alias.includes('query'))\n\t\t\t\tinference.query = true\n\n\t\t\tif (!inference.headers && alias.includes('headers'))\n\t\t\t\tinference.headers = true\n\n\t\t\tif (!inference.body && alias.includes('body')) inference.body = true\n\n\t\t\tif (!inference.cookie && alias.includes('cookie'))\n\t\t\t\tinference.cookie = true\n\n\t\t\tif (!inference.set && alias.includes('set')) inference.set = true\n\n\t\t\tcontinue\n\t\t}\n\n\t\t// ! Function is passed to another function, assume as all is accessed\n\t\tif (code.includes('(' + alias + ')')) {\n\t\t\tinference.query = true\n\t\t\tinference.headers = true\n\t\t\tinference.body = true\n\t\t\tinference.cookie = true\n\t\t\tinference.set = true\n\t\t\tinference.queries = []\n\t\t\tinference.unknownQueries = true\n\n\t\t\tbreak\n\t\t}\n\n\t\tif (!inference.query && access('query', alias)) inference.query = true\n\n\t\tif (\n\t\t\tcode.includes('return ' + alias) ||\n\t\t\tcode.includes('return ' + alias + '.query')\n\t\t) {\n\t\t\tinference.query = true\n\t\t\tinference.unknownQueries = true\n\t\t\tinference.queries = []\n\t\t}\n\n\t\tif (!inference.unknownQueries && inference.query) {\n\t\t\tlet keyword = alias + '.'\n\n\t\t\t// ? It's unlikely that user will use separate variable between c.query and query\n\t\t\tif (code.includes(keyword + 'query')) keyword = alias + '.query'\n\n\t\t\twhile (true) {\n\t\t\t\tlet start = code.indexOf(keyword)\n\n\t\t\t\t// ? This is normalized to dot notation in Bun\n\t\t\t\t// if (start === -1) {\n\t\t\t\t// \tisBracket = true\n\t\t\t\t// \tstart = code.indexOf(alias + '[\"')\n\t\t\t\t// }\n\n\t\t\t\t// if (start === -1) {\n\t\t\t\t// \tisBracket = true\n\t\t\t\t// \tstart = code.indexOf(alias + \"['\")\n\t\t\t\t// }\n\n\t\t\t\tif (start === -1 && code.indexOf(alias + '[') !== -1) {\n\t\t\t\t\t// ! Query is accessed using dynamic key, skip static parsing\n\t\t\t\t\tinference.queries = []\n\t\t\t\t\tinference.unknownQueries = true\n\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\tif (start !== -1) {\n\t\t\t\t\tlet end: number | undefined = findEndIndex(\n\t\t\t\t\t\t'',\n\t\t\t\t\t\tcode,\n\t\t\t\t\t\tstart + keyword.length + 1\n\t\t\t\t\t)\n\n\t\t\t\t\t// ? Do not remove, might need to use on other runtime\n\t\t\t\t\t// If need, replace above code with this one\n\t\t\t\t\t// let end: number | undefined = isBracket\n\t\t\t\t\t// \t? findEndQueryBracketIndex(\n\t\t\t\t\t// \t\t\t'',\n\t\t\t\t\t// \t\t\tcode,\n\t\t\t\t\t// \t\t\tstart + keyword.length + 1\n\t\t\t\t\t// \t  )\n\t\t\t\t\t// \t: findEndIndex('', code, start + keyword.length + 1)\n\n\t\t\t\t\tif (end === -1) end = undefined\n\n\t\t\t\t\tconst index = start + alias.length + 1\n\t\t\t\t\tcode = code.slice(start + alias.length + 1)\n\t\t\t\t\tlet query = code.slice(0, end ? end - index : end).trimEnd()\n\n\t\t\t\t\t// Remove nested dot\n\t\t\t\t\twhile (start !== -1) {\n\t\t\t\t\t\tstart = query.indexOf('.')\n\n\t\t\t\t\t\tif (start !== -1) query = query.slice(start + 1)\n\t\t\t\t\t}\n\n\t\t\t\t\t// Remove semi-colon\n\t\t\t\t\tif (query.charCodeAt(query.length - 1) === 59)\n\t\t\t\t\t\tquery = query.slice(0, -1)\n\n\t\t\t\t\t// Remove comma\n\t\t\t\t\tif (query.charCodeAt(query.length - 1) === 44)\n\t\t\t\t\t\tquery = query.slice(0, -1)\n\n\t\t\t\t\t// Remove closing square bracket\n\t\t\t\t\tif (query.charCodeAt(query.length - 1) === 93)\n\t\t\t\t\t\tquery = query.slice(0, -1)\n\n\t\t\t\t\t// Remove closing bracket\n\t\t\t\t\tif (query.charCodeAt(query.length - 1) === 41)\n\t\t\t\t\t\tquery = query.slice(0, -1)\n\n\t\t\t\t\t// ? Do not remove, might need to use on other runtime\n\t\t\t\t\t// if (isBracket) query = query.replaceAll(/(\"|')/g, '')\n\n\t\t\t\t\tif (query && !inference.queries.includes(query)) {\n\t\t\t\t\t\tinference.queries.push(query)\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif (!inference.headers && access('headers', alias))\n\t\t\tinference.headers = true\n\n\t\tif (!inference.body && access('body', alias)) inference.body = true\n\n\t\tif (!inference.cookie && access('cookie', alias))\n\t\t\tinference.cookie = true\n\n\t\tif (!inference.set && access('set', alias)) inference.set = true\n\n\t\tif (\n\t\t\tinference.query &&\n\t\t\tinference.headers &&\n\t\t\tinference.body &&\n\t\t\tinference.cookie &&\n\t\t\tinference.set\n\t\t)\n\t\t\tbreak\n\t}\n\n\treturn aliases\n}\n\nexport const removeDefaultParameter = (parameter: string) => {\n\twhile (true) {\n\t\tconst index = parameter.indexOf('=')\n\t\tif (index === -1) break\n\n\t\tconst commaIndex = parameter.indexOf(',', index)\n\t\tconst bracketIndex = parameter.indexOf('}', index)\n\n\t\tconst end =\n\t\t\t[commaIndex, bracketIndex]\n\t\t\t\t.filter((i) => i > 0)\n\t\t\t\t.sort((a, b) => a - b)[0] || -1\n\n\t\tif (end === -1) {\n\t\t\tparameter = parameter.slice(0, index)\n\n\t\t\tbreak\n\t\t}\n\n\t\tparameter = parameter.slice(0, index) + parameter.slice(end)\n\t}\n\n\treturn parameter\n\t\t.split(',')\n\t\t.map((i) => i.trim())\n\t\t.join(', ')\n}\n\nexport const validateInferencedQueries = (queries: string[]) => {\n\tfor (const query of queries) {\n\t\tif (query.charCodeAt(0) === 123) return false\n\t\tif (query.indexOf(\"'\") !== -1) return false\n\t\tif (query.indexOf('\"') !== -1) return false\n\t\tif (query.indexOf('\\n') !== -1) return false\n\t\tif (query.indexOf('\\t') !== -1) return false\n\t}\n\n\treturn true\n}\n\n/**\n * Analyze if context is mentioned in body\n */\nexport const inferTraceBodyReference = (\n\tcode: string,\n\taliases: string[],\n\tinference: Sucrose.TraceInference\n) => {\n\tconst access = (type: string, alias: string) =>\n\t\tcode.includes(type + '.' + alias) ||\n\t\tcode.includes(type + '[\"' + alias + '\"]') ||\n\t\tcode.includes(type + \"['\" + alias + \"']\")\n\n\tfor (let alias of aliases) {\n\t\tif (alias.charCodeAt(0) === 123) {\n\t\t\talias = retrieveRootParamters(alias)\n\n\t\t\tif (!inference.request && alias.includes('request'))\n\t\t\t\tinference.request = true\n\n\t\t\tif (!inference.parse && alias.includes('parse'))\n\t\t\t\tinference.parse = true\n\n\t\t\tif (!inference.transform && alias.includes('transform'))\n\t\t\t\tinference.transform = true\n\n\t\t\tif (!inference.handle && alias.includes('handle'))\n\t\t\t\tinference.handle = true\n\n\t\t\tif (!inference.beforeHandle && alias.includes('beforeHandle'))\n\t\t\t\tinference.beforeHandle = true\n\n\t\t\tif (!inference.afterHandle && alias.includes('afterHandle'))\n\t\t\t\tinference.afterHandle = true\n\n\t\t\tif (!inference.error && alias.includes('error'))\n\t\t\t\tinference.error = true\n\n\t\t\tif (!inference.context && alias.includes('context'))\n\t\t\t\tinference.context = true\n\n\t\t\tif (!inference.store && alias.includes('store'))\n\t\t\t\tinference.store = true\n\n\t\t\tif (!inference.set && alias.includes('set')) inference.set = true\n\n\t\t\tcontinue\n\t\t}\n\n\t\t// ! Function is passed to another function, assume as all is accessed\n\t\tif (code.includes('(' + alias + ')')) {\n\t\t\tinference.request = true\n\t\t\tinference.parse = true\n\t\t\tinference.transform = true\n\t\t\tinference.handle = true\n\t\t\tinference.beforeHandle = true\n\t\t\tinference.afterHandle = true\n\t\t\tinference.error = true\n\t\t\tinference.context = true\n\t\t\tinference.store = true\n\t\t\tinference.set = true\n\n\t\t\tbreak\n\t\t}\n\n\t\tif (!inference.request && access('request', alias))\n\t\t\tinference.request = true\n\n\t\tif (!inference.parse && access('parse', alias)) inference.parse = true\n\n\t\tif (!inference.transform && access('transform', alias))\n\t\t\tinference.transform = true\n\n\t\tif (!inference.handle && access('handle', alias))\n\t\t\tinference.handle = true\n\n\t\tif (!inference.beforeHandle && access('beforeHandle', alias))\n\t\t\tinference.beforeHandle = true\n\n\t\tif (!inference.afterHandle && access('afterHandle', alias))\n\t\t\tinference.afterHandle = true\n\n\t\tif (!inference.error && access('error', alias)) inference.error = true\n\n\t\tif (!inference.context && access('context', alias))\n\t\t\tinference.context = true\n\n\t\tif (!inference.store && access('store', alias)) inference.store = true\n\n\t\tif (!inference.set && access('set', alias)) inference.set = true\n\n\t\tif (\n\t\t\tinference.request &&\n\t\t\tinference.parse &&\n\t\t\tinference.transform &&\n\t\t\tinference.handle &&\n\t\t\tinference.beforeHandle &&\n\t\t\tinference.afterHandle &&\n\t\t\tinference.error &&\n\t\t\tinference.context &&\n\t\t\tinference.store &&\n\t\t\tinference.set\n\t\t)\n\t\t\tbreak\n\t}\n\n\treturn aliases\n}\n\nexport const sucrose = (\n\tlifeCycle: Sucrose.LifeCycle,\n\tinference: Sucrose.Inference = {\n\t\tqueries: [],\n\t\tquery: false,\n\t\theaders: false,\n\t\tbody: false,\n\t\tcookie: false,\n\t\tset: false,\n\t\tunknownQueries: false\n\t}\n): Sucrose.Inference => {\n\tconst events = []\n\n\tif (lifeCycle.handler && typeof lifeCycle.handler === 'function')\n\t\tevents.push(lifeCycle.handler)\n\n\tif (lifeCycle.beforeHandle?.length) events.push(...lifeCycle.beforeHandle)\n\tif (lifeCycle.parse?.length) events.push(...lifeCycle.parse)\n\tif (lifeCycle.error?.length) events.push(...lifeCycle.error)\n\tif (lifeCycle.transform?.length) events.push(...lifeCycle.transform)\n\tif (lifeCycle.afterHandle?.length) events.push(...lifeCycle.afterHandle)\n\tif (lifeCycle.mapResponse?.length) events.push(...lifeCycle.mapResponse)\n\tif (lifeCycle.request?.length) events.push(...lifeCycle.request)\n\tif (lifeCycle.onResponse?.length) events.push(...lifeCycle.onResponse)\n\n\tfor (const e of events) {\n\t\tif (!e) continue\n\n\t\tconst event = 'fn' in e ? e.fn : e\n\n\t\tconst [parameter, body, { isArrowReturn }] = separateFunction(\n\t\t\tevent.toString()\n\t\t)\n\n\t\tconst rootParameters = findParameterReference(parameter, inference)\n\t\tconst mainParameter = extractMainParameter(rootParameters)\n\n\t\tif (\n\t\t\tisArrowReturn &&\n\t\t\t(body === 'query' ||\n\t\t\t\t(rootParameters && body.startsWith(rootParameters + '.query')))\n\t\t) {\n\t\t\tinference.query = true\n\t\t\tinference.unknownQueries = true\n\t\t\tinference.queries = []\n\t\t}\n\n\t\tif (mainParameter) {\n\t\t\tconst aliases = findAlias(mainParameter, body)\n\t\t\taliases.splice(0, -1, mainParameter)\n\n\t\t\tinferBodyReference(body, aliases, inference)\n\t\t}\n\n\t\tconst context = rootParameters || mainParameter\n\t\tif (context && body.includes('return ' + context + '.query')) {\n\t\t\tinference.query = true\n\t\t\tinference.unknownQueries = true\n\t\t\tinference.queries = []\n\t\t}\n\n\t\tif (inference.query) {\n\t\t\tinferBodyReference(body, ['query'], inference)\n\n\t\t\tconst queryIndex = parameter.indexOf('query: {')\n\n\t\t\tif (queryIndex !== -1) {\n\t\t\t\tconst part = parameter.slice(queryIndex + 7)\n\t\t\t\tconst [start, end] = bracketPairRange(part)\n\n\t\t\t\tconst queryBracket = removeDefaultParameter(\n\t\t\t\t\tpart.slice(start, end)\n\t\t\t\t)\n\n\t\t\t\tfor (let query of queryBracket.slice(1, -1).split(',')) {\n\t\t\t\t\tconst index = query.indexOf(':')\n\n\t\t\t\t\t// Remove variable name casting: { a: b } should be b\n\t\t\t\t\tif (index !== -1) query = query.slice(0, index)\n\n\t\t\t\t\tquery = query.trim()\n\n\t\t\t\t\tif (query && !inference.queries.includes(query))\n\t\t\t\t\t\tinference.queries.push(query.trim())\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (\n\t\t\tinference.query &&\n\t\t\tinference.headers &&\n\t\t\tinference.body &&\n\t\t\tinference.cookie &&\n\t\t\tinference.set\n\t\t)\n\t\t\tbreak\n\t}\n\n\tif (!validateInferencedQueries(inference.queries)) {\n\t\tinference.unknownQueries = true\n\t\tinference.queries = []\n\t}\n\n\treturn inference\n}\n\n/**\n * Analyze if context is mentioned in body in a trace\n */\nexport const sucroseTrace = (\n\ttraces: TraceHandler[],\n\tinference: Sucrose.TraceInference = {\n\t\trequest: false,\n\t\tparse: false,\n\t\ttransform: false,\n\t\thandle: false,\n\t\tbeforeHandle: false,\n\t\tafterHandle: false,\n\t\terror: false,\n\t\tcontext: false,\n\t\tstore: false,\n\t\tset: false\n\t}\n) => {\n\tfor (const handler of traces) {\n\t\tconst [parameter, body] = separateFunction(handler.toString())\n\n\t\tconst rootParameters = findTraceParameterReference(parameter, inference)\n\t\tconst mainParameter = extractMainParameter(rootParameters)\n\n\t\tif (mainParameter) {\n\t\t\tconst aliases = findAlias(mainParameter, body)\n\t\t\taliases.splice(0, -1, mainParameter)\n\n\t\t\tinferTraceBodyReference(body, aliases, inference)\n\n\t\t\tcontinue\n\t\t}\n\n\t\tif (\n\t\t\tinference.request &&\n\t\t\tinference.parse &&\n\t\t\tinference.transform &&\n\t\t\tinference.handle &&\n\t\t\tinference.beforeHandle &&\n\t\t\tinference.afterHandle &&\n\t\t\tinference.error &&\n\t\t\tinference.context &&\n\t\t\tinference.store &&\n\t\t\tinference.set\n\t\t)\n\t\t\tbreak\n\t}\n\n\treturn inference\n}\n",
  "import type { TSchema } from '@sinclair/typebox'\nimport { Value } from '@sinclair/typebox/value'\nimport type { TypeCheck } from '@sinclair/typebox/compiler'\n\nimport { StatusMap, InvertedStatusMap } from './utils'\n\n// ? Cloudflare worker support\nconst env =\n\ttypeof Bun !== 'undefined'\n\t\t? Bun.env\n\t\t: typeof process !== 'undefined'\n\t\t? process?.env\n\t\t: undefined\n\nexport const ERROR_CODE = Symbol('ElysiaErrorCode')\nexport const ELYSIA_RESPONSE = Symbol('ElysiaResponse')\nexport type ELYSIA_RESPONSE = typeof ELYSIA_RESPONSE\n\nexport const isProduction = (env?.NODE_ENV ?? env?.ENV) === 'production'\n\nexport type ElysiaErrors =\n\t| InternalServerError\n\t| NotFoundError\n\t| ParseError\n\t| ValidationError\n\t| InvalidCookieSignature\n\nexport const error = <\n\tconst Code extends number | keyof StatusMap,\n\tconst T = Code extends keyof InvertedStatusMap\n\t\t? InvertedStatusMap[Code]\n\t\t: Code,\n\tconst Status extends Code extends keyof StatusMap\n\t\t? StatusMap[Code]\n\t\t: Code = Code extends keyof StatusMap ? StatusMap[Code] : Code\n>(\n\tcode: Code,\n\tresponse?: T\n): {\n\t[ELYSIA_RESPONSE]: Status\n\tresponse: T\n\t_type: {\n\t\t[ERROR_CODE in Status]: T\n\t}\n} =>\n\t({\n\t\t// @ts-expect-error\n\t\t[ELYSIA_RESPONSE]: StatusMap[code] ?? code,\n\t\tresponse:\n\t\t\tresponse ??\n\t\t\t(code in InvertedStatusMap\n\t\t\t\t? // @ts-expect-error Always correct\n\t\t\t\t  InvertedStatusMap[code]\n\t\t\t\t: code),\n\t\t_type: undefined as any\n\t} as const)\n\nexport class InternalServerError extends Error {\n\tcode = 'INTERNAL_SERVER_ERROR'\n\tstatus = 500\n\n\tconstructor(message?: string) {\n\t\tsuper(message ?? 'INTERNAL_SERVER_ERROR')\n\t}\n}\n\nexport class NotFoundError extends Error {\n\tcode = 'NOT_FOUND'\n\tstatus = 404\n\n\tconstructor(message?: string) {\n\t\tsuper(message ?? 'NOT_FOUND')\n\t}\n}\n\nexport class ParseError extends Error {\n\tcode = 'PARSE'\n\tstatus = 400\n\n\tconstructor(message?: string, public body?: unknown) {\n\t\tsuper(message ?? 'PARSE')\n\t}\n}\n\nexport class InvalidCookieSignature extends Error {\n\tcode = 'INVALID_COOKIE_SIGNATURE'\n\tstatus = 400\n\n\tconstructor(public key: string, message?: string) {\n\t\tsuper(message ?? `\"${key}\" has invalid cookie signature`)\n\t}\n}\n\nexport class ValidationError extends Error {\n\tcode = 'VALIDATION'\n\tstatus = 422\n\n\tconstructor(\n\t\tpublic type: string,\n\t\tpublic validator: TSchema | TypeCheck<any>,\n\t\tpublic value: unknown\n\t) {\n\t\t// @ts-expect-error\n\t\tif (typeof value === 'object' && ELYSIA_RESPONSE in value)\n\t\t\t// @ts-expect-error\n\t\t\tvalue = value.response\n\n\t\tconst error = isProduction\n\t\t\t? undefined\n\t\t\t: 'Errors' in validator\n\t\t\t? validator.Errors(value).First()\n\t\t\t: Value.Errors(validator, value).First()\n\n\t\tconst customError = error?.schema.error\n\t\t\t? typeof error.schema.error === 'function'\n\t\t\t\t? error.schema.error(type, validator, value)\n\t\t\t\t: error.schema.error\n\t\t\t: undefined\n\n\t\tconst accessor = error?.path || 'root'\n\t\tlet message = ''\n\n\t\tif (customError) {\n\t\t\tmessage =\n\t\t\t\ttypeof customError === 'object'\n\t\t\t\t\t? JSON.stringify(customError)\n\t\t\t\t\t: customError + ''\n\t\t} else if (isProduction) {\n\t\t\tmessage = JSON.stringify({\n\t\t\t\ttype: 'validation',\n\t\t\t\ton: type,\n\t\t\t\tmessage: error?.message,\n\t\t\t\tfound: value\n\t\t\t})\n\t\t} else {\n\t\t\t// @ts-ignore private field\n\t\t\tconst schema = validator?.schema ?? validator\n\t\t\tconst errors =\n\t\t\t\t'Errors' in validator\n\t\t\t\t\t? [...validator.Errors(value)]\n\t\t\t\t\t: [...Value.Errors(validator, value)]\n\n\t\t\tlet expected\n\n\t\t\ttry {\n\t\t\t\texpected = Value.Create(schema)\n\t\t\t} catch (error) {\n\t\t\t\texpected = {\n\t\t\t\t\ttype: 'Could not create expected value',\n\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\tmessage: error?.message,\n\t\t\t\t\terror\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmessage = JSON.stringify(\n\t\t\t\t{\n\t\t\t\t\ttype: 'validation',\n\t\t\t\t\ton: type,\n\t\t\t\t\tproperty: accessor,\n\t\t\t\t\tmessage: error?.message,\n\t\t\t\t\texpected,\n\t\t\t\t\tfound: value,\n\t\t\t\t\terrors\n\t\t\t\t},\n\t\t\t\tnull,\n\t\t\t\t2\n\t\t\t)\n\t\t}\n\n\t\tsuper(message)\n\n\t\tObject.setPrototypeOf(this, ValidationError.prototype)\n\t}\n\n\tget all() {\n\t\treturn [...this.validator.Errors(this.value)]\n\t}\n\n\tstatic simplifyModel(validator: TSchema | TypeCheck<any>) {\n\t\t// @ts-ignore\n\t\tconst model = 'schema' in validator ? validator.schema : validator\n\n\t\ttry {\n\t\t\treturn Value.Create(model)\n\t\t} catch {\n\t\t\treturn model\n\t\t}\n\t}\n\n\tget model() {\n\t\treturn ValidationError.simplifyModel(this.validator)\n\t}\n\n\ttoResponse(headers?: Record<string, any>) {\n\t\treturn new Response(this.message, {\n\t\t\tstatus: 400,\n\t\t\theaders: {\n\t\t\t\t...headers,\n\t\t\t\t'content-type': 'application/json'\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "import { Kind, TSchema } from '@sinclair/typebox'\nimport { Value } from '@sinclair/typebox/value'\nimport { TypeCheck, TypeCompiler } from '@sinclair/typebox/compiler'\n\nimport { t } from '.'\nimport { isNotEmpty } from './handler'\n\nimport type {\n\tLifeCycleStore,\n\tLocalHook,\n\tMaybeArray,\n\tInputSchema,\n\tBaseMacro,\n\tLifeCycleType,\n\tHookContainer,\n\tGracefulHandler,\n\tPreHandler,\n\tBodyHandler,\n\tTransformHandler,\n\tOptionalHandler,\n\tAfterHandler,\n\tMapResponse,\n\tVoidHandler,\n\tErrorHandler\n} from './types'\nimport type { CookieOptions } from './cookies'\nimport { Sucrose } from './sucrose'\n\nexport const replaceUrlPath = (url: string, pathname: string) => {\n\tconst urlObject = new URL(url)\n\turlObject.pathname = pathname\n\treturn urlObject.toString()\n}\n\nconst isClass = (v: Object) =>\n\t(typeof v === 'function' && /^\\s*class\\s+/.test(v.toString())) ||\n\t// Handle import * as Sentry from '@sentry/bun'\n\t// This also handle [object Date], [object Array]\n\t// and FFI value like [object Prisma]\n\tv.toString().startsWith('[object ') ||\n\t// If object prototype is not pure, then probably a class-like object\n\tisNotEmpty(Object.getPrototypeOf(v))\n\nconst isObject = (item: any): item is Object =>\n\titem && typeof item === 'object' && !Array.isArray(item)\n\nexport const mergeDeep = <\n\tA extends Record<string, any>,\n\tB extends Record<string, any>\n>(\n\ttarget: A,\n\tsource: B,\n\t{\n\t\tskipKeys\n\t}: {\n\t\tskipKeys?: string[]\n\t} = {}\n): A & B => {\n\tif (isObject(target) && isObject(source))\n\t\tfor (const [key, value] of Object.entries(source)) {\n\t\t\tif (skipKeys?.includes(key)) continue\n\n\t\t\tif (!isObject(value) || !(key in target) || isClass(value)) {\n\t\t\t\ttarget[key as keyof typeof target] = value\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\ttarget[key as keyof typeof target] = mergeDeep(\n\t\t\t\t(target as any)[key] as any,\n\t\t\t\tvalue\n\t\t\t)\n\t\t}\n\n\treturn target as A & B\n}\nexport const mergeCookie = <const A extends Object, const B extends Object>(\n\ta: A,\n\tb: B\n): A & B => {\n\t// @ts-ignore\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tconst { properties: _, ...target } = a ?? {}\n\n\t// @ts-ignore\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tconst { properties: __, ...source } = b ?? {}\n\n\treturn mergeDeep(target, source) as A & B\n}\n\nexport const mergeObjectArray = <T extends HookContainer>(\n\ta: T | T[] = [],\n\tb: T | T[] = []\n): T[] => {\n\tif (!a) return []\n\tif (!b) return a as any\n\n\t// ! Must copy to remove side-effect\n\tconst array = <T[]>[]\n\tconst checksums = <(number | undefined)[]>[]\n\n\tif (!Array.isArray(a)) a = [a]\n\tif (!Array.isArray(b)) b = [b]\n\n\tfor (const item of a) {\n\t\tarray.push(item)\n\n\t\tif (item.checksum) checksums.push(item.checksum)\n\t}\n\n\tfor (const item of b)\n\t\tif (!checksums.includes(item.checksum)) array.push(item)\n\n\treturn array\n}\n\nexport const primitiveHooks = [\n\t'start',\n\t'request',\n\t'parse',\n\t'transform',\n\t'resolve',\n\t'beforeHandle',\n\t'afterHandle',\n\t'onResponse',\n\t'mapResponse',\n\t'trace',\n\t'error',\n\t'stop',\n\t'body',\n\t'headers',\n\t'params',\n\t'query',\n\t'response',\n\t'type',\n\t'detail'\n] as const\n\nconst primitiveHookMap = primitiveHooks.reduce(\n\t(acc, x) => ((acc[x] = true), acc),\n\t{} as Record<string, boolean>\n)\n\nexport const mergeResponse = (\n\ta: InputSchema['response'],\n\tb: InputSchema['response']\n) => {\n\t// If both are Record<number, ...> then merge them,\n\t// giving preference to b.\n\ttype RecordNumber = Record<number, any>\n\tconst isRecordNumber = (x: typeof a | typeof b): x is RecordNumber =>\n\t\ttypeof x === 'object' && Object.keys(x).every(isNumericString)\n\n\tif (isRecordNumber(a) && isRecordNumber(b))\n\t\treturn { ...(a as RecordNumber), ...(b as RecordNumber) }\n\n\treturn b ?? a\n}\n\nexport const mergeHook = (\n\ta?: LifeCycleStore,\n\tb?: LocalHook<any, any, any, any, any, any, any>,\n\t{ allowMacro = false }: { allowMacro?: boolean } = {}\n): LifeCycleStore => {\n\t// In case if merging union is need\n\t// const customAStore: Record<string, unknown> = {}\n\t// const customBStore: Record<string, unknown> = {}\n\n\t// for (const [key, value] of Object.entries(a)) {\n\t// \tif (primitiveHooks.includes(key as any)) continue\n\n\t// \tcustomAStore[key] = value\n\t// }\n\n\t// for (const [key, value] of Object.entries(b)) {\n\t// \tif (primitiveHooks.includes(key as any)) continue\n\n\t// \tcustomBStore[key] = value\n\t// }\n\n\t// const unioned = Object.keys(customAStore).filter((x) =>\n\t// \tObject.keys(customBStore).includes(x)\n\t// )\n\n\t// // Must provide empty object to prevent reference side-effect\n\t// const customStore = Object.assign({}, customAStore, customBStore)\n\n\t// for (const union of unioned)\n\t// \tcustomStore[union] = mergeObjectArray(\n\t// \t\tcustomAStore[union],\n\t// \t\tcustomBStore[union]\n\t// \t)\n\n\tconst rest = allowMacro\n\t\t? {\n\t\t\t\t...a,\n\t\t\t\t...b\n\t\t\t}\n\t\t: undefined\n\n\treturn {\n\t\t...rest,\n\t\t// Merge local hook first\n\t\t// @ts-ignore\n\t\tbody: b?.body ?? a?.body,\n\t\t// @ts-ignore\n\t\theaders: b?.headers ?? a?.headers,\n\t\t// @ts-ignore\n\t\tparams: b?.params ?? a?.params,\n\t\t// @ts-ignore\n\t\tquery: b?.query ?? a?.query,\n\t\t// ? This order is correct - SaltyAom\n\t\tresponse: mergeResponse(\n\t\t\t// @ts-ignore\n\t\t\ta?.response,\n\t\t\t// @ts-ignore\n\t\t\tb?.response\n\t\t),\n\t\ttype: a?.type || b?.type,\n\t\tdetail: mergeDeep(\n\t\t\t// @ts-ignore\n\t\t\tb?.detail ?? {},\n\t\t\t// @ts-ignore\n\t\t\ta?.detail ?? {}\n\t\t),\n\t\tparse: mergeObjectArray(a?.parse as any, b?.parse),\n\t\ttransform: mergeObjectArray(a?.transform, b?.transform),\n\t\tbeforeHandle: mergeObjectArray(a?.beforeHandle, b?.beforeHandle),\n\t\tafterHandle: mergeObjectArray(a?.afterHandle, b?.afterHandle),\n\t\tonResponse: mergeObjectArray(a?.onResponse, b?.onResponse) as any,\n\t\tmapResponse: mergeObjectArray(a?.mapResponse, b?.mapResponse) as any,\n\t\ttrace: mergeObjectArray(a?.trace, b?.trace) as any,\n\t\terror: mergeObjectArray(a?.error, b?.error)\n\t}\n}\n\nexport const getSchemaValidator = (\n\ts: TSchema | string | undefined,\n\t{\n\t\tmodels = {},\n\t\tdynamic = false,\n\t\tnormalize = false,\n\t\tadditionalProperties = normalize\n\t}: {\n\t\tmodels?: Record<string, TSchema>\n\t\tadditionalProperties?: boolean\n\t\tdynamic?: boolean\n\t\tnormalize?: boolean\n\t}\n) => {\n\tif (!s) return\n\tif (typeof s === 'string' && !(s in models)) return\n\n\tconst schema: TSchema = typeof s === 'string' ? models[s] : s\n\n\t// @ts-ignore\n\tif (schema.type === 'object' && 'additionalProperties' in schema === false)\n\t\tschema.additionalProperties = additionalProperties\n\n\tconst cleaner = (value: unknown) => Value.Clean(schema, value)\n\n\tif (dynamic) {\n\t\tconst validator = {\n\t\t\tschema,\n\t\t\treferences: '',\n\t\t\tcheckFunc: () => {},\n\t\t\tcode: '',\n\t\t\tCheck: (value: unknown) => Value.Check(schema, value),\n\t\t\tErrors: (value: unknown) => Value.Errors(schema, value),\n\t\t\tCode: () => ''\n\t\t} as unknown as TypeCheck<TSchema>\n\n\t\tif (normalize && schema.additionalProperties === true)\n\t\t\t// @ts-ignore\n\t\t\tvalidator.Clean = cleaner\n\n\t\t// @ts-ignore\n\t\tif (schema.config) {\n\t\t\t// @ts-ignore\n\t\t\tvalidator.config = schema.config\n\n\t\t\t// @ts-ignore\n\t\t\tif (validator?.schema?.config)\n\t\t\t\t// @ts-ignore\n\t\t\t\tdelete validator.schema.config\n\t\t}\n\n\t\treturn validator\n\t}\n\n\tconst compiled = TypeCompiler.Compile(schema, Object.values(models))\n\n\t// @ts-expect-error\n\tcompiled.Clean = cleaner\n\n\t// @ts-ignore\n\tif (schema.config) {\n\t\t// @ts-ignore\n\t\tcompiled.config = schema.config\n\n\t\t// @ts-ignore\n\t\tif (compiled?.schema?.config)\n\t\t\t// @ts-ignore\n\t\t\tdelete compiled.schema.config\n\t}\n\n\treturn compiled\n}\n\nexport const getResponseSchemaValidator = (\n\ts: InputSchema['response'] | undefined,\n\t{\n\t\tmodels = {},\n\t\tdynamic = false,\n\t\tnormalize = false,\n\t\tadditionalProperties = normalize\n\t}: {\n\t\tmodels?: Record<string, TSchema>\n\t\tadditionalProperties?: boolean\n\t\tdynamic?: boolean\n\t\tnormalize?: boolean\n\t}\n): Record<number, TypeCheck<any>> | undefined => {\n\tif (!s) return\n\tif (typeof s === 'string' && !(s in models)) return\n\n\tconst maybeSchemaOrRecord = typeof s === 'string' ? models[s] : s\n\n\tconst compile = (schema: TSchema, references?: TSchema[]) => {\n\t\t// eslint-disable-next-line sonarjs/no-identical-functions\n\t\t// Sonar being delulu, schema is not identical\n\t\tconst cleaner = (value: unknown) => Value.Clean(schema, value)\n\n\t\tif (dynamic)\n\t\t\treturn {\n\t\t\t\tschema,\n\t\t\t\treferences: '',\n\t\t\t\tcheckFunc: () => {},\n\t\t\t\tcode: '',\n\t\t\t\tCheck: (value: unknown) => Value.Check(schema, value),\n\t\t\t\tErrors: (value: unknown) => Value.Errors(schema, value),\n\t\t\t\tCode: () => ''\n\t\t\t} as unknown as TypeCheck<TSchema>\n\n\t\tconst compiledValidator = TypeCompiler.Compile(schema, references)\n\n\t\tif (normalize && schema.additionalProperties === true)\n\t\t\t// @ts-ignore\n\t\t\tcompiledValidator.Clean = cleaner\n\n\t\treturn compiledValidator\n\t}\n\n\tif (Kind in maybeSchemaOrRecord) {\n\t\tif ('additionalProperties' in maybeSchemaOrRecord === false)\n\t\t\tmaybeSchemaOrRecord.additionalProperties = additionalProperties\n\n\t\treturn {\n\t\t\t200: compile(maybeSchemaOrRecord, Object.values(models))\n\t\t}\n\t}\n\n\tconst record: Record<number, TypeCheck<any>> = {}\n\n\tObject.keys(maybeSchemaOrRecord).forEach((status): TSchema | undefined => {\n\t\tconst maybeNameOrSchema = maybeSchemaOrRecord[+status]\n\n\t\tif (typeof maybeNameOrSchema === 'string') {\n\t\t\tif (maybeNameOrSchema in models) {\n\t\t\t\tconst schema = models[maybeNameOrSchema]\n\t\t\t\tschema.type === 'object' &&\n\t\t\t\t\t'additionalProperties' in schema === false\n\n\t\t\t\t// Inherits model maybe already compiled\n\t\t\t\trecord[+status] =\n\t\t\t\t\tKind in schema\n\t\t\t\t\t\t? compile(schema, Object.values(models))\n\t\t\t\t\t\t: schema\n\t\t\t}\n\n\t\t\treturn undefined\n\t\t}\n\n\t\tif (\n\t\t\tmaybeNameOrSchema.type === 'object' &&\n\t\t\t'additionalProperties' in maybeNameOrSchema === false\n\t\t)\n\t\t\tmaybeNameOrSchema.additionalProperties = additionalProperties\n\n\t\t// Inherits model maybe already compiled\n\t\trecord[+status] =\n\t\t\tKind in maybeNameOrSchema\n\t\t\t\t? compile(maybeNameOrSchema, Object.values(models))\n\t\t\t\t: maybeNameOrSchema\n\t})\n\n\treturn record\n}\n\nconst isBun = typeof Bun !== 'undefined'\nconst hasHash = isBun && typeof Bun.hash === 'function'\n\n// https://stackoverflow.com/a/52171480\nexport const checksum = (s: string) => {\n\tif (hasHash) return Bun.hash(s) as number\n\n\tlet h = 9\n\n\tfor (let i = 0; i < s.length; ) h = Math.imul(h ^ s.charCodeAt(i++), 9 ** 9)\n\n\treturn (h = h ^ (h >>> 9))\n}\n\nexport const getCookieValidator = ({\n\tvalidator,\n\tdefaultConfig = {},\n\tconfig,\n\tdynamic,\n\tmodels\n}: {\n\tvalidator: TSchema | string | undefined\n\tdefaultConfig: CookieOptions | undefined\n\tconfig: CookieOptions\n\tdynamic: boolean\n\tmodels: Record<string, TSchema> | undefined\n}) => {\n\tlet cookieValidator = getSchemaValidator(validator, {\n\t\tdynamic,\n\t\tmodels,\n\t\tadditionalProperties: true\n\t})\n\n\tif (isNotEmpty(defaultConfig)) {\n\t\tif (cookieValidator) {\n\t\t\t// @ts-expect-error private\n\t\t\tcookieValidator.config = mergeCookie(\n\t\t\t\t// @ts-expect-error private\n\t\t\t\tcookieValidator.config,\n\t\t\t\tconfig\n\t\t\t)\n\t\t} else {\n\t\t\tcookieValidator = getSchemaValidator(t.Cookie({}), {\n\t\t\t\tdynamic,\n\t\t\t\tmodels,\n\t\t\t\tadditionalProperties: true\n\t\t\t})\n\n\t\t\t// @ts-expect-error private\n\t\t\tcookieValidator.config = defaultConfig\n\t\t}\n\t}\n\n\treturn cookieValidator\n}\n\nexport const mergeLifeCycle = (\n\ta: LifeCycleStore,\n\tb: LifeCycleStore | LocalHook<any, any, any, any, any, any, any>,\n\tchecksum?: number\n): LifeCycleStore => {\n\tconst injectChecksum = (x: MaybeArray<HookContainer> | undefined) => {\n\t\tif (!x) return\n\n\t\tif (!Array.isArray(x)) {\n\t\t\t// ? clone fn is required to prevent side-effect from changing hookType\n\t\t\tconst fn = x\n\n\t\t\tif (checksum && !fn.checksum) fn.checksum = checksum\n\t\t\tif (fn.scope === 'scoped') fn.scope = 'local'\n\n\t\t\treturn fn\n\t\t}\n\n\t\t// ? clone fns is required to prevent side-effect from changing hookType\n\t\tconst fns = [...x]\n\n\t\tfor (const fn of fns) {\n\t\t\tif (checksum && !fn.checksum) fn.checksum = checksum\n\n\t\t\tif (fn.scope === 'scoped') fn.scope = 'local'\n\t\t}\n\n\t\treturn fns\n\t}\n\n\treturn {\n\t\t// ...a,\n\t\t// ...b,\n\t\tstart: mergeObjectArray(\n\t\t\ta.start,\n\t\t\tinjectChecksum(b?.start)\n\t\t) as HookContainer<GracefulHandler<any>>[],\n\t\trequest: mergeObjectArray(\n\t\t\ta.request,\n\t\t\tinjectChecksum(b?.request)\n\t\t) as HookContainer<PreHandler<any, any>>[],\n\t\tparse: mergeObjectArray(\n\t\t\ta.parse,\n\t\t\tinjectChecksum(b?.parse)\n\t\t) as HookContainer<BodyHandler<any, any>>[],\n\t\ttransform: mergeObjectArray(\n\t\t\ta.transform,\n\t\t\tinjectChecksum(b?.transform)\n\t\t) as HookContainer<TransformHandler<any, any>>[],\n\t\tbeforeHandle: mergeObjectArray(\n\t\t\ta.beforeHandle,\n\t\t\tinjectChecksum(b?.beforeHandle)\n\t\t) as HookContainer<OptionalHandler<any, any>>[],\n\t\tafterHandle: mergeObjectArray(\n\t\t\ta.afterHandle,\n\t\t\tinjectChecksum(b?.afterHandle)\n\t\t) as HookContainer<AfterHandler<any, any>>[],\n\t\tmapResponse: mergeObjectArray(\n\t\t\ta.mapResponse,\n\t\t\tinjectChecksum(b?.mapResponse)\n\t\t) as HookContainer<MapResponse<any, any>>[],\n\t\tonResponse: mergeObjectArray(\n\t\t\ta.onResponse,\n\t\t\tinjectChecksum(b?.onResponse)\n\t\t) as HookContainer<VoidHandler<any, any>>[],\n\t\t// Already merged on Elysia._use, also logic is more complicated, can't directly merge\n\t\ttrace: a.trace,\n\t\terror: mergeObjectArray(\n\t\t\ta.error,\n\t\t\tinjectChecksum(b?.error)\n\t\t) as HookContainer<ErrorHandler<any, any, any>>[],\n\t\tstop: mergeObjectArray(\n\t\t\ta.stop,\n\t\t\tinjectChecksum(b?.stop)\n\t\t) as HookContainer<GracefulHandler<any>>[]\n\t}\n}\n\nexport const asHookType = (\n\tfn: HookContainer,\n\tinject: LifeCycleType,\n\t{ skipIfHasType = false }: { skipIfHasType?: boolean } = {}\n) => {\n\tif (!fn) return fn\n\n\tif (!Array.isArray(fn)) {\n\t\tif (skipIfHasType) fn.scope ??= inject\n\t\telse fn.scope = inject\n\n\t\treturn fn\n\t}\n\n\tfor (const x of fn)\n\t\tif (skipIfHasType) x.scope ??= inject\n\t\telse x.scope = inject\n\n\treturn fn\n}\n\nconst filterGlobal = (fn: MaybeArray<HookContainer>) => {\n\tif (!fn) return fn\n\n\tif (!Array.isArray(fn))\n\t\tswitch (fn.scope) {\n\t\t\tcase 'global':\n\t\t\tcase 'scoped':\n\t\t\t\treturn { ...fn }\n\n\t\t\tdefault:\n\t\t\t\treturn { fn }\n\t\t}\n\n\tconst array = <any>[]\n\n\tfor (const x of fn)\n\t\tswitch (x.scope) {\n\t\t\tcase 'global':\n\t\t\tcase 'scoped':\n\t\t\t\tarray.push({\n\t\t\t\t\t...x\n\t\t\t\t})\n\t\t\t\tbreak\n\t\t}\n\n\treturn array\n}\n\nexport const filterGlobalHook = (\n\thook: LocalHook<any, any, any, any, any, any, any>\n): LocalHook<any, any, any, any, any, any, any> => {\n\treturn {\n\t\t// rest is validator\n\t\t...hook,\n\t\ttype: hook?.type,\n\t\tdetail: hook?.detail,\n\t\tparse: filterGlobal(hook?.parse),\n\t\ttransform: filterGlobal(hook?.transform),\n\t\tbeforeHandle: filterGlobal(hook?.beforeHandle),\n\t\tafterHandle: filterGlobal(hook?.afterHandle),\n\t\tonResponse: filterGlobal(hook?.onResponse),\n\t\terror: filterGlobal(hook?.error),\n\t\tmapResponse: filterGlobal(hook?.mapResponse)\n\t} as LocalHook<any, any, any, any, any, any, any>\n}\n\nexport const StatusMap = {\n\tContinue: 100,\n\t'Switching Protocols': 101,\n\tProcessing: 102,\n\t'Early Hints': 103,\n\tOK: 200,\n\tCreated: 201,\n\tAccepted: 202,\n\t'Non-Authoritative Information': 203,\n\t'No Content': 204,\n\t'Reset Content': 205,\n\t'Partial Content': 206,\n\t'Multi-Status': 207,\n\t'Already Reported': 208,\n\t'Multiple Choices': 300,\n\t'Moved Permanently': 301,\n\tFound: 302,\n\t'See Other': 303,\n\t'Not Modified': 304,\n\t'Temporary Redirect': 307,\n\t'Permanent Redirect': 308,\n\t'Bad Request': 400,\n\tUnauthorized: 401,\n\t'Payment Required': 402,\n\tForbidden: 403,\n\t'Not Found': 404,\n\t'Method Not Allowed': 405,\n\t'Not Acceptable': 406,\n\t'Proxy Authentication Required': 407,\n\t'Request Timeout': 408,\n\tConflict: 409,\n\tGone: 410,\n\t'Length Required': 411,\n\t'Precondition Failed': 412,\n\t'Payload Too Large': 413,\n\t'URI Too Long': 414,\n\t'Unsupported Media Type': 415,\n\t'Range Not Satisfiable': 416,\n\t'Expectation Failed': 417,\n\t\"I'm a teapot\": 418,\n\t'Misdirected Request': 421,\n\t'Unprocessable Content': 422,\n\tLocked: 423,\n\t'Failed Dependency': 424,\n\t'Too Early': 425,\n\t'Upgrade Required': 426,\n\t'Precondition Required': 428,\n\t'Too Many Requests': 429,\n\t'Request Header Fields Too Large': 431,\n\t'Unavailable For Legal Reasons': 451,\n\t'Internal Server Error': 500,\n\t'Not Implemented': 501,\n\t'Bad Gateway': 502,\n\t'Service Unavailable': 503,\n\t'Gateway Timeout': 504,\n\t'HTTP Version Not Supported': 505,\n\t'Variant Also Negotiates': 506,\n\t'Insufficient Storage': 507,\n\t'Loop Detected': 508,\n\t'Not Extended': 510,\n\t'Network Authentication Required': 511\n} as const\n\nexport const InvertedStatusMap = Object.fromEntries(\n\tObject.entries(StatusMap).map(([k, v]) => [v, k])\n) as {\n\t[K in keyof StatusMap as StatusMap[K]]: K\n}\n\nexport type StatusMap = typeof StatusMap\nexport type InvertedStatusMap = typeof InvertedStatusMap\n\nfunction removeTrailingEquals(digest: string): string {\n\tlet trimmedDigest = digest\n\twhile (trimmedDigest.endsWith('=')) {\n\t\ttrimmedDigest = trimmedDigest.slice(0, -1)\n\t}\n\treturn trimmedDigest\n}\n\nconst encoder = new TextEncoder()\n\nexport const signCookie = async (val: string, secret: string | null) => {\n\tif (typeof val !== 'string')\n\t\tthrow new TypeError('Cookie value must be provided as a string.')\n\n\tif (secret === null) throw new TypeError('Secret key must be provided.')\n\n\tconst secretKey = await crypto.subtle.importKey(\n\t\t'raw',\n\t\tencoder.encode(secret),\n\t\t{ name: 'HMAC', hash: 'SHA-256' },\n\t\tfalse,\n\t\t['sign']\n\t)\n\tconst hmacBuffer = await crypto.subtle.sign(\n\t\t'HMAC',\n\t\tsecretKey,\n\t\tencoder.encode(val)\n\t)\n\n\treturn (\n\t\tval +\n\t\t'.' +\n\t\tremoveTrailingEquals(Buffer.from(hmacBuffer).toString('base64'))\n\t)\n}\n\nexport const unsignCookie = async (input: string, secret: string | null) => {\n\tif (typeof input !== 'string')\n\t\tthrow new TypeError('Signed cookie string must be provided.')\n\n\tif (null === secret) throw new TypeError('Secret key must be provided.')\n\n\tconst tentativeValue = input.slice(0, input.lastIndexOf('.'))\n\tconst expectedInput = await signCookie(tentativeValue, secret)\n\n\treturn expectedInput === input ? tentativeValue : false\n}\n\nexport const traceBackMacro = (\n\textension: unknown,\n\tproperty: Record<string, unknown>,\n\thooks = property\n) => {\n\tif (!extension || typeof extension !== 'object' || !property) return\n\n\tfor (const [key, value] of Object.entries(property)) {\n\t\tif (key in primitiveHookMap || !(key in extension)) continue\n\n\t\tconst v = extension[\n\t\t\tkey as unknown as keyof typeof extension\n\t\t] as BaseMacro[string]\n\n\t\tif (typeof v === 'function') {\n\t\t\tv(value)\n\t\t} else if (typeof v === 'object')\n\t\t\ttraceBackMacro(v as BaseMacro, value as any, hooks)\n\t}\n}\n\nexport const createMacroManager =\n\t({\n\t\tglobalHook,\n\t\tlocalHook\n\t}: {\n\t\tglobalHook: LifeCycleStore\n\t\tlocalHook: LocalHook<any, any, any, any, any, any, any>\n\t}) =>\n\t(stackName: keyof LifeCycleStore) =>\n\t(\n\t\ttype:\n\t\t\t| {\n\t\t\t\t\tinsert?: 'before' | 'after'\n\t\t\t\t\tstack?: 'global' | 'local'\n\t\t\t  }\n\t\t\t| MaybeArray<HookContainer>,\n\t\tfn?: MaybeArray<HookContainer>\n\t) => {\n\t\tif (typeof type === 'function')\n\t\t\ttype = {\n\t\t\t\tfn: type\n\t\t\t}\n\n\t\tif ('fn' in type || Array.isArray(type)) {\n\t\t\tif (!localHook[stackName]) localHook[stackName] = []\n\t\t\tif (typeof localHook[stackName] === 'function')\n\t\t\t\tlocalHook[stackName] = [localHook[stackName]]\n\n\t\t\tif (Array.isArray(type))\n\t\t\t\tlocalHook[stackName] = (\n\t\t\t\t\tlocalHook[stackName] as unknown[]\n\t\t\t\t).concat(type) as any\n\t\t\telse localHook[stackName].push(type)\n\n\t\t\treturn\n\t\t}\n\n\t\tconst { insert = 'after', stack = 'local' } = type\n\n\t\tif (typeof fn === 'function') fn = { fn }\n\n\t\tif (stack === 'global') {\n\t\t\tif (!Array.isArray(fn)) {\n\t\t\t\tif (insert === 'before') {\n\t\t\t\t\t;(globalHook[stackName] as any[]).unshift(fn)\n\t\t\t\t} else {\n\t\t\t\t\t;(globalHook[stackName] as any[]).push(fn)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (insert === 'before') {\n\t\t\t\t\tglobalHook[stackName] = fn.concat(\n\t\t\t\t\t\tglobalHook[stackName] as any\n\t\t\t\t\t) as any\n\t\t\t\t} else {\n\t\t\t\t\tglobalHook[stackName] = (\n\t\t\t\t\t\tglobalHook[stackName] as any[]\n\t\t\t\t\t).concat(fn)\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (!localHook[stackName]) localHook[stackName] = []\n\t\t\tif (typeof localHook[stackName] === 'function')\n\t\t\t\tlocalHook[stackName] = [localHook[stackName]]\n\n\t\t\tif (!Array.isArray(fn)) {\n\t\t\t\tif (insert === 'before') {\n\t\t\t\t\t;(localHook[stackName] as any[]).unshift(fn)\n\t\t\t\t} else {\n\t\t\t\t\t;(localHook[stackName] as any[]).push(fn)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (insert === 'before') {\n\t\t\t\t\tlocalHook[stackName] = fn.concat(localHook[stackName])\n\t\t\t\t} else {\n\t\t\t\t\tlocalHook[stackName] = localHook[stackName].concat(fn)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nexport const isNumericString = (message: string): boolean => {\n\tif (message.length < 16)\n\t\treturn message.trim().length !== 0 && !Number.isNaN(Number(message))\n\n\t// if 16 digit but less then 9,007,199,254,740,991 then can be parsed\n\tif (message.length === 16) {\n\t\tconst numVal = Number(message)\n\t\tif (numVal.toString() === message)\n\t\t\treturn message.trim().length !== 0 && !Number.isNaN(numVal)\n\t}\n\n\treturn false\n}\n\nexport class PromiseGroup implements PromiseLike<void> {\n\troot: Promise<any> | null = null\n\tpromises: Promise<any>[] = []\n\n\tconstructor(public onError: (error: any) => void = console.error) {}\n\n\t/**\n\t * The number of promises still being awaited.\n\t */\n\tget size() {\n\t\treturn this.promises.length\n\t}\n\n\t/**\n\t * Add a promise to the group.\n\t * @returns The promise that was added.\n\t */\n\tadd<T>(promise: Promise<T>) {\n\t\tthis.promises.push(promise)\n\t\tthis.root ||= this.drain()\n\t\treturn promise\n\t}\n\n\tprivate async drain() {\n\t\twhile (this.promises.length > 0) {\n\t\t\ttry {\n\t\t\t\tawait this.promises[0]\n\t\t\t} catch (error) {\n\t\t\t\tthis.onError(error)\n\t\t\t}\n\t\t\tthis.promises.shift()\n\t\t}\n\t\tthis.root = null\n\t}\n\n\t// Allow the group to be awaited.\n\tthen<TResult1 = void, TResult2 = never>(\n\t\tonfulfilled?:\n\t\t\t| ((value: void) => TResult1 | PromiseLike<TResult1>)\n\t\t\t| undefined\n\t\t\t| null,\n\t\tonrejected?:\n\t\t\t| ((reason: any) => TResult2 | PromiseLike<TResult2>)\n\t\t\t| undefined\n\t\t\t| null\n\t): PromiseLike<TResult1 | TResult2> {\n\t\treturn (this.root ?? Promise.resolve()).then(onfulfilled, onrejected)\n\t}\n}\n\nexport const fnToContainer = (\n\tfn: MaybeArray<Function | HookContainer>\n): MaybeArray<HookContainer> => {\n\tif (!fn) return fn\n\n\tif (!Array.isArray(fn)) {\n\t\tif (typeof fn === 'function') return { fn }\n\t\telse if ('fn' in fn) return fn\n\t}\n\n\tconst fns = <HookContainer[]>[]\n\tfor (const x of fn) {\n\t\tif (typeof x === 'function') fns.push({ fn: x })\n\t\telse if ('fn' in x) fns.push(x)\n\t}\n\n\treturn fns\n}\n\nexport const localHookToLifeCycleStore = (\n\ta: LocalHook<any, any, any, any, any>\n): LifeCycleStore => {\n\treturn {\n\t\t...a,\n\t\tstart: fnToContainer(a?.start),\n\t\trequest: fnToContainer(a?.request),\n\t\tparse: fnToContainer(a?.parse),\n\t\ttransform: fnToContainer(a?.transform),\n\t\tbeforeHandle: fnToContainer(a?.beforeHandle),\n\t\tafterHandle: fnToContainer(a?.afterHandle),\n\t\tonResponse: fnToContainer(a?.onResponse),\n\t\tmapResponse: fnToContainer(a?.mapResponse),\n\t\ttrace: fnToContainer(a?.trace),\n\t\terror: fnToContainer(a?.error),\n\t\tstop: fnToContainer(a?.stop)\n\t}\n}\n\nexport const lifeCycleToFn = (\n\ta: LifeCycleStore\n): LocalHook<any, any, any, any, any, any, any> => {\n\treturn {\n\t\t...a,\n\t\tstart: a.start?.map((x) => x.fn),\n\t\trequest: a.request?.map((x) => x.fn),\n\t\tparse: a.parse?.map((x) => x.fn),\n\t\ttransform: a.transform?.map((x) => x.fn),\n\t\tbeforeHandle: a.beforeHandle?.map((x) => x.fn),\n\t\tafterHandle: a.afterHandle?.map((x) => x.fn),\n\t\tonResponse: a.onResponse?.map((x) => x.fn),\n\t\tmapResponse: a.mapResponse?.map((x) => x.fn),\n\t\ttrace: a.trace?.map((x) => x.fn),\n\t\terror: a.error?.map((x) => x.fn),\n\t\tstop: a.stop?.map((x) => x.fn)\n\t}\n}\n\nexport const cloneInference = (inference: {\n\tevent: Sucrose.Inference\n\ttrace: Sucrose.TraceInference\n}): {\n\tevent: Sucrose.Inference\n\ttrace: Sucrose.TraceInference\n} => ({\n\tevent: {\n\t\tbody: inference.event.body,\n\t\tcookie: inference.event.cookie,\n\t\theaders: inference.event.headers,\n\t\tqueries: [...inference.event.queries],\n\t\tquery: inference.event.query,\n\t\tset: inference.event.set,\n\t\tunknownQueries: inference.event.unknownQueries\n\t},\n\ttrace: {\n\t\trequest: inference.trace.request,\n\t\tparse: inference.trace.parse,\n\t\ttransform: inference.trace.transform,\n\t\thandle: inference.trace.handle,\n\t\tbeforeHandle: inference.trace.beforeHandle,\n\t\tafterHandle: inference.trace.afterHandle,\n\t\terror: inference.trace.error,\n\t\tcontext: inference.trace.context,\n\t\tstore: inference.trace.store,\n\t\tset: inference.trace.set\n\t}\n})\n\n/**\n *\n * @param url URL to redirect to\n * @param HTTP status code to send,\n */\nexport const redirect = (\n\turl: string,\n\tstatus: number = 301\n) =>\n\tnew Response(null, {\n\t\tstatus,\n\t\theaders: {\n\t\t\tLocation: url\n\t\t}\n\t})\n\nexport type redirect = typeof redirect\n",
  "/*!\n * cookie\n * Copyright(c) 2012-2014 Roman Shtylman\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module exports.\n * @public\n */\n\nexports.parse = parse;\nexports.serialize = serialize;\n\n/**\n * Module variables.\n * @private\n */\n\nvar __toString = Object.prototype.toString\n\n/**\n * RegExp to match field-content in RFC 7230 sec 3.2\n *\n * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n * field-vchar   = VCHAR / obs-text\n * obs-text      = %x80-FF\n */\n\nvar fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\n\n/**\n * Parse a cookie header.\n *\n * Parse the given cookie header string into an object\n * The object has the various cookies as keys(names) => values\n *\n * @param {string} str\n * @param {object} [options]\n * @return {object}\n * @public\n */\n\nfunction parse(str, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('argument str must be a string');\n  }\n\n  var obj = {}\n  var opt = options || {};\n  var dec = opt.decode || decode;\n\n  var index = 0\n  while (index < str.length) {\n    var eqIdx = str.indexOf('=', index)\n\n    // no more cookie pairs\n    if (eqIdx === -1) {\n      break\n    }\n\n    var endIdx = str.indexOf(';', index)\n\n    if (endIdx === -1) {\n      endIdx = str.length\n    } else if (endIdx < eqIdx) {\n      // backtrack on prior semicolon\n      index = str.lastIndexOf(';', eqIdx - 1) + 1\n      continue\n    }\n\n    var key = str.slice(index, eqIdx).trim()\n\n    // only assign once\n    if (undefined === obj[key]) {\n      var val = str.slice(eqIdx + 1, endIdx).trim()\n\n      // quoted values\n      if (val.charCodeAt(0) === 0x22) {\n        val = val.slice(1, -1)\n      }\n\n      obj[key] = tryDecode(val, dec);\n    }\n\n    index = endIdx + 1\n  }\n\n  return obj;\n}\n\n/**\n * Serialize data into a cookie header.\n *\n * Serialize the a name value pair into a cookie string suitable for\n * http headers. An optional options object specified cookie parameters.\n *\n * serialize('foo', 'bar', { httpOnly: true })\n *   => \"foo=bar; httpOnly\"\n *\n * @param {string} name\n * @param {string} val\n * @param {object} [options]\n * @return {string}\n * @public\n */\n\nfunction serialize(name, val, options) {\n  var opt = options || {};\n  var enc = opt.encode || encode;\n\n  if (typeof enc !== 'function') {\n    throw new TypeError('option encode is invalid');\n  }\n\n  if (!fieldContentRegExp.test(name)) {\n    throw new TypeError('argument name is invalid');\n  }\n\n  var value = enc(val);\n\n  if (value && !fieldContentRegExp.test(value)) {\n    throw new TypeError('argument val is invalid');\n  }\n\n  var str = name + '=' + value;\n\n  if (null != opt.maxAge) {\n    var maxAge = opt.maxAge - 0;\n\n    if (isNaN(maxAge) || !isFinite(maxAge)) {\n      throw new TypeError('option maxAge is invalid')\n    }\n\n    str += '; Max-Age=' + Math.floor(maxAge);\n  }\n\n  if (opt.domain) {\n    if (!fieldContentRegExp.test(opt.domain)) {\n      throw new TypeError('option domain is invalid');\n    }\n\n    str += '; Domain=' + opt.domain;\n  }\n\n  if (opt.path) {\n    if (!fieldContentRegExp.test(opt.path)) {\n      throw new TypeError('option path is invalid');\n    }\n\n    str += '; Path=' + opt.path;\n  }\n\n  if (opt.expires) {\n    var expires = opt.expires\n\n    if (!isDate(expires) || isNaN(expires.valueOf())) {\n      throw new TypeError('option expires is invalid');\n    }\n\n    str += '; Expires=' + expires.toUTCString()\n  }\n\n  if (opt.httpOnly) {\n    str += '; HttpOnly';\n  }\n\n  if (opt.secure) {\n    str += '; Secure';\n  }\n\n  if (opt.partitioned) {\n    str += '; Partitioned'\n  }\n\n  if (opt.priority) {\n    var priority = typeof opt.priority === 'string'\n      ? opt.priority.toLowerCase()\n      : opt.priority\n\n    switch (priority) {\n      case 'low':\n        str += '; Priority=Low'\n        break\n      case 'medium':\n        str += '; Priority=Medium'\n        break\n      case 'high':\n        str += '; Priority=High'\n        break\n      default:\n        throw new TypeError('option priority is invalid')\n    }\n  }\n\n  if (opt.sameSite) {\n    var sameSite = typeof opt.sameSite === 'string'\n      ? opt.sameSite.toLowerCase() : opt.sameSite;\n\n    switch (sameSite) {\n      case true:\n        str += '; SameSite=Strict';\n        break;\n      case 'lax':\n        str += '; SameSite=Lax';\n        break;\n      case 'strict':\n        str += '; SameSite=Strict';\n        break;\n      case 'none':\n        str += '; SameSite=None';\n        break;\n      default:\n        throw new TypeError('option sameSite is invalid');\n    }\n  }\n\n  return str;\n}\n\n/**\n * URL-decode string value. Optimized to skip native call when no %.\n *\n * @param {string} str\n * @returns {string}\n */\n\nfunction decode (str) {\n  return str.indexOf('%') !== -1\n    ? decodeURIComponent(str)\n    : str\n}\n\n/**\n * URL-encode value.\n *\n * @param {string} val\n * @returns {string}\n */\n\nfunction encode (val) {\n  return encodeURIComponent(val)\n}\n\n/**\n * Determine if value is a Date.\n *\n * @param {*} val\n * @private\n */\n\nfunction isDate (val) {\n  return __toString.call(val) === '[object Date]' ||\n    val instanceof Date\n}\n\n/**\n * Try decoding a string using a decoding function.\n *\n * @param {string} str\n * @param {function} decode\n * @private\n */\n\nfunction tryDecode(str, decode) {\n  try {\n    return decode(str);\n  } catch (e) {\n    return str;\n  }\n}\n",
  "import { parse } from 'cookie'\n\n// @ts-ignore\nimport decodeURIComponent from 'fast-decode-uri-component'\n\nimport { unsignCookie, isNumericString } from './utils'\nimport { InvalidCookieSignature } from './error'\n\nimport type { Context } from './context'\nimport type { Prettify } from './types'\n\nexport interface CookieOptions {\n\t/**\n\t * Specifies the value for the {@link https://tools.ietf.org/html/rfc6265#section-5.2.3|Domain Set-Cookie attribute}. By default, no\n\t * domain is set, and most clients will consider the cookie to apply to only\n\t * the current domain.\n\t */\n\tdomain?: string | undefined\n\n\t/**\n\t * Specifies the `Date` object to be the value for the {@link https://tools.ietf.org/html/rfc6265#section-5.2.1|`Expires` `Set-Cookie` attribute}. By default,\n\t * no expiration is set, and most clients will consider this a \"non-persistent cookie\" and will delete\n\t * it on a condition like exiting a web browser application.\n\t *\n\t * *Note* the {@link https://tools.ietf.org/html/rfc6265#section-5.3|cookie storage model specification}\n\t * states that if both `expires` and `maxAge` are set, then `maxAge` takes precedence, but it is\n\t * possible not all clients by obey this, so if both are set, they should\n\t * point to the same date and time.\n\t */\n\texpires?: Date | undefined\n\t/**\n\t * Specifies the boolean value for the {@link https://tools.ietf.org/html/rfc6265#section-5.2.6|`HttpOnly` `Set-Cookie` attribute}.\n\t * When truthy, the `HttpOnly` attribute is set, otherwise it is not. By\n\t * default, the `HttpOnly` attribute is not set.\n\t *\n\t * *Note* be careful when setting this to true, as compliant clients will\n\t * not allow client-side JavaScript to see the cookie in `document.cookie`.\n\t */\n\thttpOnly?: boolean | undefined\n\t/**\n\t * Specifies the number (in seconds) to be the value for the `Max-Age`\n\t * `Set-Cookie` attribute. The given number will be converted to an integer\n\t * by rounding down. By default, no maximum age is set.\n\t *\n\t * *Note* the {@link https://tools.ietf.org/html/rfc6265#section-5.3|cookie storage model specification}\n\t * states that if both `expires` and `maxAge` are set, then `maxAge` takes precedence, but it is\n\t * possible not all clients by obey this, so if both are set, they should\n\t * point to the same date and time.\n\t */\n\tmaxAge?: number | undefined\n\t/**\n\t * Specifies the value for the {@link https://tools.ietf.org/html/rfc6265#section-5.2.4|`Path` `Set-Cookie` attribute}.\n\t * By default, the path is considered the \"default path\".\n\t */\n\tpath?: string | undefined\n\t/**\n\t * Specifies the `string` to be the value for the [`Priority` `Set-Cookie` attribute][rfc-west-cookie-priority-00-4.1].\n\t *\n\t * - `'low'` will set the `Priority` attribute to `Low`.\n\t * - `'medium'` will set the `Priority` attribute to `Medium`, the default priority when not set.\n\t * - `'high'` will set the `Priority` attribute to `High`.\n\t *\n\t * More information about the different priority levels can be found in\n\t * [the specification][rfc-west-cookie-priority-00-4.1].\n\t *\n\t * **note** This is an attribute that has not yet been fully standardized, and may change in the future.\n\t * This also means many clients may ignore this attribute until they understand it.\n\t */\n\tpriority?: 'low' | 'medium' | 'high' | undefined\n\t/**\n\t * Specifies the boolean or string to be the value for the {@link https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-03#section-4.1.2.7|`SameSite` `Set-Cookie` attribute}.\n\t *\n\t * - `true` will set the `SameSite` attribute to `Strict` for strict same\n\t * site enforcement.\n\t * - `false` will not set the `SameSite` attribute.\n\t * - `'lax'` will set the `SameSite` attribute to Lax for lax same site\n\t * enforcement.\n\t * - `'strict'` will set the `SameSite` attribute to Strict for strict same\n\t * site enforcement.\n\t *  - `'none'` will set the SameSite attribute to None for an explicit\n\t *  cross-site cookie.\n\t *\n\t * More information about the different enforcement levels can be found in {@link https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-03#section-4.1.2.7|the specification}.\n\t *\n\t * *note* This is an attribute that has not yet been fully standardized, and may change in the future. This also means many clients may ignore this attribute until they understand it.\n\t */\n\tsameSite?: true | false | 'lax' | 'strict' | 'none' | undefined\n\t/**\n\t * Specifies the boolean value for the {@link https://tools.ietf.org/html/rfc6265#section-5.2.5|`Secure` `Set-Cookie` attribute}. When truthy, the\n\t * `Secure` attribute is set, otherwise it is not. By default, the `Secure` attribute is not set.\n\t *\n\t * *Note* be careful when setting this to `true`, as compliant clients will\n\t * not send the cookie back to the server in the future if the browser does\n\t * not have an HTTPS connection.\n\t */\n\tsecure?: boolean | undefined\n\n\t/**\n\t * Secret key for signing cookie\n\t *\n\t * If array is passed, will use Key Rotation.\n\t *\n\t * Key rotation is when an encryption key is retired\n\t * and replaced by generating a new cryptographic key.\n\t */\n\tsecrets?: string | string[]\n}\n\nexport type ElysiaCookie = Prettify<\n\tCookieOptions & {\n\t\tvalue?: unknown\n\t}\n>\n\ntype Updater<T> = T | ((value: T) => T)\n\nexport class Cookie<T> implements ElysiaCookie {\n\tconstructor(\n\t\tprivate name: string,\n\t\tprivate jar: Record<string, ElysiaCookie>,\n\t\tprivate initial: Partial<ElysiaCookie> = {}\n\t) {}\n\n\tget cookie() {\n\t\tif (!(this.name in this.jar)) return this.initial\n\n\t\treturn this.jar[this.name]\n\t}\n\n\tset cookie(jar: ElysiaCookie) {\n\t\tif (!(this.name in this.jar)) this.jar[this.name] = this.initial\n\n\t\tthis.jar[this.name] = jar\n\t}\n\n\tget value(): T {\n\t\treturn this.cookie.value as T\n\t}\n\n\tset value(value: T) {\n\t\tif (!(this.name in this.jar)) this.jar[this.name] = this.initial\n\n\t\tthis.jar[this.name].value = value\n\t}\n\n\tget expires() {\n\t\treturn this.cookie.expires\n\t}\n\n\tset expires(expires) {\n\t\tthis.cookie.expires = expires\n\t}\n\n\tget maxAge() {\n\t\treturn this.cookie.maxAge\n\t}\n\n\tset maxAge(maxAge) {\n\t\tthis.cookie.maxAge = maxAge\n\t}\n\n\tget domain() {\n\t\treturn this.cookie.domain\n\t}\n\n\tset domain(domain) {\n\t\tthis.cookie.domain = domain\n\t}\n\n\tget path() {\n\t\treturn this.cookie.path\n\t}\n\n\tset path(path) {\n\t\tthis.cookie.path = path\n\t}\n\n\tget secure() {\n\t\treturn this.cookie.secure\n\t}\n\n\tset secure(secure) {\n\t\tthis.cookie.secure = secure\n\t}\n\n\tget httpOnly() {\n\t\treturn this.cookie.httpOnly\n\t}\n\n\tset httpOnly(httpOnly) {\n\t\tthis.cookie.httpOnly = httpOnly\n\t}\n\n\tget sameSite() {\n\t\treturn this.cookie.sameSite\n\t}\n\n\tset sameSite(sameSite) {\n\t\tthis.cookie.sameSite = sameSite\n\t}\n\n\tget priority() {\n\t\treturn this.cookie.priority\n\t}\n\n\tset priority(priority) {\n\t\tthis.cookie.priority = priority\n\t}\n\n\tget secrets() {\n\t\treturn this.cookie.secrets\n\t}\n\n\tset secrets(secrets) {\n\t\tthis.cookie.secrets = secrets\n\t}\n\n\tupdate(config: Updater<Partial<ElysiaCookie>>) {\n\t\tthis.cookie = Object.assign(\n\t\t\tthis.cookie,\n\t\t\ttypeof config === 'function' ? config(this.cookie) : config\n\t\t)\n\n\t\treturn this\n\t}\n\n\tset(config: Updater<Partial<ElysiaCookie>>) {\n\t\tthis.cookie = Object.assign(\n\t\t\t{\n\t\t\t\t...this.initial,\n\t\t\t\tvalue: this.value,\n\t\t\t},\n\t\t\ttypeof config === 'function' ? config(this.cookie) : config\n\t\t)\n\n\t\treturn this\n\t}\n\n\tremove() {\n\t\tif (this.value === undefined) return\n\n\t\tthis.set({\n\t\t\texpires: new Date(0),\n\t\t\tmaxAge: 0,\n\t\t\tvalue: ''\n\t\t})\n\n\t\treturn this\n\t}\n\n\ttoString() {\n\t\treturn typeof this.value === 'object'\n\t\t\t? JSON.stringify(this.value)\n\t\t\t: this.value?.toString() ?? ''\n\t}\n}\n\nexport const createCookieJar = (\n\tset: Context['set'],\n\tstore: Record<string, ElysiaCookie>,\n\tinitial?: Partial<ElysiaCookie>\n): Record<string, Cookie<unknown>> => {\n\tif (!set.cookie) set.cookie = {}\n\n\treturn new Proxy(store, {\n\t\tget(_, key: string) {\n\t\t\tif (key in store)\n\t\t\t\treturn new Cookie(\n\t\t\t\t\tkey,\n\t\t\t\t\tset.cookie as Record<string, ElysiaCookie>,\n\t\t\t\t\tObject.assign({}, initial ?? {}, store[key])\n\t\t\t\t)\n\n\t\t\treturn new Cookie(\n\t\t\t\tkey,\n\t\t\t\tset.cookie as Record<string, ElysiaCookie>,\n\t\t\t\tObject.assign({}, initial)\n\t\t\t)\n\t\t}\n\t}) as Record<string, Cookie<unknown>>\n}\n\nexport const parseCookie = async (\n\tset: Context['set'],\n\tcookieString?: string | null,\n\t{\n\t\tsecrets,\n\t\tsign,\n\t\t...initial\n\t}: CookieOptions & {\n\t\tsign?: true | string | string[]\n\t} = {}\n) => {\n\tif (!cookieString) return createCookieJar(set, {}, initial)\n\n\tconst isStringKey = typeof secrets === 'string'\n\tif (sign && sign !== true && !Array.isArray(sign)) sign = [sign]\n\n\tconst jar: Record<string, ElysiaCookie> = {}\n\n\tconst cookies = parse(cookieString)\n\tfor (const [name, v] of Object.entries(cookies)) {\n\t\tlet value = decodeURIComponent(v)\n\n\t\tif (sign === true || sign?.includes(name)) {\n\t\t\tif (!secrets)\n\t\t\t\tthrow new Error('No secret is provided to cookie plugin')\n\n\t\t\tif (isStringKey) {\n\t\t\t\tconst temp = await unsignCookie(value as string, secrets)\n\t\t\t\tif (temp === false) throw new InvalidCookieSignature(name)\n\n\t\t\t\tvalue = temp\n\t\t\t} else {\n\t\t\t\tlet decoded = true\n\t\t\t\tfor (let i = 0; i < secrets.length; i++) {\n\t\t\t\t\tconst temp = await unsignCookie(value as string, secrets[i])\n\n\t\t\t\t\tif (temp !== false) {\n\t\t\t\t\t\tdecoded = true\n\t\t\t\t\t\tvalue = temp\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!decoded) throw new InvalidCookieSignature(name)\n\t\t\t}\n\t\t}\n\n\t\tconst start = value.charCodeAt(0)\n\t\tif (start === 123 || start === 91)\n\t\t\ttry {\n\t\t\t\tjar[name] = {\n\t\t\t\t\tvalue: JSON.parse(value)\n\t\t\t\t}\n\n\t\t\t\tcontinue\n\t\t\t} catch {\n\t\t\t\t// ignore\n\t\t\t}\n\n\t\tif (isNumericString(value)) {\n\t\t\tjar[name] = {\n\t\t\t\tvalue: parseInt(value)\n\t\t\t}\n\n\t\t\tcontinue\n\t\t}\n\n\t\tif (value === 'true') {\n\t\t\tjar[name] = {\n\t\t\t\tvalue: true\n\t\t\t}\n\n\t\t\tcontinue\n\t\t}\n\n\t\tif (value === 'false') {\n\t\t\tjar[name] = {\n\t\t\t\tvalue: false\n\t\t\t}\n\n\t\t\tcontinue\n\t\t}\n\n\t\tjar[name] = {\n\t\t\tvalue\n\t\t}\n\t}\n\n\treturn createCookieJar(set, jar, initial)\n}\n",
  "import { parse } from 'cookie'\n\n// @ts-ignore\nimport decodeURIComponent from 'fast-decode-uri-component'\n\nimport { unsignCookie, isNumericString } from './utils'\nimport { InvalidCookieSignature } from './error'\n\nimport type { Context } from './context'\nimport type { Prettify } from './types'\n\nexport interface CookieOptions {\n\t/**\n\t * Specifies the value for the {@link https://tools.ietf.org/html/rfc6265#section-5.2.3|Domain Set-Cookie attribute}. By default, no\n\t * domain is set, and most clients will consider the cookie to apply to only\n\t * the current domain.\n\t */\n\tdomain?: string | undefined\n\n\t/**\n\t * Specifies the `Date` object to be the value for the {@link https://tools.ietf.org/html/rfc6265#section-5.2.1|`Expires` `Set-Cookie` attribute}. By default,\n\t * no expiration is set, and most clients will consider this a \"non-persistent cookie\" and will delete\n\t * it on a condition like exiting a web browser application.\n\t *\n\t * *Note* the {@link https://tools.ietf.org/html/rfc6265#section-5.3|cookie storage model specification}\n\t * states that if both `expires` and `maxAge` are set, then `maxAge` takes precedence, but it is\n\t * possible not all clients by obey this, so if both are set, they should\n\t * point to the same date and time.\n\t */\n\texpires?: Date | undefined\n\t/**\n\t * Specifies the boolean value for the {@link https://tools.ietf.org/html/rfc6265#section-5.2.6|`HttpOnly` `Set-Cookie` attribute}.\n\t * When truthy, the `HttpOnly` attribute is set, otherwise it is not. By\n\t * default, the `HttpOnly` attribute is not set.\n\t *\n\t * *Note* be careful when setting this to true, as compliant clients will\n\t * not allow client-side JavaScript to see the cookie in `document.cookie`.\n\t */\n\thttpOnly?: boolean | undefined\n\t/**\n\t * Specifies the number (in seconds) to be the value for the `Max-Age`\n\t * `Set-Cookie` attribute. The given number will be converted to an integer\n\t * by rounding down. By default, no maximum age is set.\n\t *\n\t * *Note* the {@link https://tools.ietf.org/html/rfc6265#section-5.3|cookie storage model specification}\n\t * states that if both `expires` and `maxAge` are set, then `maxAge` takes precedence, but it is\n\t * possible not all clients by obey this, so if both are set, they should\n\t * point to the same date and time.\n\t */\n\tmaxAge?: number | undefined\n\t/**\n\t * Specifies the value for the {@link https://tools.ietf.org/html/rfc6265#section-5.2.4|`Path` `Set-Cookie` attribute}.\n\t * By default, the path is considered the \"default path\".\n\t */\n\tpath?: string | undefined\n\t/**\n\t * Specifies the `string` to be the value for the [`Priority` `Set-Cookie` attribute][rfc-west-cookie-priority-00-4.1].\n\t *\n\t * - `'low'` will set the `Priority` attribute to `Low`.\n\t * - `'medium'` will set the `Priority` attribute to `Medium`, the default priority when not set.\n\t * - `'high'` will set the `Priority` attribute to `High`.\n\t *\n\t * More information about the different priority levels can be found in\n\t * [the specification][rfc-west-cookie-priority-00-4.1].\n\t *\n\t * **note** This is an attribute that has not yet been fully standardized, and may change in the future.\n\t * This also means many clients may ignore this attribute until they understand it.\n\t */\n\tpriority?: 'low' | 'medium' | 'high' | undefined\n\t/**\n\t * Specifies the boolean or string to be the value for the {@link https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-03#section-4.1.2.7|`SameSite` `Set-Cookie` attribute}.\n\t *\n\t * - `true` will set the `SameSite` attribute to `Strict` for strict same\n\t * site enforcement.\n\t * - `false` will not set the `SameSite` attribute.\n\t * - `'lax'` will set the `SameSite` attribute to Lax for lax same site\n\t * enforcement.\n\t * - `'strict'` will set the `SameSite` attribute to Strict for strict same\n\t * site enforcement.\n\t *  - `'none'` will set the SameSite attribute to None for an explicit\n\t *  cross-site cookie.\n\t *\n\t * More information about the different enforcement levels can be found in {@link https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-03#section-4.1.2.7|the specification}.\n\t *\n\t * *note* This is an attribute that has not yet been fully standardized, and may change in the future. This also means many clients may ignore this attribute until they understand it.\n\t */\n\tsameSite?: true | false | 'lax' | 'strict' | 'none' | undefined\n\t/**\n\t * Specifies the boolean value for the {@link https://tools.ietf.org/html/rfc6265#section-5.2.5|`Secure` `Set-Cookie` attribute}. When truthy, the\n\t * `Secure` attribute is set, otherwise it is not. By default, the `Secure` attribute is not set.\n\t *\n\t * *Note* be careful when setting this to `true`, as compliant clients will\n\t * not send the cookie back to the server in the future if the browser does\n\t * not have an HTTPS connection.\n\t */\n\tsecure?: boolean | undefined\n\n\t/**\n\t * Secret key for signing cookie\n\t *\n\t * If array is passed, will use Key Rotation.\n\t *\n\t * Key rotation is when an encryption key is retired\n\t * and replaced by generating a new cryptographic key.\n\t */\n\tsecrets?: string | string[]\n}\n\nexport type ElysiaCookie = Prettify<\n\tCookieOptions & {\n\t\tvalue?: unknown\n\t}\n>\n\ntype Updater<T> = T | ((value: T) => T)\n\nexport class Cookie<T> implements ElysiaCookie {\n\tconstructor(\n\t\tprivate name: string,\n\t\tprivate jar: Record<string, ElysiaCookie>,\n\t\tprivate initial: Partial<ElysiaCookie> = {}\n\t) {}\n\n\tget cookie() {\n\t\tif (!(this.name in this.jar)) return this.initial\n\n\t\treturn this.jar[this.name]\n\t}\n\n\tset cookie(jar: ElysiaCookie) {\n\t\tif (!(this.name in this.jar)) this.jar[this.name] = this.initial\n\n\t\tthis.jar[this.name] = jar\n\t}\n\n\tget value(): T {\n\t\treturn this.cookie.value as T\n\t}\n\n\tset value(value: T) {\n\t\tif (!(this.name in this.jar)) this.jar[this.name] = this.initial\n\n\t\tthis.jar[this.name].value = value\n\t}\n\n\tget expires() {\n\t\treturn this.cookie.expires\n\t}\n\n\tset expires(expires) {\n\t\tthis.cookie.expires = expires\n\t}\n\n\tget maxAge() {\n\t\treturn this.cookie.maxAge\n\t}\n\n\tset maxAge(maxAge) {\n\t\tthis.cookie.maxAge = maxAge\n\t}\n\n\tget domain() {\n\t\treturn this.cookie.domain\n\t}\n\n\tset domain(domain) {\n\t\tthis.cookie.domain = domain\n\t}\n\n\tget path() {\n\t\treturn this.cookie.path\n\t}\n\n\tset path(path) {\n\t\tthis.cookie.path = path\n\t}\n\n\tget secure() {\n\t\treturn this.cookie.secure\n\t}\n\n\tset secure(secure) {\n\t\tthis.cookie.secure = secure\n\t}\n\n\tget httpOnly() {\n\t\treturn this.cookie.httpOnly\n\t}\n\n\tset httpOnly(httpOnly) {\n\t\tthis.cookie.httpOnly = httpOnly\n\t}\n\n\tget sameSite() {\n\t\treturn this.cookie.sameSite\n\t}\n\n\tset sameSite(sameSite) {\n\t\tthis.cookie.sameSite = sameSite\n\t}\n\n\tget priority() {\n\t\treturn this.cookie.priority\n\t}\n\n\tset priority(priority) {\n\t\tthis.cookie.priority = priority\n\t}\n\n\tget secrets() {\n\t\treturn this.cookie.secrets\n\t}\n\n\tset secrets(secrets) {\n\t\tthis.cookie.secrets = secrets\n\t}\n\n\tupdate(config: Updater<Partial<ElysiaCookie>>) {\n\t\tthis.cookie = Object.assign(\n\t\t\tthis.cookie,\n\t\t\ttypeof config === 'function' ? config(this.cookie) : config\n\t\t)\n\n\t\treturn this\n\t}\n\n\tset(config: Updater<Partial<ElysiaCookie>>) {\n\t\tthis.cookie = Object.assign(\n\t\t\t{\n\t\t\t\t...this.initial,\n\t\t\t\tvalue: this.value,\n\t\t\t},\n\t\t\ttypeof config === 'function' ? config(this.cookie) : config\n\t\t)\n\n\t\treturn this\n\t}\n\n\tremove() {\n\t\tif (this.value === undefined) return\n\n\t\tthis.set({\n\t\t\texpires: new Date(0),\n\t\t\tmaxAge: 0,\n\t\t\tvalue: ''\n\t\t})\n\n\t\treturn this\n\t}\n\n\ttoString() {\n\t\treturn typeof this.value === 'object'\n\t\t\t? JSON.stringify(this.value)\n\t\t\t: this.value?.toString() ?? ''\n\t}\n}\n\nexport const createCookieJar = (\n\tset: Context['set'],\n\tstore: Record<string, ElysiaCookie>,\n\tinitial?: Partial<ElysiaCookie>\n): Record<string, Cookie<unknown>> => {\n\tif (!set.cookie) set.cookie = {}\n\n\treturn new Proxy(store, {\n\t\tget(_, key: string) {\n\t\t\tif (key in store)\n\t\t\t\treturn new Cookie(\n\t\t\t\t\tkey,\n\t\t\t\t\tset.cookie as Record<string, ElysiaCookie>,\n\t\t\t\t\tObject.assign({}, initial ?? {}, store[key])\n\t\t\t\t)\n\n\t\t\treturn new Cookie(\n\t\t\t\tkey,\n\t\t\t\tset.cookie as Record<string, ElysiaCookie>,\n\t\t\t\tObject.assign({}, initial)\n\t\t\t)\n\t\t}\n\t}) as Record<string, Cookie<unknown>>\n}\n\nexport const parseCookie = async (\n\tset: Context['set'],\n\tcookieString?: string | null,\n\t{\n\t\tsecrets,\n\t\tsign,\n\t\t...initial\n\t}: CookieOptions & {\n\t\tsign?: true | string | string[]\n\t} = {}\n) => {\n\tif (!cookieString) return createCookieJar(set, {}, initial)\n\n\tconst isStringKey = typeof secrets === 'string'\n\tif (sign && sign !== true && !Array.isArray(sign)) sign = [sign]\n\n\tconst jar: Record<string, ElysiaCookie> = {}\n\n\tconst cookies = parse(cookieString)\n\tfor (const [name, v] of Object.entries(cookies)) {\n\t\tlet value = decodeURIComponent(v)\n\n\t\tif (sign === true || sign?.includes(name)) {\n\t\t\tif (!secrets)\n\t\t\t\tthrow new Error('No secret is provided to cookie plugin')\n\n\t\t\tif (isStringKey) {\n\t\t\t\tconst temp = await unsignCookie(value as string, secrets)\n\t\t\t\tif (temp === false) throw new InvalidCookieSignature(name)\n\n\t\t\t\tvalue = temp\n\t\t\t} else {\n\t\t\t\tlet decoded = true\n\t\t\t\tfor (let i = 0; i < secrets.length; i++) {\n\t\t\t\t\tconst temp = await unsignCookie(value as string, secrets[i])\n\n\t\t\t\t\tif (temp !== false) {\n\t\t\t\t\t\tdecoded = true\n\t\t\t\t\t\tvalue = temp\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!decoded) throw new InvalidCookieSignature(name)\n\t\t\t}\n\t\t}\n\n\t\tconst start = value.charCodeAt(0)\n\t\tif (start === 123 || start === 91)\n\t\t\ttry {\n\t\t\t\tjar[name] = {\n\t\t\t\t\tvalue: JSON.parse(value)\n\t\t\t\t}\n\n\t\t\t\tcontinue\n\t\t\t} catch {\n\t\t\t\t// ignore\n\t\t\t}\n\n\t\tif (isNumericString(value)) {\n\t\t\tjar[name] = {\n\t\t\t\tvalue: parseInt(value)\n\t\t\t}\n\n\t\t\tcontinue\n\t\t}\n\n\t\tif (value === 'true') {\n\t\t\tjar[name] = {\n\t\t\t\tvalue: true\n\t\t\t}\n\n\t\t\tcontinue\n\t\t}\n\n\t\tif (value === 'false') {\n\t\t\tjar[name] = {\n\t\t\t\tvalue: false\n\t\t\t}\n\n\t\t\tcontinue\n\t\t}\n\n\t\tjar[name] = {\n\t\t\tvalue\n\t\t}\n\t}\n\n\treturn createCookieJar(set, jar, initial)\n}\n",
  "/* eslint-disable sonarjs/no-duplicate-string */\nimport { serialize } from 'cookie'\nimport { StatusMap } from './utils'\n\nimport { Cookie } from './cookies'\nimport { ELYSIA_RESPONSE } from './error'\n\nimport type { Context } from './context'\n\nconst hasHeaderShorthand = 'toJSON' in new Headers()\n\ntype SetResponse = Omit<Context['set'], 'status'> & {\n\tstatus: number\n}\n\nexport const isNotEmpty = (obj?: Object) => {\n\tif (!obj) return false\n\n\tfor (const x in obj) return true\n\n\treturn false\n}\n/** */\n\nconst handleFile = (response: File | Blob, set?: Context['set']) => {\n\tconst size = response.size\n\n\tif (\n\t\t(!set && size) ||\n\t\t(size &&\n\t\t\tset &&\n\t\t\tset.status !== 206 &&\n\t\t\tset.status !== 304 &&\n\t\t\tset.status !== 412 &&\n\t\t\tset.status !== 416)\n\t) {\n\t\tif (set) {\n\t\t\tif (set.headers instanceof Headers)\n\t\t\t\tif (hasHeaderShorthand)\n\t\t\t\t\tset.headers = (set.headers as unknown as Headers).toJSON()\n\t\t\t\telse\n\t\t\t\t\tfor (const [key, value] of set.headers.entries())\n\t\t\t\t\t\tif (key in set.headers) set.headers[key] = value\n\n\t\t\treturn new Response(response as Blob, {\n\t\t\t\tstatus: set.status as number,\n\t\t\t\theaders: Object.assign(\n\t\t\t\t\t{\n\t\t\t\t\t\t'accept-ranges': 'bytes',\n\t\t\t\t\t\t'content-range': `bytes 0-${size - 1}/${size}`\n\t\t\t\t\t},\n\t\t\t\t\tset.headers\n\t\t\t\t)\n\t\t\t})\n\t\t}\n\n\t\treturn new Response(response as Blob, {\n\t\t\theaders: {\n\t\t\t\t'accept-ranges': 'bytes',\n\t\t\t\t'content-range': `bytes 0-${size - 1}/${size}`\n\t\t\t}\n\t\t})\n\t}\n\n\treturn new Response(response as Blob)\n}\n\nexport const parseSetCookies = (headers: Headers, setCookie: string[]) => {\n\tif (!headers) return headers\n\n\theaders.delete('Set-Cookie')\n\n\tfor (let i = 0; i < setCookie.length; i++) {\n\t\tconst index = setCookie[i].indexOf('=')\n\n\t\theaders.append(\n\t\t\t'Set-Cookie',\n\t\t\t`${setCookie[i].slice(0, index)}=${\n\t\t\t\tsetCookie[i].slice(index + 1) || ''\n\t\t\t}`\n\t\t)\n\t}\n\n\treturn headers\n}\n\nexport const serializeCookie = (cookies: Context['set']['cookie']) => {\n\tif (!cookies || !isNotEmpty(cookies)) return undefined\n\n\tconst set: string[] = []\n\n\tfor (const [key, property] of Object.entries(cookies)) {\n\t\tif (!key || !property) continue\n\n\t\tconst value = property.value\n\t\tif (value === undefined || value === null) continue\n\n\t\tset.push(\n\t\t\tserialize(\n\t\t\t\tkey,\n\t\t\t\ttypeof value === 'object' ? JSON.stringify(value) : value + '',\n\t\t\t\tproperty\n\t\t\t)\n\t\t)\n\t}\n\n\tif (set.length === 0) return undefined\n\tif (set.length === 1) return set[0]\n\n\treturn set\n}\n\nexport const mapResponse = (\n\tresponse: unknown,\n\tset: Context['set'],\n\trequest?: Request\n): Response => {\n\t// @ts-ignore\n\tif (response?.$passthrough)\n\t\t// @ts-ignore\n\t\tresponse = response?.[response.$passthrough]\n\n\t// @ts-ignore\n\tif (response?.[ELYSIA_RESPONSE]) {\n\t\t// @ts-ignore\n\t\tset.status = response[ELYSIA_RESPONSE]\n\t\t// @ts-ignore\n\t\tresponse = response.response\n\t}\n\n\tif (\n\t\tisNotEmpty(set.headers) ||\n\t\tset.status !== 200 ||\n\t\tset.redirect ||\n\t\tset.cookie\n\t) {\n\t\tif (typeof set.status === 'string') set.status = StatusMap[set.status]\n\n\t\tif (set.redirect) {\n\t\t\tset.headers.Location = set.redirect\n\t\t\tif (!set.status || set.status < 300 || set.status >= 400)\n\t\t\t\tset.status = 302\n\t\t}\n\n\t\tif (set.cookie && isNotEmpty(set.cookie))\n\t\t\tset.headers['Set-Cookie'] = serializeCookie(set.cookie)\n\n\t\tif (\n\t\t\tset.headers['Set-Cookie'] &&\n\t\t\tArray.isArray(set.headers['Set-Cookie'])\n\t\t)\n\t\t\tset.headers = parseSetCookies(\n\t\t\t\tnew Headers(set.headers) as Headers,\n\t\t\t\tset.headers['Set-Cookie']\n\t\t\t) as any\n\n\t\tswitch (response?.constructor?.name) {\n\t\t\tcase 'String':\n\t\t\t\treturn new Response(response as string, set as SetResponse)\n\n\t\t\tcase 'Blob':\n\t\t\t\treturn handleFile(response as File | Blob, set)\n\n\t\t\tcase 'Object':\n\t\t\tcase 'Array':\n\t\t\t\treturn Response.json(response, set as SetResponse)\n\n\t\t\tcase 'ReadableStream':\n\t\t\t\tif (\n\t\t\t\t\t!set.headers['content-type']?.startsWith(\n\t\t\t\t\t\t'text/event-stream'\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t\tset.headers['content-type'] =\n\t\t\t\t\t\t'text/event-stream; charset=utf-8'\n\n\t\t\t\trequest?.signal.addEventListener(\n\t\t\t\t\t'abort',\n\t\t\t\t\t{\n\t\t\t\t\t\thandleEvent() {\n\t\t\t\t\t\t\tif (!request?.signal.aborted)\n\t\t\t\t\t\t\t\t(response as ReadableStream).cancel(request)\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tonce: true\n\t\t\t\t\t}\n\t\t\t\t)\n\n\t\t\t\treturn new Response(\n\t\t\t\t\tresponse as ReadableStream,\n\t\t\t\t\tset as SetResponse\n\t\t\t\t)\n\n\t\t\tcase undefined:\n\t\t\t\tif (!response) return new Response('', set as SetResponse)\n\n\t\t\t\treturn Response.json(response, set as SetResponse)\n\n\t\t\tcase 'Response':\n\t\t\t\tconst inherits = { ...set.headers }\n\n\t\t\t\tif (hasHeaderShorthand)\n\t\t\t\t\tset.headers = (\n\t\t\t\t\t\t(response as Response).headers as Headers\n\t\t\t\t\t).toJSON()\n\t\t\t\telse\n\t\t\t\t\tfor (const [key, value] of (\n\t\t\t\t\t\tresponse as Response\n\t\t\t\t\t).headers.entries())\n\t\t\t\t\t\tif (key in set.headers) set.headers[key] = value\n\n\t\t\t\tfor (const key in inherits)\n\t\t\t\t\t(response as Response).headers.append(key, inherits[key])\n\n\t\t\t\treturn response as Response\n\n\t\t\tcase 'Error':\n\t\t\t\treturn errorToResponse(response as Error, set)\n\n\t\t\tcase 'Promise':\n\t\t\t\treturn (response as Promise<any>).then((x) =>\n\t\t\t\t\tmapResponse(x, set)\n\t\t\t\t) as any\n\n\t\t\tcase 'Function':\n\t\t\t\treturn mapResponse((response as Function)(), set)\n\n\t\t\tcase 'Number':\n\t\t\tcase 'Boolean':\n\t\t\t\treturn new Response(\n\t\t\t\t\t(response as number | boolean).toString(),\n\t\t\t\t\tset as SetResponse\n\t\t\t\t)\n\n\t\t\tcase 'Cookie':\n\t\t\t\tif (response instanceof Cookie)\n\t\t\t\t\treturn new Response(response.value, set as SetResponse)\n\n\t\t\t\treturn new Response(response?.toString(), set as SetResponse)\n\n\t\t\tdefault:\n\t\t\t\tif (response instanceof Response) {\n\t\t\t\t\tconst inherits = Object.assign({}, set.headers)\n\n\t\t\t\t\tif (hasHeaderShorthand)\n\t\t\t\t\t\tset.headers = (\n\t\t\t\t\t\t\t(response as Response).headers as Headers\n\t\t\t\t\t\t).toJSON()\n\t\t\t\t\telse\n\t\t\t\t\t\tfor (const [key, value] of (\n\t\t\t\t\t\t\tresponse as Response\n\t\t\t\t\t\t).headers.entries())\n\t\t\t\t\t\t\tif (key in set.headers) set.headers[key] = value\n\n\t\t\t\t\tfor (const key in inherits)\n\t\t\t\t\t\t(response as Response).headers.append(\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tinherits[key]\n\t\t\t\t\t\t)\n\n\t\t\t\t\treturn response as Response\n\t\t\t\t}\n\n\t\t\t\tif (response instanceof Promise)\n\t\t\t\t\treturn response.then((x) => mapResponse(x, set)) as any\n\n\t\t\t\tif (response instanceof Error)\n\t\t\t\t\treturn errorToResponse(response as Error, set)\n\n\t\t\t\tif ('charCodeAt' in (response as any)) {\n\t\t\t\t\tconst code = (response as any).charCodeAt(0)\n\n\t\t\t\t\tif (code === 123 || code === 91) {\n\t\t\t\t\t\tif (!set.headers['Content-Type'])\n\t\t\t\t\t\t\tset.headers['Content-Type'] = 'application/json'\n\n\t\t\t\t\t\treturn new Response(\n\t\t\t\t\t\t\tJSON.stringify(response),\n\t\t\t\t\t\t\tset as SetResponse\n\t\t\t\t\t\t) as any\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn new Response(response as any, set as SetResponse)\n\t\t}\n\t} else\n\t\tswitch (response?.constructor?.name) {\n\t\t\tcase 'String':\n\t\t\t\treturn new Response(response as string)\n\n\t\t\tcase 'Blob':\n\t\t\t\treturn handleFile(response as File | Blob, set)\n\n\t\t\tcase 'Object':\n\t\t\tcase 'Array':\n\t\t\t\treturn new Response(JSON.stringify(response), {\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'content-type': 'application/json'\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\tcase 'ReadableStream':\n\t\t\t\trequest?.signal.addEventListener(\n\t\t\t\t\t'abort',\n\t\t\t\t\t{\n\t\t\t\t\t\thandleEvent() {\n\t\t\t\t\t\t\tif (!request?.signal.aborted)\n\t\t\t\t\t\t\t\t(response as ReadableStream).cancel(request)\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tonce: true\n\t\t\t\t\t}\n\t\t\t\t)\n\n\t\t\t\treturn new Response(response as ReadableStream, {\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'Content-Type': 'text/event-stream; charset=utf-8'\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\tcase undefined:\n\t\t\t\tif (!response) return new Response('')\n\n\t\t\t\treturn new Response(JSON.stringify(response), {\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'content-type': 'application/json'\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\tcase 'Response':\n\t\t\t\treturn response as Response\n\n\t\t\tcase 'Error':\n\t\t\t\treturn errorToResponse(response as Error, set)\n\n\t\t\tcase 'Promise':\n\t\t\t\t// @ts-ignore\n\t\t\t\treturn (response as any as Promise<unknown>).then((x) => {\n\t\t\t\t\tconst r = mapCompactResponse(x)\n\n\t\t\t\t\tif (r !== undefined) return r\n\n\t\t\t\t\treturn new Response('')\n\t\t\t\t})\n\n\t\t\t// ? Maybe response or Blob\n\t\t\tcase 'Function':\n\t\t\t\treturn mapCompactResponse((response as Function)())\n\n\t\t\tcase 'Number':\n\t\t\tcase 'Boolean':\n\t\t\t\treturn new Response((response as number | boolean).toString())\n\n\t\t\tcase 'Cookie':\n\t\t\t\tif (response instanceof Cookie)\n\t\t\t\t\treturn new Response(response.value, set as SetResponse)\n\n\t\t\t\treturn new Response(response?.toString(), set as SetResponse)\n\n\t\t\tdefault:\n\t\t\t\tif (response instanceof Response)\n\t\t\t\t\treturn new Response(response.body, {\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t'Content-Type': 'application/json'\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\n\t\t\t\tif (response instanceof Promise)\n\t\t\t\t\treturn response.then((x) => mapResponse(x, set)) as any\n\n\t\t\t\tif (response instanceof Error)\n\t\t\t\t\treturn errorToResponse(response as Error, set)\n\n\t\t\t\tif ('charCodeAt' in (response as any)) {\n\t\t\t\t\tconst code = (response as any).charCodeAt(0)\n\n\t\t\t\t\tif (code === 123 || code === 91) {\n\t\t\t\t\t\tif (!set.headers['Content-Type'])\n\t\t\t\t\t\t\tset.headers['Content-Type'] = 'application/json'\n\n\t\t\t\t\t\treturn new Response(\n\t\t\t\t\t\t\tJSON.stringify(response),\n\t\t\t\t\t\t\tset as SetResponse\n\t\t\t\t\t\t) as any\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn new Response(response as any)\n\t\t}\n}\n\nexport const mapEarlyResponse = (\n\tresponse: unknown,\n\tset: Context['set'],\n\trequest?: Request\n): Response | undefined => {\n\tif (response === undefined || response === null) return\n\n\t// @ts-ignore\n\tif (response?.$passthrough)\n\t\t// @ts-ignore\n\t\tresponse = response?.[response.$passthrough]\n\n\t// @ts-ignore\n\tif (response?.[ELYSIA_RESPONSE]) {\n\t\t// @ts-ignore\n\t\tset.status = response[ELYSIA_RESPONSE]\n\t\t// @ts-ignore\n\t\tresponse = response.response\n\t}\n\n\tif (\n\t\tisNotEmpty(set.headers) ||\n\t\tset.status !== 200 ||\n\t\tset.redirect ||\n\t\tset.cookie\n\t) {\n\t\tif (typeof set.status === 'string') set.status = StatusMap[set.status]\n\n\t\tif (set.redirect) {\n\t\t\tset.headers.Location = set.redirect\n\n\t\t\tif (!set.status || set.status < 300 || set.status >= 400)\n\t\t\t\tset.status = 302\n\t\t}\n\n\t\tif (set.cookie && isNotEmpty(set.cookie))\n\t\t\tset.headers['Set-Cookie'] = serializeCookie(set.cookie)\n\n\t\tif (\n\t\t\tset.headers['Set-Cookie'] &&\n\t\t\tArray.isArray(set.headers['Set-Cookie'])\n\t\t)\n\t\t\tset.headers = parseSetCookies(\n\t\t\t\tnew Headers(set.headers) as Headers,\n\t\t\t\tset.headers['Set-Cookie']\n\t\t\t) as any\n\n\t\tswitch (response?.constructor?.name) {\n\t\t\tcase 'String':\n\t\t\t\treturn new Response(response as string, set as SetResponse)\n\n\t\t\tcase 'Blob':\n\t\t\t\treturn handleFile(response as File | Blob, set)\n\n\t\t\tcase 'Object':\n\t\t\tcase 'Array':\n\t\t\t\treturn Response.json(response, set as SetResponse)\n\n\t\t\tcase 'ReadableStream':\n\t\t\t\tif (\n\t\t\t\t\t!set.headers['content-type']?.startsWith(\n\t\t\t\t\t\t'text/event-stream'\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t\tset.headers['content-type'] =\n\t\t\t\t\t\t'text/event-stream; charset=utf-8'\n\n\t\t\t\trequest?.signal.addEventListener(\n\t\t\t\t\t'abort',\n\t\t\t\t\t{\n\t\t\t\t\t\thandleEvent() {\n\t\t\t\t\t\t\tif (!request?.signal.aborted)\n\t\t\t\t\t\t\t\t(response as ReadableStream).cancel(request)\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tonce: true\n\t\t\t\t\t}\n\t\t\t\t)\n\n\t\t\t\treturn new Response(\n\t\t\t\t\tresponse as ReadableStream,\n\t\t\t\t\tset as SetResponse\n\t\t\t\t)\n\n\t\t\tcase undefined:\n\t\t\t\tif (!response) return\n\n\t\t\t\treturn Response.json(response, set as SetResponse)\n\n\t\t\tcase 'Response':\n\t\t\t\tconst inherits = Object.assign({}, set.headers)\n\n\t\t\t\tif (hasHeaderShorthand)\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tset.headers = (response as Response).headers.toJSON()\n\t\t\t\telse\n\t\t\t\t\tfor (const [key, value] of (\n\t\t\t\t\t\tresponse as Response\n\t\t\t\t\t).headers.entries())\n\t\t\t\t\t\tif (!(key in set.headers)) set.headers[key] = value\n\n\t\t\t\tfor (const key in inherits)\n\t\t\t\t\t(response as Response).headers.append(key, inherits[key])\n\n\t\t\t\tif ((response as Response).status !== set.status)\n\t\t\t\t\tset.status = (response as Response).status\n\n\t\t\t\treturn response as Response\n\n\t\t\tcase 'Promise':\n\t\t\t\t// @ts-ignore\n\t\t\t\treturn (response as Promise<unknown>).then((x) => {\n\t\t\t\t\tconst r = mapEarlyResponse(x, set)\n\t\t\t\t\tif (r !== undefined) return r\n\t\t\t\t})\n\n\t\t\tcase 'Error':\n\t\t\t\treturn errorToResponse(response as Error, set)\n\n\t\t\tcase 'Function':\n\t\t\t\treturn mapEarlyResponse((response as Function)(), set)\n\n\t\t\tcase 'Number':\n\t\t\tcase 'Boolean':\n\t\t\t\treturn new Response(\n\t\t\t\t\t(response as number | boolean).toString(),\n\t\t\t\t\tset as SetResponse\n\t\t\t\t)\n\n\t\t\tcase 'Cookie':\n\t\t\t\tif (response instanceof Cookie)\n\t\t\t\t\treturn new Response(response.value, set as SetResponse)\n\n\t\t\t\treturn new Response(response?.toString(), set as SetResponse)\n\n\t\t\tdefault:\n\t\t\t\tif (response instanceof Response) {\n\t\t\t\t\tconst inherits = { ...set.headers }\n\n\t\t\t\t\tif (hasHeaderShorthand)\n\t\t\t\t\t\tset.headers = (\n\t\t\t\t\t\t\t(response as Response).headers as Headers\n\t\t\t\t\t\t).toJSON()\n\t\t\t\t\telse\n\t\t\t\t\t\tfor (const [key, value] of (\n\t\t\t\t\t\t\tresponse as Response\n\t\t\t\t\t\t).headers.entries())\n\t\t\t\t\t\t\tif (key in set.headers) set.headers[key] = value\n\n\t\t\t\t\tfor (const key in inherits)\n\t\t\t\t\t\t(response as Response).headers.append(\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tinherits[key]\n\t\t\t\t\t\t)\n\n\t\t\t\t\treturn response as Response\n\t\t\t\t}\n\n\t\t\t\tif (response instanceof Promise)\n\t\t\t\t\treturn response.then((x) => mapEarlyResponse(x, set)) as any\n\n\t\t\t\tif (response instanceof Error)\n\t\t\t\t\treturn errorToResponse(response as Error, set)\n\n\t\t\t\tif ('charCodeAt' in (response as any)) {\n\t\t\t\t\tconst code = (response as any).charCodeAt(0)\n\n\t\t\t\t\tif (code === 123 || code === 91) {\n\t\t\t\t\t\tif (!set.headers['Content-Type'])\n\t\t\t\t\t\t\tset.headers['Content-Type'] = 'application/json'\n\n\t\t\t\t\t\treturn new Response(\n\t\t\t\t\t\t\tJSON.stringify(response),\n\t\t\t\t\t\t\tset as SetResponse\n\t\t\t\t\t\t) as any\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn new Response(response as any, set as SetResponse)\n\t\t}\n\t} else\n\t\tswitch (response?.constructor?.name) {\n\t\t\tcase 'String':\n\t\t\t\treturn new Response(response as string)\n\n\t\t\tcase 'Blob':\n\t\t\t\treturn handleFile(response as File | Blob, set)\n\n\t\t\tcase 'Object':\n\t\t\tcase 'Array':\n\t\t\t\treturn new Response(JSON.stringify(response), {\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'content-type': 'application/json'\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\tcase 'ReadableStream':\n\t\t\t\trequest?.signal.addEventListener(\n\t\t\t\t\t'abort',\n\t\t\t\t\t{\n\t\t\t\t\t\thandleEvent() {\n\t\t\t\t\t\t\tif (!request?.signal.aborted)\n\t\t\t\t\t\t\t\t(response as ReadableStream).cancel(request)\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tonce: true\n\t\t\t\t\t}\n\t\t\t\t)\n\n\t\t\t\treturn new Response(response as ReadableStream, {\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'Content-Type': 'text/event-stream; charset=utf-8'\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\tcase undefined:\n\t\t\t\tif (!response) return new Response('')\n\n\t\t\t\treturn new Response(JSON.stringify(response), {\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'content-type': 'application/json'\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\tcase 'Response':\n\t\t\t\treturn response as Response\n\n\t\t\tcase 'Promise':\n\t\t\t\t// @ts-ignore\n\t\t\t\treturn (response as Promise<unknown>).then((x) => {\n\t\t\t\t\tconst r = mapEarlyResponse(x, set)\n\t\t\t\t\tif (r !== undefined) return r\n\t\t\t\t})\n\n\t\t\tcase 'Error':\n\t\t\t\treturn errorToResponse(response as Error, set)\n\n\t\t\tcase 'Function':\n\t\t\t\treturn mapCompactResponse((response as Function)())\n\n\t\t\tcase 'Number':\n\t\t\tcase 'Boolean':\n\t\t\t\treturn new Response((response as number | boolean).toString())\n\n\t\t\tcase 'Cookie':\n\t\t\t\tif (response instanceof Cookie)\n\t\t\t\t\treturn new Response(response.value, set as SetResponse)\n\n\t\t\t\treturn new Response(response?.toString(), set as SetResponse)\n\n\t\t\tdefault:\n\t\t\t\tif (response instanceof Response)\n\t\t\t\t\treturn new Response(response.body, {\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t'Content-Type': 'application/json'\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\n\t\t\t\tif (response instanceof Promise)\n\t\t\t\t\treturn response.then((x) => mapEarlyResponse(x, set)) as any\n\n\t\t\t\tif (response instanceof Error)\n\t\t\t\t\treturn errorToResponse(response as Error, set)\n\n\t\t\t\tif ('charCodeAt' in (response as any)) {\n\t\t\t\t\tconst code = (response as any).charCodeAt(0)\n\n\t\t\t\t\tif (code === 123 || code === 91) {\n\t\t\t\t\t\tif (!set.headers['Content-Type'])\n\t\t\t\t\t\t\tset.headers['Content-Type'] = 'application/json'\n\n\t\t\t\t\t\treturn new Response(\n\t\t\t\t\t\t\tJSON.stringify(response),\n\t\t\t\t\t\t\tset as SetResponse\n\t\t\t\t\t\t) as any\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn new Response(response as any)\n\t\t}\n}\n\nexport const mapCompactResponse = (\n\tresponse: unknown,\n\trequest?: Request\n): Response => {\n\t// @ts-ignore\n\tif (response?.$passthrough)\n\t\t// @ts-ignore\n\t\tresponse = response?.[response.$passthrough]\n\n\t// @ts-ignore\n\tif (response?.[ELYSIA_RESPONSE])\n\t\t// @ts-ignore\n\t\treturn mapResponse(response.response, {\n\t\t\t// @ts-ignore\n\t\t\tstatus: response[ELYSIA_RESPONSE],\n\t\t\theaders: {}\n\t\t})\n\n\tswitch (response?.constructor?.name) {\n\t\tcase 'String':\n\t\t\treturn new Response(response as string)\n\n\t\tcase 'Blob':\n\t\t\treturn handleFile(response as File | Blob)\n\n\t\tcase 'Object':\n\t\tcase 'Array':\n\t\t\treturn new Response(JSON.stringify(response), {\n\t\t\t\theaders: {\n\t\t\t\t\t'content-type': 'application/json'\n\t\t\t\t}\n\t\t\t})\n\n\t\tcase 'ReadableStream':\n\t\t\trequest?.signal.addEventListener(\n\t\t\t\t'abort',\n\t\t\t\t{\n\t\t\t\t\thandleEvent() {\n\t\t\t\t\t\tif (!request?.signal.aborted)\n\t\t\t\t\t\t\t(response as ReadableStream).cancel(request)\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tonce: true\n\t\t\t\t}\n\t\t\t)\n\n\t\t\treturn new Response(response as ReadableStream, {\n\t\t\t\theaders: {\n\t\t\t\t\t'Content-Type': 'text/event-stream; charset=utf-8'\n\t\t\t\t}\n\t\t\t})\n\n\t\tcase undefined:\n\t\t\tif (!response) return new Response('')\n\n\t\t\treturn new Response(JSON.stringify(response), {\n\t\t\t\theaders: {\n\t\t\t\t\t'content-type': 'application/json'\n\t\t\t\t}\n\t\t\t})\n\n\t\tcase 'Response':\n\t\t\treturn response as Response\n\n\t\tcase 'Error':\n\t\t\treturn errorToResponse(response as Error)\n\n\t\tcase 'Promise':\n\t\t\t// @ts-ignore\n\t\t\treturn (response as any as Promise<unknown>).then(\n\t\t\t\tmapCompactResponse\n\t\t\t)\n\n\t\t// ? Maybe response or Blob\n\t\tcase 'Function':\n\t\t\treturn mapCompactResponse((response as Function)())\n\n\t\tcase 'Number':\n\t\tcase 'Boolean':\n\t\t\treturn new Response((response as number | boolean).toString())\n\n\t\tdefault:\n\t\t\tif (response instanceof Response)\n\t\t\t\treturn new Response(response.body, {\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'Content-Type': 'application/json'\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\tif (response instanceof Promise)\n\t\t\t\treturn response.then(mapCompactResponse) as any\n\n\t\t\tif (response instanceof Error)\n\t\t\t\treturn errorToResponse(response as Error)\n\n\t\t\tif ('charCodeAt' in (response as any)) {\n\t\t\t\tconst code = (response as any).charCodeAt(0)\n\n\t\t\t\tif (code === 123 || code === 91) {\n\t\t\t\t\treturn new Response(\n\t\t\t\t\t\tJSON.stringify(response),\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t\t'Content-Type': 'application/json'\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t) as any\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn new Response(response as any)\n\t}\n}\n\nexport const errorToResponse = (error: Error, set?: Context['set']) =>\n\tnew Response(\n\t\tJSON.stringify({\n\t\t\tname: error?.name,\n\t\t\tmessage: error?.message,\n\t\t\tcause: error?.cause\n\t\t}),\n\t\t{\n\t\t\tstatus: set?.status !== 200 ? (set?.status as number) ?? 500 : 500,\n\t\t\theaders: set?.headers\n\t\t}\n\t)\n",
  "import { Kind, TSchema } from '@sinclair/typebox'\nimport { Value } from '@sinclair/typebox/value'\nimport { TypeCheck, TypeCompiler } from '@sinclair/typebox/compiler'\n\nimport { t } from '.'\nimport { isNotEmpty } from './handler'\n\nimport type {\n\tLifeCycleStore,\n\tLocalHook,\n\tMaybeArray,\n\tInputSchema,\n\tBaseMacro,\n\tLifeCycleType,\n\tHookContainer,\n\tGracefulHandler,\n\tPreHandler,\n\tBodyHandler,\n\tTransformHandler,\n\tOptionalHandler,\n\tAfterHandler,\n\tMapResponse,\n\tVoidHandler,\n\tErrorHandler\n} from './types'\nimport type { CookieOptions } from './cookies'\nimport { Sucrose } from './sucrose'\n\nexport const replaceUrlPath = (url: string, pathname: string) => {\n\tconst urlObject = new URL(url)\n\turlObject.pathname = pathname\n\treturn urlObject.toString()\n}\n\nconst isClass = (v: Object) =>\n\t(typeof v === 'function' && /^\\s*class\\s+/.test(v.toString())) ||\n\t// Handle import * as Sentry from '@sentry/bun'\n\t// This also handle [object Date], [object Array]\n\t// and FFI value like [object Prisma]\n\tv.toString().startsWith('[object ') ||\n\t// If object prototype is not pure, then probably a class-like object\n\tisNotEmpty(Object.getPrototypeOf(v))\n\nconst isObject = (item: any): item is Object =>\n\titem && typeof item === 'object' && !Array.isArray(item)\n\nexport const mergeDeep = <\n\tA extends Record<string, any>,\n\tB extends Record<string, any>\n>(\n\ttarget: A,\n\tsource: B,\n\t{\n\t\tskipKeys\n\t}: {\n\t\tskipKeys?: string[]\n\t} = {}\n): A & B => {\n\tif (isObject(target) && isObject(source))\n\t\tfor (const [key, value] of Object.entries(source)) {\n\t\t\tif (skipKeys?.includes(key)) continue\n\n\t\t\tif (!isObject(value) || !(key in target) || isClass(value)) {\n\t\t\t\ttarget[key as keyof typeof target] = value\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\ttarget[key as keyof typeof target] = mergeDeep(\n\t\t\t\t(target as any)[key] as any,\n\t\t\t\tvalue\n\t\t\t)\n\t\t}\n\n\treturn target as A & B\n}\nexport const mergeCookie = <const A extends Object, const B extends Object>(\n\ta: A,\n\tb: B\n): A & B => {\n\t// @ts-ignore\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tconst { properties: _, ...target } = a ?? {}\n\n\t// @ts-ignore\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tconst { properties: __, ...source } = b ?? {}\n\n\treturn mergeDeep(target, source) as A & B\n}\n\nexport const mergeObjectArray = <T extends HookContainer>(\n\ta: T | T[] = [],\n\tb: T | T[] = []\n): T[] => {\n\tif (!a) return []\n\tif (!b) return a as any\n\n\t// ! Must copy to remove side-effect\n\tconst array = <T[]>[]\n\tconst checksums = <(number | undefined)[]>[]\n\n\tif (!Array.isArray(a)) a = [a]\n\tif (!Array.isArray(b)) b = [b]\n\n\tfor (const item of a) {\n\t\tarray.push(item)\n\n\t\tif (item.checksum) checksums.push(item.checksum)\n\t}\n\n\tfor (const item of b)\n\t\tif (!checksums.includes(item.checksum)) array.push(item)\n\n\treturn array\n}\n\nexport const primitiveHooks = [\n\t'start',\n\t'request',\n\t'parse',\n\t'transform',\n\t'resolve',\n\t'beforeHandle',\n\t'afterHandle',\n\t'onResponse',\n\t'mapResponse',\n\t'trace',\n\t'error',\n\t'stop',\n\t'body',\n\t'headers',\n\t'params',\n\t'query',\n\t'response',\n\t'type',\n\t'detail'\n] as const\n\nconst primitiveHookMap = primitiveHooks.reduce(\n\t(acc, x) => ((acc[x] = true), acc),\n\t{} as Record<string, boolean>\n)\n\nexport const mergeResponse = (\n\ta: InputSchema['response'],\n\tb: InputSchema['response']\n) => {\n\t// If both are Record<number, ...> then merge them,\n\t// giving preference to b.\n\ttype RecordNumber = Record<number, any>\n\tconst isRecordNumber = (x: typeof a | typeof b): x is RecordNumber =>\n\t\ttypeof x === 'object' && Object.keys(x).every(isNumericString)\n\n\tif (isRecordNumber(a) && isRecordNumber(b))\n\t\treturn { ...(a as RecordNumber), ...(b as RecordNumber) }\n\n\treturn b ?? a\n}\n\nexport const mergeHook = (\n\ta?: LifeCycleStore,\n\tb?: LocalHook<any, any, any, any, any, any, any>,\n\t{ allowMacro = false }: { allowMacro?: boolean } = {}\n): LifeCycleStore => {\n\t// In case if merging union is need\n\t// const customAStore: Record<string, unknown> = {}\n\t// const customBStore: Record<string, unknown> = {}\n\n\t// for (const [key, value] of Object.entries(a)) {\n\t// \tif (primitiveHooks.includes(key as any)) continue\n\n\t// \tcustomAStore[key] = value\n\t// }\n\n\t// for (const [key, value] of Object.entries(b)) {\n\t// \tif (primitiveHooks.includes(key as any)) continue\n\n\t// \tcustomBStore[key] = value\n\t// }\n\n\t// const unioned = Object.keys(customAStore).filter((x) =>\n\t// \tObject.keys(customBStore).includes(x)\n\t// )\n\n\t// // Must provide empty object to prevent reference side-effect\n\t// const customStore = Object.assign({}, customAStore, customBStore)\n\n\t// for (const union of unioned)\n\t// \tcustomStore[union] = mergeObjectArray(\n\t// \t\tcustomAStore[union],\n\t// \t\tcustomBStore[union]\n\t// \t)\n\n\tconst rest = allowMacro\n\t\t? {\n\t\t\t\t...a,\n\t\t\t\t...b\n\t\t\t}\n\t\t: undefined\n\n\treturn {\n\t\t...rest,\n\t\t// Merge local hook first\n\t\t// @ts-ignore\n\t\tbody: b?.body ?? a?.body,\n\t\t// @ts-ignore\n\t\theaders: b?.headers ?? a?.headers,\n\t\t// @ts-ignore\n\t\tparams: b?.params ?? a?.params,\n\t\t// @ts-ignore\n\t\tquery: b?.query ?? a?.query,\n\t\t// ? This order is correct - SaltyAom\n\t\tresponse: mergeResponse(\n\t\t\t// @ts-ignore\n\t\t\ta?.response,\n\t\t\t// @ts-ignore\n\t\t\tb?.response\n\t\t),\n\t\ttype: a?.type || b?.type,\n\t\tdetail: mergeDeep(\n\t\t\t// @ts-ignore\n\t\t\tb?.detail ?? {},\n\t\t\t// @ts-ignore\n\t\t\ta?.detail ?? {}\n\t\t),\n\t\tparse: mergeObjectArray(a?.parse as any, b?.parse),\n\t\ttransform: mergeObjectArray(a?.transform, b?.transform),\n\t\tbeforeHandle: mergeObjectArray(a?.beforeHandle, b?.beforeHandle),\n\t\tafterHandle: mergeObjectArray(a?.afterHandle, b?.afterHandle),\n\t\tonResponse: mergeObjectArray(a?.onResponse, b?.onResponse) as any,\n\t\tmapResponse: mergeObjectArray(a?.mapResponse, b?.mapResponse) as any,\n\t\ttrace: mergeObjectArray(a?.trace, b?.trace) as any,\n\t\terror: mergeObjectArray(a?.error, b?.error)\n\t}\n}\n\nexport const getSchemaValidator = (\n\ts: TSchema | string | undefined,\n\t{\n\t\tmodels = {},\n\t\tdynamic = false,\n\t\tnormalize = false,\n\t\tadditionalProperties = normalize\n\t}: {\n\t\tmodels?: Record<string, TSchema>\n\t\tadditionalProperties?: boolean\n\t\tdynamic?: boolean\n\t\tnormalize?: boolean\n\t}\n) => {\n\tif (!s) return\n\tif (typeof s === 'string' && !(s in models)) return\n\n\tconst schema: TSchema = typeof s === 'string' ? models[s] : s\n\n\t// @ts-ignore\n\tif (schema.type === 'object' && 'additionalProperties' in schema === false)\n\t\tschema.additionalProperties = additionalProperties\n\n\tconst cleaner = (value: unknown) => Value.Clean(schema, value)\n\n\tif (dynamic) {\n\t\tconst validator = {\n\t\t\tschema,\n\t\t\treferences: '',\n\t\t\tcheckFunc: () => {},\n\t\t\tcode: '',\n\t\t\tCheck: (value: unknown) => Value.Check(schema, value),\n\t\t\tErrors: (value: unknown) => Value.Errors(schema, value),\n\t\t\tCode: () => ''\n\t\t} as unknown as TypeCheck<TSchema>\n\n\t\tif (normalize && schema.additionalProperties === true)\n\t\t\t// @ts-ignore\n\t\t\tvalidator.Clean = cleaner\n\n\t\t// @ts-ignore\n\t\tif (schema.config) {\n\t\t\t// @ts-ignore\n\t\t\tvalidator.config = schema.config\n\n\t\t\t// @ts-ignore\n\t\t\tif (validator?.schema?.config)\n\t\t\t\t// @ts-ignore\n\t\t\t\tdelete validator.schema.config\n\t\t}\n\n\t\treturn validator\n\t}\n\n\tconst compiled = TypeCompiler.Compile(schema, Object.values(models))\n\n\t// @ts-expect-error\n\tcompiled.Clean = cleaner\n\n\t// @ts-ignore\n\tif (schema.config) {\n\t\t// @ts-ignore\n\t\tcompiled.config = schema.config\n\n\t\t// @ts-ignore\n\t\tif (compiled?.schema?.config)\n\t\t\t// @ts-ignore\n\t\t\tdelete compiled.schema.config\n\t}\n\n\treturn compiled\n}\n\nexport const getResponseSchemaValidator = (\n\ts: InputSchema['response'] | undefined,\n\t{\n\t\tmodels = {},\n\t\tdynamic = false,\n\t\tnormalize = false,\n\t\tadditionalProperties = normalize\n\t}: {\n\t\tmodels?: Record<string, TSchema>\n\t\tadditionalProperties?: boolean\n\t\tdynamic?: boolean\n\t\tnormalize?: boolean\n\t}\n): Record<number, TypeCheck<any>> | undefined => {\n\tif (!s) return\n\tif (typeof s === 'string' && !(s in models)) return\n\n\tconst maybeSchemaOrRecord = typeof s === 'string' ? models[s] : s\n\n\tconst compile = (schema: TSchema, references?: TSchema[]) => {\n\t\t// eslint-disable-next-line sonarjs/no-identical-functions\n\t\t// Sonar being delulu, schema is not identical\n\t\tconst cleaner = (value: unknown) => Value.Clean(schema, value)\n\n\t\tif (dynamic)\n\t\t\treturn {\n\t\t\t\tschema,\n\t\t\t\treferences: '',\n\t\t\t\tcheckFunc: () => {},\n\t\t\t\tcode: '',\n\t\t\t\tCheck: (value: unknown) => Value.Check(schema, value),\n\t\t\t\tErrors: (value: unknown) => Value.Errors(schema, value),\n\t\t\t\tCode: () => ''\n\t\t\t} as unknown as TypeCheck<TSchema>\n\n\t\tconst compiledValidator = TypeCompiler.Compile(schema, references)\n\n\t\tif (normalize && schema.additionalProperties === true)\n\t\t\t// @ts-ignore\n\t\t\tcompiledValidator.Clean = cleaner\n\n\t\treturn compiledValidator\n\t}\n\n\tif (Kind in maybeSchemaOrRecord) {\n\t\tif ('additionalProperties' in maybeSchemaOrRecord === false)\n\t\t\tmaybeSchemaOrRecord.additionalProperties = additionalProperties\n\n\t\treturn {\n\t\t\t200: compile(maybeSchemaOrRecord, Object.values(models))\n\t\t}\n\t}\n\n\tconst record: Record<number, TypeCheck<any>> = {}\n\n\tObject.keys(maybeSchemaOrRecord).forEach((status): TSchema | undefined => {\n\t\tconst maybeNameOrSchema = maybeSchemaOrRecord[+status]\n\n\t\tif (typeof maybeNameOrSchema === 'string') {\n\t\t\tif (maybeNameOrSchema in models) {\n\t\t\t\tconst schema = models[maybeNameOrSchema]\n\t\t\t\tschema.type === 'object' &&\n\t\t\t\t\t'additionalProperties' in schema === false\n\n\t\t\t\t// Inherits model maybe already compiled\n\t\t\t\trecord[+status] =\n\t\t\t\t\tKind in schema\n\t\t\t\t\t\t? compile(schema, Object.values(models))\n\t\t\t\t\t\t: schema\n\t\t\t}\n\n\t\t\treturn undefined\n\t\t}\n\n\t\tif (\n\t\t\tmaybeNameOrSchema.type === 'object' &&\n\t\t\t'additionalProperties' in maybeNameOrSchema === false\n\t\t)\n\t\t\tmaybeNameOrSchema.additionalProperties = additionalProperties\n\n\t\t// Inherits model maybe already compiled\n\t\trecord[+status] =\n\t\t\tKind in maybeNameOrSchema\n\t\t\t\t? compile(maybeNameOrSchema, Object.values(models))\n\t\t\t\t: maybeNameOrSchema\n\t})\n\n\treturn record\n}\n\nconst isBun = typeof Bun !== 'undefined'\nconst hasHash = isBun && typeof Bun.hash === 'function'\n\n// https://stackoverflow.com/a/52171480\nexport const checksum = (s: string) => {\n\tif (hasHash) return Bun.hash(s) as number\n\n\tlet h = 9\n\n\tfor (let i = 0; i < s.length; ) h = Math.imul(h ^ s.charCodeAt(i++), 9 ** 9)\n\n\treturn (h = h ^ (h >>> 9))\n}\n\nexport const getCookieValidator = ({\n\tvalidator,\n\tdefaultConfig = {},\n\tconfig,\n\tdynamic,\n\tmodels\n}: {\n\tvalidator: TSchema | string | undefined\n\tdefaultConfig: CookieOptions | undefined\n\tconfig: CookieOptions\n\tdynamic: boolean\n\tmodels: Record<string, TSchema> | undefined\n}) => {\n\tlet cookieValidator = getSchemaValidator(validator, {\n\t\tdynamic,\n\t\tmodels,\n\t\tadditionalProperties: true\n\t})\n\n\tif (isNotEmpty(defaultConfig)) {\n\t\tif (cookieValidator) {\n\t\t\t// @ts-expect-error private\n\t\t\tcookieValidator.config = mergeCookie(\n\t\t\t\t// @ts-expect-error private\n\t\t\t\tcookieValidator.config,\n\t\t\t\tconfig\n\t\t\t)\n\t\t} else {\n\t\t\tcookieValidator = getSchemaValidator(t.Cookie({}), {\n\t\t\t\tdynamic,\n\t\t\t\tmodels,\n\t\t\t\tadditionalProperties: true\n\t\t\t})\n\n\t\t\t// @ts-expect-error private\n\t\t\tcookieValidator.config = defaultConfig\n\t\t}\n\t}\n\n\treturn cookieValidator\n}\n\nexport const mergeLifeCycle = (\n\ta: LifeCycleStore,\n\tb: LifeCycleStore | LocalHook<any, any, any, any, any, any, any>,\n\tchecksum?: number\n): LifeCycleStore => {\n\tconst injectChecksum = (x: MaybeArray<HookContainer> | undefined) => {\n\t\tif (!x) return\n\n\t\tif (!Array.isArray(x)) {\n\t\t\t// ? clone fn is required to prevent side-effect from changing hookType\n\t\t\tconst fn = x\n\n\t\t\tif (checksum && !fn.checksum) fn.checksum = checksum\n\t\t\tif (fn.scope === 'scoped') fn.scope = 'local'\n\n\t\t\treturn fn\n\t\t}\n\n\t\t// ? clone fns is required to prevent side-effect from changing hookType\n\t\tconst fns = [...x]\n\n\t\tfor (const fn of fns) {\n\t\t\tif (checksum && !fn.checksum) fn.checksum = checksum\n\n\t\t\tif (fn.scope === 'scoped') fn.scope = 'local'\n\t\t}\n\n\t\treturn fns\n\t}\n\n\treturn {\n\t\t// ...a,\n\t\t// ...b,\n\t\tstart: mergeObjectArray(\n\t\t\ta.start,\n\t\t\tinjectChecksum(b?.start)\n\t\t) as HookContainer<GracefulHandler<any>>[],\n\t\trequest: mergeObjectArray(\n\t\t\ta.request,\n\t\t\tinjectChecksum(b?.request)\n\t\t) as HookContainer<PreHandler<any, any>>[],\n\t\tparse: mergeObjectArray(\n\t\t\ta.parse,\n\t\t\tinjectChecksum(b?.parse)\n\t\t) as HookContainer<BodyHandler<any, any>>[],\n\t\ttransform: mergeObjectArray(\n\t\t\ta.transform,\n\t\t\tinjectChecksum(b?.transform)\n\t\t) as HookContainer<TransformHandler<any, any>>[],\n\t\tbeforeHandle: mergeObjectArray(\n\t\t\ta.beforeHandle,\n\t\t\tinjectChecksum(b?.beforeHandle)\n\t\t) as HookContainer<OptionalHandler<any, any>>[],\n\t\tafterHandle: mergeObjectArray(\n\t\t\ta.afterHandle,\n\t\t\tinjectChecksum(b?.afterHandle)\n\t\t) as HookContainer<AfterHandler<any, any>>[],\n\t\tmapResponse: mergeObjectArray(\n\t\t\ta.mapResponse,\n\t\t\tinjectChecksum(b?.mapResponse)\n\t\t) as HookContainer<MapResponse<any, any>>[],\n\t\tonResponse: mergeObjectArray(\n\t\t\ta.onResponse,\n\t\t\tinjectChecksum(b?.onResponse)\n\t\t) as HookContainer<VoidHandler<any, any>>[],\n\t\t// Already merged on Elysia._use, also logic is more complicated, can't directly merge\n\t\ttrace: a.trace,\n\t\terror: mergeObjectArray(\n\t\t\ta.error,\n\t\t\tinjectChecksum(b?.error)\n\t\t) as HookContainer<ErrorHandler<any, any, any>>[],\n\t\tstop: mergeObjectArray(\n\t\t\ta.stop,\n\t\t\tinjectChecksum(b?.stop)\n\t\t) as HookContainer<GracefulHandler<any>>[]\n\t}\n}\n\nexport const asHookType = (\n\tfn: HookContainer,\n\tinject: LifeCycleType,\n\t{ skipIfHasType = false }: { skipIfHasType?: boolean } = {}\n) => {\n\tif (!fn) return fn\n\n\tif (!Array.isArray(fn)) {\n\t\tif (skipIfHasType) fn.scope ??= inject\n\t\telse fn.scope = inject\n\n\t\treturn fn\n\t}\n\n\tfor (const x of fn)\n\t\tif (skipIfHasType) x.scope ??= inject\n\t\telse x.scope = inject\n\n\treturn fn\n}\n\nconst filterGlobal = (fn: MaybeArray<HookContainer>) => {\n\tif (!fn) return fn\n\n\tif (!Array.isArray(fn))\n\t\tswitch (fn.scope) {\n\t\t\tcase 'global':\n\t\t\tcase 'scoped':\n\t\t\t\treturn { ...fn }\n\n\t\t\tdefault:\n\t\t\t\treturn { fn }\n\t\t}\n\n\tconst array = <any>[]\n\n\tfor (const x of fn)\n\t\tswitch (x.scope) {\n\t\t\tcase 'global':\n\t\t\tcase 'scoped':\n\t\t\t\tarray.push({\n\t\t\t\t\t...x\n\t\t\t\t})\n\t\t\t\tbreak\n\t\t}\n\n\treturn array\n}\n\nexport const filterGlobalHook = (\n\thook: LocalHook<any, any, any, any, any, any, any>\n): LocalHook<any, any, any, any, any, any, any> => {\n\treturn {\n\t\t// rest is validator\n\t\t...hook,\n\t\ttype: hook?.type,\n\t\tdetail: hook?.detail,\n\t\tparse: filterGlobal(hook?.parse),\n\t\ttransform: filterGlobal(hook?.transform),\n\t\tbeforeHandle: filterGlobal(hook?.beforeHandle),\n\t\tafterHandle: filterGlobal(hook?.afterHandle),\n\t\tonResponse: filterGlobal(hook?.onResponse),\n\t\terror: filterGlobal(hook?.error),\n\t\tmapResponse: filterGlobal(hook?.mapResponse)\n\t} as LocalHook<any, any, any, any, any, any, any>\n}\n\nexport const StatusMap = {\n\tContinue: 100,\n\t'Switching Protocols': 101,\n\tProcessing: 102,\n\t'Early Hints': 103,\n\tOK: 200,\n\tCreated: 201,\n\tAccepted: 202,\n\t'Non-Authoritative Information': 203,\n\t'No Content': 204,\n\t'Reset Content': 205,\n\t'Partial Content': 206,\n\t'Multi-Status': 207,\n\t'Already Reported': 208,\n\t'Multiple Choices': 300,\n\t'Moved Permanently': 301,\n\tFound: 302,\n\t'See Other': 303,\n\t'Not Modified': 304,\n\t'Temporary Redirect': 307,\n\t'Permanent Redirect': 308,\n\t'Bad Request': 400,\n\tUnauthorized: 401,\n\t'Payment Required': 402,\n\tForbidden: 403,\n\t'Not Found': 404,\n\t'Method Not Allowed': 405,\n\t'Not Acceptable': 406,\n\t'Proxy Authentication Required': 407,\n\t'Request Timeout': 408,\n\tConflict: 409,\n\tGone: 410,\n\t'Length Required': 411,\n\t'Precondition Failed': 412,\n\t'Payload Too Large': 413,\n\t'URI Too Long': 414,\n\t'Unsupported Media Type': 415,\n\t'Range Not Satisfiable': 416,\n\t'Expectation Failed': 417,\n\t\"I'm a teapot\": 418,\n\t'Misdirected Request': 421,\n\t'Unprocessable Content': 422,\n\tLocked: 423,\n\t'Failed Dependency': 424,\n\t'Too Early': 425,\n\t'Upgrade Required': 426,\n\t'Precondition Required': 428,\n\t'Too Many Requests': 429,\n\t'Request Header Fields Too Large': 431,\n\t'Unavailable For Legal Reasons': 451,\n\t'Internal Server Error': 500,\n\t'Not Implemented': 501,\n\t'Bad Gateway': 502,\n\t'Service Unavailable': 503,\n\t'Gateway Timeout': 504,\n\t'HTTP Version Not Supported': 505,\n\t'Variant Also Negotiates': 506,\n\t'Insufficient Storage': 507,\n\t'Loop Detected': 508,\n\t'Not Extended': 510,\n\t'Network Authentication Required': 511\n} as const\n\nexport const InvertedStatusMap = Object.fromEntries(\n\tObject.entries(StatusMap).map(([k, v]) => [v, k])\n) as {\n\t[K in keyof StatusMap as StatusMap[K]]: K\n}\n\nexport type StatusMap = typeof StatusMap\nexport type InvertedStatusMap = typeof InvertedStatusMap\n\nfunction removeTrailingEquals(digest: string): string {\n\tlet trimmedDigest = digest\n\twhile (trimmedDigest.endsWith('=')) {\n\t\ttrimmedDigest = trimmedDigest.slice(0, -1)\n\t}\n\treturn trimmedDigest\n}\n\nconst encoder = new TextEncoder()\n\nexport const signCookie = async (val: string, secret: string | null) => {\n\tif (typeof val !== 'string')\n\t\tthrow new TypeError('Cookie value must be provided as a string.')\n\n\tif (secret === null) throw new TypeError('Secret key must be provided.')\n\n\tconst secretKey = await crypto.subtle.importKey(\n\t\t'raw',\n\t\tencoder.encode(secret),\n\t\t{ name: 'HMAC', hash: 'SHA-256' },\n\t\tfalse,\n\t\t['sign']\n\t)\n\tconst hmacBuffer = await crypto.subtle.sign(\n\t\t'HMAC',\n\t\tsecretKey,\n\t\tencoder.encode(val)\n\t)\n\n\treturn (\n\t\tval +\n\t\t'.' +\n\t\tremoveTrailingEquals(Buffer.from(hmacBuffer).toString('base64'))\n\t)\n}\n\nexport const unsignCookie = async (input: string, secret: string | null) => {\n\tif (typeof input !== 'string')\n\t\tthrow new TypeError('Signed cookie string must be provided.')\n\n\tif (null === secret) throw new TypeError('Secret key must be provided.')\n\n\tconst tentativeValue = input.slice(0, input.lastIndexOf('.'))\n\tconst expectedInput = await signCookie(tentativeValue, secret)\n\n\treturn expectedInput === input ? tentativeValue : false\n}\n\nexport const traceBackMacro = (\n\textension: unknown,\n\tproperty: Record<string, unknown>,\n\thooks = property\n) => {\n\tif (!extension || typeof extension !== 'object' || !property) return\n\n\tfor (const [key, value] of Object.entries(property)) {\n\t\tif (key in primitiveHookMap || !(key in extension)) continue\n\n\t\tconst v = extension[\n\t\t\tkey as unknown as keyof typeof extension\n\t\t] as BaseMacro[string]\n\n\t\tif (typeof v === 'function') {\n\t\t\tv(value)\n\t\t} else if (typeof v === 'object')\n\t\t\ttraceBackMacro(v as BaseMacro, value as any, hooks)\n\t}\n}\n\nexport const createMacroManager =\n\t({\n\t\tglobalHook,\n\t\tlocalHook\n\t}: {\n\t\tglobalHook: LifeCycleStore\n\t\tlocalHook: LocalHook<any, any, any, any, any, any, any>\n\t}) =>\n\t(stackName: keyof LifeCycleStore) =>\n\t(\n\t\ttype:\n\t\t\t| {\n\t\t\t\t\tinsert?: 'before' | 'after'\n\t\t\t\t\tstack?: 'global' | 'local'\n\t\t\t  }\n\t\t\t| MaybeArray<HookContainer>,\n\t\tfn?: MaybeArray<HookContainer>\n\t) => {\n\t\tif (typeof type === 'function')\n\t\t\ttype = {\n\t\t\t\tfn: type\n\t\t\t}\n\n\t\tif ('fn' in type || Array.isArray(type)) {\n\t\t\tif (!localHook[stackName]) localHook[stackName] = []\n\t\t\tif (typeof localHook[stackName] === 'function')\n\t\t\t\tlocalHook[stackName] = [localHook[stackName]]\n\n\t\t\tif (Array.isArray(type))\n\t\t\t\tlocalHook[stackName] = (\n\t\t\t\t\tlocalHook[stackName] as unknown[]\n\t\t\t\t).concat(type) as any\n\t\t\telse localHook[stackName].push(type)\n\n\t\t\treturn\n\t\t}\n\n\t\tconst { insert = 'after', stack = 'local' } = type\n\n\t\tif (typeof fn === 'function') fn = { fn }\n\n\t\tif (stack === 'global') {\n\t\t\tif (!Array.isArray(fn)) {\n\t\t\t\tif (insert === 'before') {\n\t\t\t\t\t;(globalHook[stackName] as any[]).unshift(fn)\n\t\t\t\t} else {\n\t\t\t\t\t;(globalHook[stackName] as any[]).push(fn)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (insert === 'before') {\n\t\t\t\t\tglobalHook[stackName] = fn.concat(\n\t\t\t\t\t\tglobalHook[stackName] as any\n\t\t\t\t\t) as any\n\t\t\t\t} else {\n\t\t\t\t\tglobalHook[stackName] = (\n\t\t\t\t\t\tglobalHook[stackName] as any[]\n\t\t\t\t\t).concat(fn)\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (!localHook[stackName]) localHook[stackName] = []\n\t\t\tif (typeof localHook[stackName] === 'function')\n\t\t\t\tlocalHook[stackName] = [localHook[stackName]]\n\n\t\t\tif (!Array.isArray(fn)) {\n\t\t\t\tif (insert === 'before') {\n\t\t\t\t\t;(localHook[stackName] as any[]).unshift(fn)\n\t\t\t\t} else {\n\t\t\t\t\t;(localHook[stackName] as any[]).push(fn)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (insert === 'before') {\n\t\t\t\t\tlocalHook[stackName] = fn.concat(localHook[stackName])\n\t\t\t\t} else {\n\t\t\t\t\tlocalHook[stackName] = localHook[stackName].concat(fn)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nexport const isNumericString = (message: string): boolean => {\n\tif (message.length < 16)\n\t\treturn message.trim().length !== 0 && !Number.isNaN(Number(message))\n\n\t// if 16 digit but less then 9,007,199,254,740,991 then can be parsed\n\tif (message.length === 16) {\n\t\tconst numVal = Number(message)\n\t\tif (numVal.toString() === message)\n\t\t\treturn message.trim().length !== 0 && !Number.isNaN(numVal)\n\t}\n\n\treturn false\n}\n\nexport class PromiseGroup implements PromiseLike<void> {\n\troot: Promise<any> | null = null\n\tpromises: Promise<any>[] = []\n\n\tconstructor(public onError: (error: any) => void = console.error) {}\n\n\t/**\n\t * The number of promises still being awaited.\n\t */\n\tget size() {\n\t\treturn this.promises.length\n\t}\n\n\t/**\n\t * Add a promise to the group.\n\t * @returns The promise that was added.\n\t */\n\tadd<T>(promise: Promise<T>) {\n\t\tthis.promises.push(promise)\n\t\tthis.root ||= this.drain()\n\t\treturn promise\n\t}\n\n\tprivate async drain() {\n\t\twhile (this.promises.length > 0) {\n\t\t\ttry {\n\t\t\t\tawait this.promises[0]\n\t\t\t} catch (error) {\n\t\t\t\tthis.onError(error)\n\t\t\t}\n\t\t\tthis.promises.shift()\n\t\t}\n\t\tthis.root = null\n\t}\n\n\t// Allow the group to be awaited.\n\tthen<TResult1 = void, TResult2 = never>(\n\t\tonfulfilled?:\n\t\t\t| ((value: void) => TResult1 | PromiseLike<TResult1>)\n\t\t\t| undefined\n\t\t\t| null,\n\t\tonrejected?:\n\t\t\t| ((reason: any) => TResult2 | PromiseLike<TResult2>)\n\t\t\t| undefined\n\t\t\t| null\n\t): PromiseLike<TResult1 | TResult2> {\n\t\treturn (this.root ?? Promise.resolve()).then(onfulfilled, onrejected)\n\t}\n}\n\nexport const fnToContainer = (\n\tfn: MaybeArray<Function | HookContainer>\n): MaybeArray<HookContainer> => {\n\tif (!fn) return fn\n\n\tif (!Array.isArray(fn)) {\n\t\tif (typeof fn === 'function') return { fn }\n\t\telse if ('fn' in fn) return fn\n\t}\n\n\tconst fns = <HookContainer[]>[]\n\tfor (const x of fn) {\n\t\tif (typeof x === 'function') fns.push({ fn: x })\n\t\telse if ('fn' in x) fns.push(x)\n\t}\n\n\treturn fns\n}\n\nexport const localHookToLifeCycleStore = (\n\ta: LocalHook<any, any, any, any, any>\n): LifeCycleStore => {\n\treturn {\n\t\t...a,\n\t\tstart: fnToContainer(a?.start),\n\t\trequest: fnToContainer(a?.request),\n\t\tparse: fnToContainer(a?.parse),\n\t\ttransform: fnToContainer(a?.transform),\n\t\tbeforeHandle: fnToContainer(a?.beforeHandle),\n\t\tafterHandle: fnToContainer(a?.afterHandle),\n\t\tonResponse: fnToContainer(a?.onResponse),\n\t\tmapResponse: fnToContainer(a?.mapResponse),\n\t\ttrace: fnToContainer(a?.trace),\n\t\terror: fnToContainer(a?.error),\n\t\tstop: fnToContainer(a?.stop)\n\t}\n}\n\nexport const lifeCycleToFn = (\n\ta: LifeCycleStore\n): LocalHook<any, any, any, any, any, any, any> => {\n\treturn {\n\t\t...a,\n\t\tstart: a.start?.map((x) => x.fn),\n\t\trequest: a.request?.map((x) => x.fn),\n\t\tparse: a.parse?.map((x) => x.fn),\n\t\ttransform: a.transform?.map((x) => x.fn),\n\t\tbeforeHandle: a.beforeHandle?.map((x) => x.fn),\n\t\tafterHandle: a.afterHandle?.map((x) => x.fn),\n\t\tonResponse: a.onResponse?.map((x) => x.fn),\n\t\tmapResponse: a.mapResponse?.map((x) => x.fn),\n\t\ttrace: a.trace?.map((x) => x.fn),\n\t\terror: a.error?.map((x) => x.fn),\n\t\tstop: a.stop?.map((x) => x.fn)\n\t}\n}\n\nexport const cloneInference = (inference: {\n\tevent: Sucrose.Inference\n\ttrace: Sucrose.TraceInference\n}): {\n\tevent: Sucrose.Inference\n\ttrace: Sucrose.TraceInference\n} => ({\n\tevent: {\n\t\tbody: inference.event.body,\n\t\tcookie: inference.event.cookie,\n\t\theaders: inference.event.headers,\n\t\tqueries: [...inference.event.queries],\n\t\tquery: inference.event.query,\n\t\tset: inference.event.set,\n\t\tunknownQueries: inference.event.unknownQueries\n\t},\n\ttrace: {\n\t\trequest: inference.trace.request,\n\t\tparse: inference.trace.parse,\n\t\ttransform: inference.trace.transform,\n\t\thandle: inference.trace.handle,\n\t\tbeforeHandle: inference.trace.beforeHandle,\n\t\tafterHandle: inference.trace.afterHandle,\n\t\terror: inference.trace.error,\n\t\tcontext: inference.trace.context,\n\t\tstore: inference.trace.store,\n\t\tset: inference.trace.set\n\t}\n})\n\n/**\n *\n * @param url URL to redirect to\n * @param HTTP status code to send,\n */\nexport const redirect = (\n\turl: string,\n\tstatus: number = 301\n) =>\n\tnew Response(null, {\n\t\tstatus,\n\t\theaders: {\n\t\t\tLocation: url\n\t\t}\n\t})\n\nexport type redirect = typeof redirect\n",
  "import type { TSchema } from '@sinclair/typebox'\nimport { Value } from '@sinclair/typebox/value'\nimport type { TypeCheck } from '@sinclair/typebox/compiler'\n\nimport { StatusMap, InvertedStatusMap } from './utils'\n\n// ? Cloudflare worker support\nconst env =\n\ttypeof Bun !== 'undefined'\n\t\t? Bun.env\n\t\t: typeof process !== 'undefined'\n\t\t? process?.env\n\t\t: undefined\n\nexport const ERROR_CODE = Symbol('ElysiaErrorCode')\nexport const ELYSIA_RESPONSE = Symbol('ElysiaResponse')\nexport type ELYSIA_RESPONSE = typeof ELYSIA_RESPONSE\n\nexport const isProduction = (env?.NODE_ENV ?? env?.ENV) === 'production'\n\nexport type ElysiaErrors =\n\t| InternalServerError\n\t| NotFoundError\n\t| ParseError\n\t| ValidationError\n\t| InvalidCookieSignature\n\nexport const error = <\n\tconst Code extends number | keyof StatusMap,\n\tconst T = Code extends keyof InvertedStatusMap\n\t\t? InvertedStatusMap[Code]\n\t\t: Code,\n\tconst Status extends Code extends keyof StatusMap\n\t\t? StatusMap[Code]\n\t\t: Code = Code extends keyof StatusMap ? StatusMap[Code] : Code\n>(\n\tcode: Code,\n\tresponse?: T\n): {\n\t[ELYSIA_RESPONSE]: Status\n\tresponse: T\n\t_type: {\n\t\t[ERROR_CODE in Status]: T\n\t}\n} =>\n\t({\n\t\t// @ts-expect-error\n\t\t[ELYSIA_RESPONSE]: StatusMap[code] ?? code,\n\t\tresponse:\n\t\t\tresponse ??\n\t\t\t(code in InvertedStatusMap\n\t\t\t\t? // @ts-expect-error Always correct\n\t\t\t\t  InvertedStatusMap[code]\n\t\t\t\t: code),\n\t\t_type: undefined as any\n\t} as const)\n\nexport class InternalServerError extends Error {\n\tcode = 'INTERNAL_SERVER_ERROR'\n\tstatus = 500\n\n\tconstructor(message?: string) {\n\t\tsuper(message ?? 'INTERNAL_SERVER_ERROR')\n\t}\n}\n\nexport class NotFoundError extends Error {\n\tcode = 'NOT_FOUND'\n\tstatus = 404\n\n\tconstructor(message?: string) {\n\t\tsuper(message ?? 'NOT_FOUND')\n\t}\n}\n\nexport class ParseError extends Error {\n\tcode = 'PARSE'\n\tstatus = 400\n\n\tconstructor(message?: string, public body?: unknown) {\n\t\tsuper(message ?? 'PARSE')\n\t}\n}\n\nexport class InvalidCookieSignature extends Error {\n\tcode = 'INVALID_COOKIE_SIGNATURE'\n\tstatus = 400\n\n\tconstructor(public key: string, message?: string) {\n\t\tsuper(message ?? `\"${key}\" has invalid cookie signature`)\n\t}\n}\n\nexport class ValidationError extends Error {\n\tcode = 'VALIDATION'\n\tstatus = 422\n\n\tconstructor(\n\t\tpublic type: string,\n\t\tpublic validator: TSchema | TypeCheck<any>,\n\t\tpublic value: unknown\n\t) {\n\t\t// @ts-expect-error\n\t\tif (typeof value === 'object' && ELYSIA_RESPONSE in value)\n\t\t\t// @ts-expect-error\n\t\t\tvalue = value.response\n\n\t\tconst error = isProduction\n\t\t\t? undefined\n\t\t\t: 'Errors' in validator\n\t\t\t? validator.Errors(value).First()\n\t\t\t: Value.Errors(validator, value).First()\n\n\t\tconst customError = error?.schema.error\n\t\t\t? typeof error.schema.error === 'function'\n\t\t\t\t? error.schema.error(type, validator, value)\n\t\t\t\t: error.schema.error\n\t\t\t: undefined\n\n\t\tconst accessor = error?.path || 'root'\n\t\tlet message = ''\n\n\t\tif (customError) {\n\t\t\tmessage =\n\t\t\t\ttypeof customError === 'object'\n\t\t\t\t\t? JSON.stringify(customError)\n\t\t\t\t\t: customError + ''\n\t\t} else if (isProduction) {\n\t\t\tmessage = JSON.stringify({\n\t\t\t\ttype: 'validation',\n\t\t\t\ton: type,\n\t\t\t\tmessage: error?.message,\n\t\t\t\tfound: value\n\t\t\t})\n\t\t} else {\n\t\t\t// @ts-ignore private field\n\t\t\tconst schema = validator?.schema ?? validator\n\t\t\tconst errors =\n\t\t\t\t'Errors' in validator\n\t\t\t\t\t? [...validator.Errors(value)]\n\t\t\t\t\t: [...Value.Errors(validator, value)]\n\n\t\t\tlet expected\n\n\t\t\ttry {\n\t\t\t\texpected = Value.Create(schema)\n\t\t\t} catch (error) {\n\t\t\t\texpected = {\n\t\t\t\t\ttype: 'Could not create expected value',\n\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\tmessage: error?.message,\n\t\t\t\t\terror\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmessage = JSON.stringify(\n\t\t\t\t{\n\t\t\t\t\ttype: 'validation',\n\t\t\t\t\ton: type,\n\t\t\t\t\tproperty: accessor,\n\t\t\t\t\tmessage: error?.message,\n\t\t\t\t\texpected,\n\t\t\t\t\tfound: value,\n\t\t\t\t\terrors\n\t\t\t\t},\n\t\t\t\tnull,\n\t\t\t\t2\n\t\t\t)\n\t\t}\n\n\t\tsuper(message)\n\n\t\tObject.setPrototypeOf(this, ValidationError.prototype)\n\t}\n\n\tget all() {\n\t\treturn [...this.validator.Errors(this.value)]\n\t}\n\n\tstatic simplifyModel(validator: TSchema | TypeCheck<any>) {\n\t\t// @ts-ignore\n\t\tconst model = 'schema' in validator ? validator.schema : validator\n\n\t\ttry {\n\t\t\treturn Value.Create(model)\n\t\t} catch {\n\t\t\treturn model\n\t\t}\n\t}\n\n\tget model() {\n\t\treturn ValidationError.simplifyModel(this.validator)\n\t}\n\n\ttoResponse(headers?: Record<string, any>) {\n\t\treturn new Response(this.message, {\n\t\t\tstatus: 400,\n\t\t\theaders: {\n\t\t\t\t...headers,\n\t\t\t\t'content-type': 'application/json'\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "import type { ServerWebSocket, WebSocketHandler } from 'bun'\n\nimport type { TSchema } from '@sinclair/typebox'\nimport type { TypeCheck } from '@sinclair/typebox/compiler'\n\nimport { ValidationError } from '../error'\nimport type { Context } from '../context'\n\nimport type { SingletonBase, RouteSchema } from '../types'\n\nexport const websocket: WebSocketHandler<any> = {\n\topen(ws) {\n\t\tws.data.open?.(ws)\n\t},\n\tmessage(ws, message) {\n\t\tws.data.message?.(ws, message)\n\t},\n\tdrain(ws) {\n\t\tws.data.drain?.(ws)\n\t},\n\tclose(ws, code, reason) {\n\t\tws.data.close?.(ws, code, reason)\n\t}\n}\n\nexport class ElysiaWS<\n\tWS extends ServerWebSocket<{\n\t\tid?: string\n\t\tvalidator?: TypeCheck<TSchema>\n\t}>,\n\tRoute extends RouteSchema = RouteSchema,\n\tSingleton extends SingletonBase = {\n\t\tdecorator: {}\n\t\tstore: {}\n\t\tderive: {}\n\t\tresolve: {}\n\t}\n> {\n\tvalidator?: TypeCheck<TSchema>\n\n\tconstructor(public raw: WS, public data: Context<Route, Singleton>) {\n\t\tthis.validator = raw.data.validator\n\t\tif (raw.data.id) {\n\t\t\tthis.id = raw.data.id\n\t\t} else {\n\t\t\tconst array = new Uint32Array(1)\n\t\t\tcrypto.getRandomValues(array)\n\t\t\tthis.id = array[0].toString()\n\t\t}\n\t}\n\n\tget id() {\n\t\treturn this.raw.data.id!\n\t}\n\n\tset id(newID: string) {\n\t\tthis.raw.data.id = newID\n\t}\n\n\tget publish() {\n\t\treturn (\n\t\t\ttopic: string,\n\t\t\tdata: Route['response'] = undefined,\n\t\t\tcompress?: boolean\n\t\t) => {\n\t\t\tif (this.validator?.Check(data) === false)\n\t\t\t\tthrow new ValidationError('message', this.validator, data)\n\n\t\t\tif (typeof data === 'object') data = JSON.stringify(data)\n\n\t\t\tthis.raw.publish(topic, data as unknown as string, compress)\n\n\t\t\treturn this\n\t\t}\n\t}\n\n\tget send() {\n\t\treturn (data: Route['response']) => {\n\t\t\tif (this.validator?.Check(data) === false)\n\t\t\t\tthrow new ValidationError('message', this.validator, data)\n\n\t\t\tif (Buffer.isBuffer(data)) {\n\t\t\t\tthis.raw.send(data as unknown as Buffer)\n\n\t\t\t\treturn this\n\t\t\t}\n\n\t\t\tif (typeof data === 'object') data = JSON.stringify(data)\n\n\t\t\tthis.raw.send(data as unknown as string)\n\n\t\t\treturn this\n\t\t}\n\t}\n\n\tget subscribe() {\n\t\treturn (room: string) => {\n\t\t\tthis.raw.subscribe(room)\n\n\t\t\treturn this\n\t\t}\n\t}\n\n\tget unsubscribe() {\n\t\treturn (room: string) => {\n\t\t\tthis.raw.unsubscribe(room)\n\n\t\t\treturn this\n\t\t}\n\t}\n\n\tget cork() {\n\t\treturn (callback: () => this) => {\n\t\t\tthis.raw.cork(callback as any)\n\n\t\t\treturn this\n\t\t}\n\t}\n\n\tget close() {\n\t\treturn () => {\n\t\t\tthis.raw.close()\n\n\t\t\treturn this\n\t\t}\n\t}\n\n\tget terminate() {\n\t\treturn this.raw.terminate.bind(this.raw)\n\t}\n\n\tget isSubscribed() {\n\t\treturn this.raw.isSubscribed.bind(this.raw)\n\t}\n\n\tget remoteAddress() {\n\t\treturn this.raw.remoteAddress\n\t}\n}\n",
  "import { type Elysia } from '.'\n\nimport { Value } from '@sinclair/typebox/value'\nimport type { TAnySchema } from '@sinclair/typebox'\n\nimport { parse as parseQuery } from 'fast-querystring'\n\n// @ts-expect-error\nimport decodeURIComponent from 'fast-decode-uri-component'\n\nimport {\n\tgetCookieValidator,\n\tlifeCycleToFn,\n\tredirect,\n\tsignCookie\n} from './utils'\nimport { ParseError, error } from './error'\n\nimport {\n\tmapEarlyResponse,\n\tmapResponse,\n\tmapCompactResponse,\n\tisNotEmpty\n} from './handler'\nimport {\n\tNotFoundError,\n\tValidationError,\n\tInternalServerError,\n\tERROR_CODE,\n\tELYSIA_RESPONSE\n} from './error'\n\nimport { Sucrose, sucrose } from './sucrose'\nimport { parseCookie, type CookieOptions } from './cookies'\n\nimport type {\n\tComposedHandler,\n\tHandler,\n\tHookContainer,\n\tLifeCycleStore,\n\tSchemaValidator,\n\tTraceEvent\n} from './types'\n\nconst headersHasToJSON = (new Headers() as Headers).toJSON\nconst requestId = { value: 0 }\n\nconst createReport = ({\n\thasTrace,\n\thasTraceSet = false,\n\taddFn,\n\tcondition = {}\n}: {\n\thasTrace: boolean | number\n\thasTraceSet?: boolean\n\taddFn(string: string): void\n\tcondition: Partial<Record<TraceEvent, boolean>>\n}) => {\n\tif (hasTrace) {\n\t\taddFn(`\\nconst reporter = getReporter()\\n`)\n\n\t\treturn (\n\t\t\tevent: TraceEvent,\n\t\t\t{\n\t\t\t\tname,\n\t\t\t\tattribute = '',\n\t\t\t\tunit = 0\n\t\t\t}: {\n\t\t\t\tname?: string\n\t\t\t\tattribute?: string\n\t\t\t\tunit?: number\n\t\t\t} = {}\n\t\t) => {\n\t\t\tconst dotIndex = event.indexOf('.')\n\t\t\tconst isGroup = dotIndex === -1\n\n\t\t\tif (\n\t\t\t\tevent !== 'request' &&\n\t\t\t\tevent !== 'response' &&\n\t\t\t\t!condition[\n\t\t\t\t\t(isGroup\n\t\t\t\t\t\t? event\n\t\t\t\t\t\t: event.slice(0, dotIndex)) as keyof typeof condition\n\t\t\t\t]\n\t\t\t)\n\t\t\t\treturn () => {\n\t\t\t\t\tif (hasTraceSet && event === 'afterHandle')\n\t\t\t\t\t\taddFn(`\\nawait traceDone\\n`)\n\t\t\t\t}\n\n\t\t\tif (isGroup) name ||= event\n\t\t\telse name ||= 'anonymous'\n\n\t\t\taddFn(\n\t\t\t\t'\\n' +\n\t\t\t\t\t`reporter.emit('event', {\n\t\t\t\t\tid,\n\t\t\t\t\tevent: '${event}',\n\t\t\t\t\ttype: 'begin',\n\t\t\t\t\tname: '${name}',\n\t\t\t\t\ttime: performance.now(),\n\t\t\t\t\t${isGroup ? `unit: ${unit},` : ''}\n\t\t\t\t\t${attribute}\n\t\t\t\t})`.replace(/(\\t| |\\n)/g, '') +\n\t\t\t\t\t'\\n'\n\t\t\t)\n\n\t\t\treturn () => {\n\t\t\t\taddFn(\n\t\t\t\t\t'\\n' +\n\t\t\t\t\t\t`reporter.emit('event', {\n\t\t\t\t\t\t\tid,\n\t\t\t\t\t\t\tevent: '${event}',\n\t\t\t\t\t\t\ttype: 'end',\n\t\t\t\t\t\t\ttime: performance.now()\n\t\t\t\t\t\t})`.replace(/(\\t| |\\n)/g, '') +\n\t\t\t\t\t\t'\\n'\n\t\t\t\t)\n\n\t\t\t\tif (hasTraceSet && event === 'afterHandle')\n\t\t\t\t\taddFn(`\\nawait traceDone\\n`)\n\t\t\t}\n\t\t}\n\t} else {\n\t\treturn () => () => {}\n\t}\n}\n\nexport const hasReturn = (fnLiteral: string) => {\n\tconst parenthesisEnd = fnLiteral.indexOf(')')\n\n\t// Is direct arrow function return eg. () => 1\n\tif (\n\t\tfnLiteral.charCodeAt(parenthesisEnd + 2) === 61 &&\n\t\tfnLiteral.charCodeAt(parenthesisEnd + 5) !== 123\n\t) {\n\t\treturn true\n\t}\n\n\treturn fnLiteral.includes('return')\n}\n\nconst composeValidationFactory = (\n\thasErrorHandler: boolean,\n\t{\n\t\tinjectResponse = '',\n\t\tnormalize = false\n\t}: {\n\t\tinjectResponse?: string\n\t\tnormalize?: boolean\n\t} = {}\n) => ({\n\tcomposeValidation: (type: string, value = `c.${type}`) =>\n\t\thasErrorHandler\n\t\t\t? `c.set.status = 422; throw new ValidationError('${type}', ${type}, ${value})`\n\t\t\t: `c.set.status = 422; return new ValidationError('${type}', ${type}, ${value}).toResponse(c.set.headers)`,\n\tcomposeResponseValidation: (name = 'r') => {\n\t\tconst returnError = hasErrorHandler\n\t\t\t? `throw new ValidationError('response', response[c.set.status], ${name})`\n\t\t\t: `return new ValidationError('response', response[c.set.status], ${name}).toResponse(c.set.headers)`\n\n\t\tlet code = '\\n' + injectResponse + '\\n'\n\n\t\tcode += `let er\n\n\t\tif(${name} && typeof ${name} === \"object\" && ELYSIA_RESPONSE in ${name})\n\t\t\ter = ${name}[ELYSIA_RESPONSE]\\n`\n\n\t\tif (normalize)\n\t\t\tcode += `\n\t\t\tif(!er && response[c.set.status]?.Clean)\n\t\t\t\t${name} = response[c.set.status]?.Clean(${name})\n\t\t\telse if(response[er]?.Clean)\n\t\t\t\t${name}.response = response[er]?.Clean(${name}.response)`\n\n\t\tcode += `\n\t\t\tif(er) {\n\t\t\t\tif(!(${name} instanceof Response) && response[er]?.Check(${name}.response) === false) {\n\t\t\t\t\tif(!(response instanceof Error)) {\n\t\t\t\t\t\tc.set.status = ${name}[ELYSIA_RESPONSE]\n\n\t\t\t\t\t\t${returnError}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if(!(${name} instanceof Response) && response[c.set.status]?.Check(${name}) === false) {\n\t\t\t\tif(!(response instanceof Error))\n\t\t\t\t\t${returnError}\n\t\t\t}\\n`\n\n\t\treturn code\n\t}\n})\n\nconst KindSymbol = Symbol.for('TypeBox.Kind')\n\nexport const hasType = (type: string, schema: TAnySchema) => {\n\tif (!schema) return\n\n\tif (KindSymbol in schema && schema[KindSymbol] === type) return true\n\n\tif (schema.type === 'object') {\n\t\tconst properties = schema.properties as Record<string, TAnySchema>\n\t\tfor (const key of Object.keys(properties)) {\n\t\t\tconst property = properties[key]\n\n\t\t\tif (property.type === 'object') {\n\t\t\t\tif (hasType(type, property)) return true\n\t\t\t} else if (property.anyOf) {\n\t\t\t\tfor (let i = 0; i < property.anyOf.length; i++)\n\t\t\t\t\tif (hasType(type, property.anyOf[i])) return true\n\t\t\t}\n\n\t\t\tif (KindSymbol in property && property[KindSymbol] === type)\n\t\t\t\treturn true\n\t\t}\n\n\t\treturn false\n\t}\n\n\treturn (\n\t\tschema.properties &&\n\t\tKindSymbol in schema.properties &&\n\t\tschema.properties[KindSymbol] === type\n\t)\n}\n\nexport const hasProperty = (expectedProperty: string, schema: TAnySchema) => {\n\tif (!schema) return\n\n\tif (schema.type === 'object') {\n\t\tconst properties = schema.properties as Record<string, TAnySchema>\n\n\t\tif (!properties) return false\n\n\t\tfor (const key of Object.keys(properties)) {\n\t\t\tconst property = properties[key]\n\n\t\t\tif (expectedProperty in property) return true\n\n\t\t\tif (property.type === 'object') {\n\t\t\t\tif (hasProperty(expectedProperty, property)) return true\n\t\t\t} else if (property.anyOf) {\n\t\t\t\tfor (let i = 0; i < property.anyOf.length; i++) {\n\t\t\t\t\tif (hasProperty(expectedProperty, property.anyOf[i]))\n\t\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false\n\t}\n\n\treturn expectedProperty in schema\n}\n\nconst TransformSymbol = Symbol.for('TypeBox.Transform')\n\nexport const hasTransform = (schema: TAnySchema) => {\n\tif (!schema) return\n\n\tif (schema.type === 'object' && schema.properties) {\n\t\tconst properties = schema.properties as Record<string, TAnySchema>\n\t\tfor (const key of Object.keys(properties)) {\n\t\t\tconst property = properties[key]\n\n\t\t\tif (property.type === 'object') {\n\t\t\t\tif (hasTransform(property)) return true\n\t\t\t} else if (property.anyOf) {\n\t\t\t\tfor (let i = 0; i < property.anyOf.length; i++)\n\t\t\t\t\tif (hasTransform(property.anyOf[i])) return true\n\t\t\t}\n\n\t\t\tconst hasTransformSymbol = TransformSymbol in property\n\t\t\tif (hasTransformSymbol) return true\n\t\t}\n\n\t\treturn false\n\t}\n\n\treturn (\n\t\tTransformSymbol in schema ||\n\t\t(schema.properties && TransformSymbol in schema.properties)\n\t)\n}\n\n/**\n * This function will return the type of unioned if all unioned type is the same.\n * It's intent to use for content-type mapping only\n *\n * ```ts\n * t.Union([\n *   t.Object({\n *     password: t.String()\n *   }),\n *   t.Object({\n *     token: t.String()\n *   })\n * ])\n * ```\n */\n// const getUnionedType = (validator: TypeCheck<any> | undefined) => {\n// \tif (!validator) return\n\n// \t// @ts-ignore\n// \tconst schema = validator?.schema\n\n// \tif (schema && 'anyOf' in schema) {\n// \t\tlet foundDifference = false\n// \t\tconst type: string = schema.anyOf[0].type\n\n// \t\tfor (const validator of schema.anyOf as { type: string }[]) {\n// \t\t\tif (validator.type !== type) {\n// \t\t\t\tfoundDifference = true\n// \t\t\t\tbreak\n// \t\t\t}\n// \t\t}\n\n// \t\tif (!foundDifference) return type\n// \t}\n\n// \t// @ts-ignore\n// \treturn validator.schema?.type\n// }\n\nconst matchFnReturn = /(?:return|=>) \\S+\\(/g\n\nexport const isAsync = (v: Function | HookContainer) => {\n\tconst fn = 'fn' in v ? v.fn : v\n\n\tif (fn.constructor.name === 'AsyncFunction') return true\n\n\tconst literal = fn.toString()\n\tif (literal.includes('=> response.clone(')) return false\n\tif (literal.includes('await')) return true\n\tif (literal.includes('async')) return true\n\n\treturn !!literal.match(matchFnReturn)\n}\n\nexport const composeHandler = ({\n\tapp,\n\tpath,\n\tmethod,\n\tlocalHook,\n\thooks,\n\tvalidator,\n\thandler,\n\tallowMeta = false,\n\tappInference: { event: eventInference, trace: traceInference }\n}: {\n\tapp: Elysia<any, any, any, any, any, any, any, any>\n\tpath: string\n\tmethod: string\n\thooks: LifeCycleStore\n\tlocalHook: LifeCycleStore\n\tvalidator: SchemaValidator\n\thandler: unknown | Handler<any, any>\n\tallowMeta?: boolean\n\tappInference: {\n\t\tevent: Sucrose.Inference\n\t\ttrace: Sucrose.TraceInference\n\t}\n}): ComposedHandler => {\n\tconst isHandleFn = typeof handler === 'function'\n\n\tif (!isHandleFn)\n\t\thandler = mapResponse(handler, {\n\t\t\t// @ts-expect-error private property\n\t\t\theaders: app.setHeaders ?? {}\n\t\t})\n\n\tconst hasErrorHandler =\n\t\t(app.config.forceErrorEncapsulation &&\n\t\t\t(isHandleFn ||\n\t\t\t\thooks.afterHandle.length > 0 ||\n\t\t\t\thooks.beforeHandle.length > 0 ||\n\t\t\t\thooks.transform.length > 0)) ||\n\t\thooks.error.length > 0 ||\n\t\tapp.event.error.length > 0 ||\n\t\ttypeof Bun === 'undefined' ||\n\t\thooks.onResponse.length > 0 ||\n\t\t!!hooks.trace.length\n\n\tconst handle = isHandleFn ? `handler(c)` : `handler`\n\tconst handleResponse = hooks.onResponse.length\n\t\t? `\\n;(async () => {${hooks.onResponse\n\t\t\t\t.map((_, i) => `await res${i}(c)`)\n\t\t\t\t.join(';')}})();\\n`\n\t\t: ''\n\n\tconst traceConditions: Record<\n\t\tExclude<TraceEvent, `${string}.unit` | 'request' | 'response' | 'exit'>,\n\t\tboolean\n\t> = traceInference\n\n\tconst hasTrace = hooks.trace.length > 0\n\tlet fnLiteral = ''\n\n\tconst inference = sucrose(\n\t\tObject.assign(localHook, {\n\t\t\thandler: handler as any\n\t\t}),\n\t\teventInference\n\t)\n\n\tconst hasQuery = inference.query || !!validator.query\n\n\tconst hasBody =\n\t\tmethod !== '$INTERNALWS' &&\n\t\tmethod !== 'GET' &&\n\t\tmethod !== 'HEAD' &&\n\t\thooks.type !== 'none' &&\n\t\t(inference.body || !!validator.body)\n\n\t// @ts-expect-error private\n\tconst defaultHeaders = app.setHeaders\n\tconst hasDefaultHeaders =\n\t\tdefaultHeaders && !!Object.keys(defaultHeaders).length\n\n\t// ? defaultHeaders doesn't imply that user will use headers in handler\n\tconst hasHeaders = inference.headers || validator.headers\n\tconst hasCookie = inference.cookie || !!validator.cookie\n\n\tconst cookieValidator = hasCookie\n\t\t? getCookieValidator({\n\t\t\t\tvalidator: validator.cookie as any,\n\t\t\t\tdefaultConfig: app.config.cookie,\n\t\t\t\tdynamic: !!app.config.aot,\n\t\t\t\t// @ts-expect-error\n\t\t\t\tconfig: validator.cookie?.config ?? {},\n\t\t\t\t// @ts-expect-error\n\t\t\t\tmodels: app.definitions.type\n\t\t  })\n\t\t: undefined\n\n\t// @ts-ignore private property\n\tconst cookieMeta = cookieValidator?.config as {\n\t\tsecrets?: string | string[]\n\t\tsign: string[] | true\n\t\tproperties: { [x: string]: Object }\n\t}\n\n\tlet encodeCookie = ''\n\n\tif (cookieMeta?.sign) {\n\t\tif (!cookieMeta.secrets)\n\t\t\tthrow new Error(\n\t\t\t\t`t.Cookie required secret which is not set in (${method}) ${path}.`\n\t\t\t)\n\n\t\tconst secret = !cookieMeta.secrets\n\t\t\t? undefined\n\t\t\t: typeof cookieMeta.secrets === 'string'\n\t\t\t? cookieMeta.secrets\n\t\t\t: cookieMeta.secrets[0]\n\n\t\tencodeCookie += `const _setCookie = c.set.cookie\n\t\tif(_setCookie) {`\n\n\t\tif (cookieMeta.sign === true) {\n\t\t\tencodeCookie += `for(const [key, cookie] of Object.entries(_setCookie)) {\n\t\t\t\tc.set.cookie[key].value = await signCookie(cookie.value, '${secret}')\n\t\t\t}`\n\t\t} else\n\t\t\tfor (const name of cookieMeta.sign) {\n\t\t\t\tencodeCookie += `if(_setCookie['${name}']?.value) { c.set.cookie['${name}'].value = await signCookie(_setCookie['${name}'].value, '${secret}') }\\n`\n\t\t\t}\n\n\t\tencodeCookie += '}\\n'\n\t}\n\n\tconst normalize = app.config.normalize\n\n\tconst { composeValidation, composeResponseValidation } =\n\t\tcomposeValidationFactory(hasErrorHandler, {\n\t\t\tnormalize\n\t\t})\n\n\tif (hasHeaders) {\n\t\t// This function is Bun specific\n\t\t// @ts-ignore\n\t\tfnLiteral += headersHasToJSON\n\t\t\t? `c.headers = c.request.headers.toJSON()\\n`\n\t\t\t: `c.headers = {}\n                for (const [key, value] of c.request.headers.entries())\n\t\t\t\t\tc.headers[key] = value\n\t\t\t\t`\n\t}\n\n\tif (hasCookie) {\n\t\tconst get = (name: keyof CookieOptions, defaultValue?: unknown) => {\n\t\t\t// @ts-ignore\n\t\t\tconst value = cookieMeta?.[name] ?? defaultValue\n\t\t\tif (!value)\n\t\t\t\treturn typeof defaultValue === 'string'\n\t\t\t\t\t? `${name}: \"${defaultValue}\",`\n\t\t\t\t\t: `${name}: ${defaultValue},`\n\n\t\t\tif (typeof value === 'string') return `${name}: '${value}',`\n\t\t\tif (value instanceof Date)\n\t\t\t\treturn `${name}: new Date(${value.getTime()}),`\n\n\t\t\treturn `${name}: ${value},`\n\t\t}\n\n\t\tconst options = cookieMeta\n\t\t\t? `{\n\t\t\tsecrets: ${\n\t\t\t\tcookieMeta.secrets !== undefined\n\t\t\t\t\t? typeof cookieMeta.secrets === 'string'\n\t\t\t\t\t\t? `'${cookieMeta.secrets}'`\n\t\t\t\t\t\t: '[' +\n\t\t\t\t\t\t  cookieMeta.secrets.reduce(\n\t\t\t\t\t\t\t\t(a, b) => a + `'${b}',`,\n\t\t\t\t\t\t\t\t''\n\t\t\t\t\t\t  ) +\n\t\t\t\t\t\t  ']'\n\t\t\t\t\t: 'undefined'\n\t\t\t},\n\t\t\tsign: ${\n\t\t\t\tcookieMeta.sign === true\n\t\t\t\t\t? true\n\t\t\t\t\t: cookieMeta.sign !== undefined\n\t\t\t\t\t? '[' +\n\t\t\t\t\t  cookieMeta.sign.reduce((a, b) => a + `'${b}',`, '') +\n\t\t\t\t\t  ']'\n\t\t\t\t\t: 'undefined'\n\t\t\t},\n\t\t\t${get('domain')}\n\t\t\t${get('expires')}\n\t\t\t${get('httpOnly')}\n\t\t\t${get('maxAge')}\n\t\t\t${get('path', '/')}\n\t\t\t${get('priority')}\n\t\t\t${get('sameSite')}\n\t\t\t${get('secure')}\n\t\t}`\n\t\t\t: 'undefined'\n\n\t\tif (hasHeaders)\n\t\t\tfnLiteral += `\\nc.cookie = await parseCookie(c.set, c.headers.cookie, ${options})\\n`\n\t\telse\n\t\t\tfnLiteral += `\\nc.cookie = await parseCookie(c.set, c.request.headers.get('cookie'), ${options})\\n`\n\t}\n\n\tif (hasQuery) {\n\t\tlet destructured = [] as string[]\n\n\t\t// @ts-ignore\n\t\tif (validator.query && validator.query.schema.type === 'object') {\n\t\t\t// @ts-ignore\n\t\t\tdestructured = Object.keys(validator.query.schema.properties)\n\t\t} else\n\t\t\tfor (const query of inference.queries)\n\t\t\t\tif (destructured.indexOf(query) === -1) destructured.push(query)\n\n\t\tif (\n\t\t\tapp.config.forceDynamicQuery === true ||\n\t\t\tinference.unknownQueries === true ||\n\t\t\t!destructured.length\n\t\t) {\n\t\t\tfnLiteral += `if(c.qi !== -1) {\n\t\t\t\tc.query = parseQuery(c.request.url.slice(c.qi + 1).replace(/\\\\+/g, ' '))\n\n\t\t\t\tfor(const key of Object.keys(c.query))\n\t\t\t\t\tc.query[key] = decodeURIComponent(c.query[key])\n\t\t\t} else c.query = {}`\n\t\t} else {\n\t\t\tfnLiteral += `if(c.qi !== -1) {\n\t\t\t\tlet url = c.request.url.slice(c.qi).replace(/\\\\+/g, ' ')\n\n\t\t\t\t${destructured\n\t\t\t\t\t.map(\n\t\t\t\t\t\t(name, index) => `\n\t\t\t\t\t\t${index === 0 ? 'let' : ''} memory = url.indexOf('&${name}=')\n\t\t\t\t\t\tif(memory === -1) memory = url.indexOf('?${name}=')\n\t\t\t\t\t\tlet a${index}\n\n\t\t\t\t\t\tif(memory !== -1) {\n\t\t\t\t\t\t\tconst start = memory + ${name.length + 2}\n\t\t\t\t\t\t\tmemory = url.indexOf('&', start)\n\n\t\t\t\t\t\t\tif(memory === -1) a${index} = decodeURIComponent(url.slice(start))\n\t\t\t\t\t\t\telse a${index} = decodeURIComponent(url.slice(start, memory))\n\t\t\t\t\t\t}`\n\t\t\t\t\t)\n\t\t\t\t\t.join('\\n')}\n\n\t\t\t\tc.query = {\n\t\t\t\t\t${destructured.map((name, index) => `'${name}': a${index}`).join(', ')}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tc.query = {}\n\t\t\t}`\n\t\t}\n\t}\n\n\tconst hasTraceSet = traceInference.set\n\tconst hasSet =\n\t\tinference.cookie ||\n\t\tinference.set ||\n\t\thasTraceSet ||\n\t\thasHeaders ||\n\t\t(isHandleFn && hasDefaultHeaders)\n\n\tif (hasTrace) fnLiteral += '\\nconst id = c.$$requestId\\n'\n\n\tconst report = createReport({\n\t\thasTrace,\n\t\thasTraceSet,\n\t\tcondition: traceConditions,\n\t\taddFn: (word) => {\n\t\t\tfnLiteral += word\n\t\t}\n\t})\n\n\tfnLiteral += hasErrorHandler ? '\\n try {\\n' : ''\n\n\tif (hasTraceSet) {\n\t\tfnLiteral += `\\nconst traceDone = Promise.all([`\n\t\tfor (let i = 0; i < hooks.trace.length; i++) {\n\t\t\tfnLiteral += `new Promise(r => { reporter.once(\\`res\\${id}.${i}\\`, r) }),`\n\t\t}\n\t\tfnLiteral += `])\\n`\n\t}\n\n\tconst isAsyncHandler = typeof handler === 'function' && isAsync(handler)\n\n\tconst maybeAsync =\n\t\thasCookie ||\n\t\thasBody ||\n\t\thasTraceSet ||\n\t\tisAsyncHandler ||\n\t\t!!hooks.mapResponse.length ||\n\t\thooks.parse.length > 0 ||\n\t\thooks.afterHandle.some(isAsync) ||\n\t\thooks.beforeHandle.some(isAsync) ||\n\t\thooks.transform.some(isAsync)\n\n\tconst endParse = report('parse', {\n\t\tunit: hooks.parse.length\n\t})\n\n\tif (hasBody) {\n\t\tconst hasBodyInference =\n\t\t\thooks.parse.length || inference.body || validator.body\n\n\t\tif (hooks.type && !hooks.parse.length) {\n\t\t\tswitch (hooks.type) {\n\t\t\t\tcase 'json':\n\t\t\t\tcase 'application/json':\n\t\t\t\t\tif (hasErrorHandler)\n\t\t\t\t\t\tfnLiteral += `const tempBody = await c.request.text()\n\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tc.body = JSON.parse(tempBody)\n\t\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\t\tthrow new ParseError('Failed to parse body as found: ' + (typeof body === \"string\" ? \"'\" + body + \"'\" : body), body)\n\t\t\t\t\t\t\t}`\n\t\t\t\t\telse fnLiteral += `c.body = await c.request.json()`\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'text':\n\t\t\t\tcase 'text/plain':\n\t\t\t\t\tfnLiteral += `c.body = await c.request.text()\\n`\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'urlencoded':\n\t\t\t\tcase 'application/x-www-form-urlencoded':\n\t\t\t\t\tfnLiteral += `c.body = parseQuery(await c.request.text())\\n`\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'arrayBuffer':\n\t\t\t\tcase 'application/octet-stream':\n\t\t\t\t\tfnLiteral += `c.body = await c.request.arrayBuffer()\\n`\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'formdata':\n\t\t\t\tcase 'multipart/form-data':\n\t\t\t\t\tfnLiteral += `c.body = {}\n\n\t\t\t\t\t\tconst form = await c.request.formData()\n\t\t\t\t\t\tfor (const key of form.keys()) {\n\t\t\t\t\t\t\tif (c.body[key])\n\t\t\t\t\t\t\t\tcontinue\n\n\t\t\t\t\t\t\tconst value = form.getAll(key)\n\t\t\t\t\t\t\tif (value.length === 1)\n\t\t\t\t\t\t\t\tc.body[key] = value[0]\n\t\t\t\t\t\t\telse c.body[key] = value\n\t\t\t\t\t\t}\\n`\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t} else if (hasBodyInference) {\n\t\t\tfnLiteral += '\\n'\n\t\t\tfnLiteral += hasHeaders\n\t\t\t\t? `let contentType = c.headers['content-type']`\n\t\t\t\t: `let contentType = c.request.headers.get('content-type')`\n\n\t\t\tfnLiteral += `\n\t\t\t\tif (contentType) {\n\t\t\t\t\tconst index = contentType.indexOf(';')\n\t\t\t\t\tif (index !== -1) contentType = contentType.substring(0, index)\\n\n\t\t\t\t\tc.contentType = contentType\\n`\n\n\t\t\tif (hooks.parse.length) {\n\t\t\t\tfnLiteral += `let used = false\\n`\n\n\t\t\t\tconst endReport = report('parse', {\n\t\t\t\t\tunit: hooks.parse.length\n\t\t\t\t})\n\n\t\t\t\tfor (let i = 0; i < hooks.parse.length; i++) {\n\t\t\t\t\tconst endUnit = report('parse.unit', {\n\t\t\t\t\t\tname: hooks.parse[i].fn.name\n\t\t\t\t\t})\n\n\t\t\t\t\tconst name = `bo${i}`\n\n\t\t\t\t\tif (i !== 0) fnLiteral += `if(!used) {\\n`\n\n\t\t\t\t\tfnLiteral += `let ${name} = parse[${i}](c, contentType)\\n`\n\t\t\t\t\tfnLiteral += `if(${name} instanceof Promise) ${name} = await ${name}\\n`\n\t\t\t\t\tfnLiteral += `if(${name} !== undefined) { c.body = ${name}; used = true }\\n`\n\n\t\t\t\t\tendUnit()\n\n\t\t\t\t\tif (i !== 0) fnLiteral += `}`\n\t\t\t\t}\n\n\t\t\t\tendReport()\n\t\t\t}\n\n\t\t\tfnLiteral += '\\ndelete c.contentType\\n'\n\n\t\t\tif (hooks.parse.length) fnLiteral += `if (!used) {`\n\n\t\t\tif (hooks.type && !Array.isArray(hooks.type)) {\n\t\t\t\tswitch (hooks.type) {\n\t\t\t\t\tcase 'json':\n\t\t\t\t\tcase 'application/json':\n\t\t\t\t\t\tif (hasErrorHandler)\n\t\t\t\t\t\t\tfnLiteral += `const tempBody = await c.request.text()\n\t\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tc.body = JSON.parse(tempBody)\n\t\t\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\t\t\tthrow new ParseError('Failed to parse body as found: ' + (typeof body === \"string\" ? \"'\" + body + \"'\" : body), body)\n\t\t\t\t\t\t\t\t}`\n\t\t\t\t\t\telse fnLiteral += `c.body = await c.request.json()`\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'text':\n\t\t\t\t\tcase 'text/plain':\n\t\t\t\t\t\tfnLiteral += `c.body = await c.request.text()\\n`\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'urlencoded':\n\t\t\t\t\tcase 'application/x-www-form-urlencoded':\n\t\t\t\t\t\tfnLiteral += `c.body = parseQuery(await c.request.text())\\n`\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'arrayBuffer':\n\t\t\t\t\tcase 'application/octet-stream':\n\t\t\t\t\t\tfnLiteral += `c.body = await c.request.arrayBuffer()\\n`\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'formdata':\n\t\t\t\t\tcase 'multipart/form-data':\n\t\t\t\t\t\tfnLiteral += `c.body = {}\n\t\n\t\t\t\t\t\t\tconst form = await c.request.formData()\n\t\t\t\t\t\t\tfor (const key of form.keys()) {\n\t\t\t\t\t\t\t\tif (c.body[key])\n\t\t\t\t\t\t\t\t\tcontinue\n\t\n\t\t\t\t\t\t\t\tconst value = form.getAll(key)\n\t\t\t\t\t\t\t\tif (value.length === 1)\n\t\t\t\t\t\t\t\t\tc.body[key] = value[0]\n\t\t\t\t\t\t\t\telse c.body[key] = value\n\t\t\t\t\t\t\t}\\n`\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfnLiteral += `\n\t\t\t\t\tswitch (contentType) {\n\t\t\t\t\t\tcase 'application/json':\n\t\t\t\t\t\t\t${\n\t\t\t\t\t\t\t\thasErrorHandler\n\t\t\t\t\t\t\t\t\t? `\n\t\t\t\t\t\t\tconst tempBody = await c.request.text()\n\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tc.body = JSON.parse(tempBody)\n\t\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\t\tthrow new ParseError('Failed to parse body as found: ' + (typeof body === \"string\" ? \"'\" + body + \"'\" : body), body)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t`\n\t\t\t\t\t\t\t\t\t: `c.body = await c.request.json()\\n`\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'text/plain':\n\t\t\t\t\t\t\tc.body = await c.request.text()\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'application/x-www-form-urlencoded':\n\t\t\t\t\t\t\tc.body = parseQuery(await c.request.text())\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'application/octet-stream':\n\t\t\t\t\t\t\tc.body = await c.request.arrayBuffer();\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'multipart/form-data':\n\t\t\t\t\t\t\tc.body = {}\n\n\t\t\t\t\t\t\tconst form = await c.request.formData()\n\t\t\t\t\t\t\tfor (const key of form.keys()) {\n\t\t\t\t\t\t\t\tif (c.body[key])\n\t\t\t\t\t\t\t\t\tcontinue\n\n\t\t\t\t\t\t\t\tconst value = form.getAll(key)\n\t\t\t\t\t\t\t\tif (value.length === 1)\n\t\t\t\t\t\t\t\t\tc.body[key] = value[0]\n\t\t\t\t\t\t\t\telse c.body[key] = value\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t}`\n\t\t\t}\n\n\t\t\tif (hooks.parse.length) fnLiteral += `}`\n\n\t\t\tfnLiteral += '}\\n'\n\t\t}\n\n\t\tfnLiteral += '\\n'\n\t}\n\n\tendParse()\n\n\tif (hooks?.transform) {\n\t\tconst endTransform = report('transform', {\n\t\t\tunit: hooks.transform.length\n\t\t})\n\n\t\tif (hooks.transform.length) fnLiteral += '\\nlet transformed\\n'\n\n\t\tfor (let i = 0; i < hooks.transform.length; i++) {\n\t\t\tconst transform = hooks.transform[i]\n\n\t\t\tconst endUnit = report('transform.unit', {\n\t\t\t\tname: transform.fn.name\n\t\t\t})\n\n\t\t\tfnLiteral += isAsync(transform)\n\t\t\t\t? `transformed = await transform[${i}](c)\\n`\n\t\t\t\t: `transformed = transform[${i}](c)\\n`\n\n\t\t\tfnLiteral += `if(transformed?.[ELYSIA_RESPONSE])\n\t\t\t\tthrow transformed\n\t\t\telse\n\t\t\t\tObject.assign(c, transformed)\\n`\n\n\t\t\tendUnit()\n\t\t}\n\n\t\tendTransform()\n\t}\n\n\tif (validator) {\n\t\tfnLiteral += '\\n'\n\n\t\tif (validator.headers) {\n\t\t\t// @ts-ignore\n\t\t\tif (hasProperty('default', validator.headers.params))\n\t\t\t\tfor (const [key, value] of Object.entries(\n\t\t\t\t\tValue.Default(\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tvalidator.headers.schema,\n\t\t\t\t\t\t{}\n\t\t\t\t\t) as Object\n\t\t\t\t)) {\n\t\t\t\t\tconst parsed =\n\t\t\t\t\t\ttypeof value === 'object'\n\t\t\t\t\t\t\t? JSON.stringify(value)\n\t\t\t\t\t\t\t: `'${value}'`\n\n\t\t\t\t\tif (parsed)\n\t\t\t\t\t\tfnLiteral += `c.headers['${key}'] ??= ${parsed}\\n`\n\t\t\t\t}\n\n\t\t\tfnLiteral += `if(headers.Check(c.headers) === false) {\n\t\t\t\t${composeValidation('headers')}\n\t\t\t}`\n\n\t\t\t// @ts-ignore\n\t\t\tif (hasTransform(validator.headers.schema))\n\t\t\t\tfnLiteral += `\\nc.headers = headers.Decode(c.headers)\\n`\n\t\t}\n\n\t\tif (validator.params) {\n\t\t\t// @ts-ignore\n\t\t\tif (hasProperty('default', validator.params.schema))\n\t\t\t\tfor (const [key, value] of Object.entries(\n\t\t\t\t\tValue.Default(\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tvalidator.params.schema,\n\t\t\t\t\t\t{}\n\t\t\t\t\t) as Object\n\t\t\t\t)) {\n\t\t\t\t\tconst parsed =\n\t\t\t\t\t\ttypeof value === 'object'\n\t\t\t\t\t\t\t? JSON.stringify(value)\n\t\t\t\t\t\t\t: `'${value}'`\n\n\t\t\t\t\tif (parsed)\n\t\t\t\t\t\tfnLiteral += `c.params['${key}'] ??= ${parsed}\\n`\n\t\t\t\t}\n\n\t\t\tfnLiteral += `if(params.Check(c.params) === false) {\n\t\t\t\t${composeValidation('params')}\n\t\t\t}`\n\n\t\t\t// @ts-ignore\n\t\t\tif (hasTransform(validator.params.schema))\n\t\t\t\tfnLiteral += `\\nc.params = params.Decode(c.params)\\n`\n\t\t}\n\n\t\tif (validator.query) {\n\t\t\tif (normalize) fnLiteral += 'c.query = query.Clean(c.query);\\n'\n\n\t\t\t// @ts-ignore\n\t\t\tif (hasProperty('default', validator.query.schema))\n\t\t\t\tfor (const [key, value] of Object.entries(\n\t\t\t\t\tValue.Default(\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tvalidator.query.schema,\n\t\t\t\t\t\t{}\n\t\t\t\t\t) as Object\n\t\t\t\t)) {\n\t\t\t\t\tconst parsed =\n\t\t\t\t\t\ttypeof value === 'object'\n\t\t\t\t\t\t\t? JSON.stringify(value)\n\t\t\t\t\t\t\t: `'${value}'`\n\n\t\t\t\t\tif (parsed) fnLiteral += `c.query['${key}'] ??= ${parsed}\\n`\n\t\t\t\t}\n\n\t\t\tfnLiteral += `if(query.Check(c.query) === false) {\n\t\t\t\t${composeValidation('query')}\n\t\t\t}`\n\n\t\t\t// @ts-ignore\n\t\t\tif (hasTransform(validator.query.schema))\n\t\t\t\t// Decode doesn't work with Object.create(null)\n\t\t\t\tfnLiteral += `\\nc.query = query.Decode(Object.assign({}, c.query))\\n`\n\t\t}\n\n\t\tif (validator.body) {\n\t\t\tif (normalize) fnLiteral += 'c.body = body.Clean(c.body);\\n'\n\t\t\t// @ts-ignore\n\t\t\tif (hasProperty('default', validator.body.schema))\n\t\t\t\tfnLiteral += `if(body.Check(c.body) === false) {\n    \t\t\t\tc.body = Object.assign(${JSON.stringify(\n\t\t\t\t\t\tValue.Default(\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\tvalidator.body.schema,\n\t\t\t\t\t\t\tnull\n\t\t\t\t\t\t) ?? {}\n\t\t\t\t\t)}, c.body)\n\n    \t\t\t\tif(body.Check(c.query) === false) {\n        \t\t\t\t${composeValidation('body')}\n     \t\t\t}\n            }`\n\t\t\telse\n\t\t\t\tfnLiteral += `if(body.Check(c.body) === false) {\n\t\t\t${composeValidation('body')}\n\t\t}`\n\n\t\t\t// @ts-ignore\n\t\t\tif (hasTransform(validator.body.schema))\n\t\t\t\tfnLiteral += `\\nc.body = body.Decode(c.body)\\n`\n\t\t}\n\n\t\t// @ts-ignore\n\t\tif (isNotEmpty(cookieValidator?.schema.properties ?? {})) {\n\t\t\tfnLiteral += `const cookieValue = {}\n    \t\t\tfor(const [key, value] of Object.entries(c.cookie))\n    \t\t\t\tcookieValue[key] = value.value\\n`\n\n\t\t\t// @ts-ignore\n\t\t\tif (hasProperty('default', cookieValidator.schema))\n\t\t\t\tfor (const [key, value] of Object.entries(\n\t\t\t\t\tValue.Default(\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tcookieValidator.schema,\n\t\t\t\t\t\t{}\n\t\t\t\t\t) as Object\n\t\t\t\t)) {\n\t\t\t\t\tfnLiteral += `cookieValue['${key}'] = ${\n\t\t\t\t\t\ttypeof value === 'object'\n\t\t\t\t\t\t\t? JSON.stringify(value)\n\t\t\t\t\t\t\t: value\n\t\t\t\t\t}\\n`\n\t\t\t\t}\n\n\t\t\tfnLiteral += `if(cookie.Check(cookieValue) === false) {\n\t\t\t\t${composeValidation('cookie', 'cookieValue')}\n\t\t\t}`\n\n\t\t\t// // @ts-ignore\n\t\t\t// if (hasTransform(validator.cookie.schema))\n\t\t\t// \tfnLiteral += `\\nc.cookie = params.Decode(c.cookie)\\n`\n\t\t}\n\t}\n\n\tif (hooks?.beforeHandle) {\n\t\tconst endBeforeHandle = report('beforeHandle', {\n\t\t\tunit: hooks.beforeHandle.length\n\t\t})\n\n\t\tlet hasResolve = false\n\n\t\tfor (let i = 0; i < hooks.beforeHandle.length; i++) {\n\t\t\tconst beforeHandle = hooks.beforeHandle[i]\n\n\t\t\tconst endUnit = report('beforeHandle.unit', {\n\t\t\t\tname: beforeHandle.fn.name\n\t\t\t})\n\n\t\t\tconst returning = hasReturn(beforeHandle.fn.toString())\n\n\t\t\tconst isResolver = beforeHandle.subType === 'resolve'\n\n\t\t\tif (isResolver) {\n\t\t\t\tif (!hasResolve) {\n\t\t\t\t\thasResolve = true\n\t\t\t\t\tfnLiteral += '\\nlet resolved\\n'\n\t\t\t\t}\n\n\t\t\t\tfnLiteral += isAsync(beforeHandle)\n\t\t\t\t\t? `resolved = await beforeHandle[${i}](c);\\n`\n\t\t\t\t\t: `resolved = beforeHandle[${i}](c);\\n`\n\n\t\t\t\tfnLiteral += `if(resolved[ELYSIA_RESPONSE])\n\t\t\t\t\t\tthrow resolved\n\t\t\t\t\telse\n\t\t\t\t\t\tObject.assign(c, resolved)\\n`\n\t\t\t} else if (!returning) {\n\t\t\t\tfnLiteral += isAsync(beforeHandle)\n\t\t\t\t\t? `await beforeHandle[${i}](c);\\n`\n\t\t\t\t\t: `beforeHandle[${i}](c);\\n`\n\n\t\t\t\tendUnit()\n\t\t\t} else {\n\t\t\t\tfnLiteral += `Object.assign(c, be);`\n\t\t\t\tfnLiteral += isAsync(beforeHandle)\n\t\t\t\t\t? `be = await beforeHandle[${i}](c);\\n`\n\t\t\t\t\t: `be = beforeHandle[${i}](c);\\n`\n\n\t\t\t\tendUnit()\n\n\t\t\t\tfnLiteral += `if(be !== undefined) {\\n`\n\t\t\t\tendBeforeHandle()\n\t\t\t\tconst endAfterHandle = report('afterHandle', {\n\t\t\t\t\tunit: hooks.transform.length\n\t\t\t\t})\n\t\t\t\tif (hooks.afterHandle) {\n\t\t\t\t\treport('handle', {\n\t\t\t\t\t\tname: isHandleFn\n\t\t\t\t\t\t\t? (handler as Function).name\n\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t})()\n\n\t\t\t\t\tfor (let i = 0; i < hooks.afterHandle.length; i++) {\n\t\t\t\t\t\tconst hook = hooks.afterHandle[i]\n\n\t\t\t\t\t\tconst returning = hasReturn(hook.fn.toString())\n\n\t\t\t\t\t\tconst endUnit = report('afterHandle.unit', {\n\t\t\t\t\t\t\tname: hook.fn.name\n\t\t\t\t\t\t})\n\n\t\t\t\t\t\tfnLiteral += `c.response = be\\n`\n\n\t\t\t\t\t\tif (!returning) {\n\t\t\t\t\t\t\tfnLiteral += isAsync(hook.fn)\n\t\t\t\t\t\t\t\t? `await afterHandle[${i}](c, be)\\n`\n\t\t\t\t\t\t\t\t: `afterHandle[${i}](c, be)\\n`\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfnLiteral += isAsync(hook.fn)\n\t\t\t\t\t\t\t\t? `af = await afterHandle[${i}](c)\\n`\n\t\t\t\t\t\t\t\t: `af = afterHandle[${i}](c)\\n`\n\n\t\t\t\t\t\t\tfnLiteral += `if(af !== undefined) { c.response = be = af }\\n`\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tendUnit()\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tendAfterHandle()\n\n\t\t\t\tif (validator.response)\n\t\t\t\t\tfnLiteral += composeResponseValidation('be')\n\n\t\t\t\tif (hooks.mapResponse.length) {\n\t\t\t\t\tfnLiteral += `c.response = be`\n\n\t\t\t\t\tfor (let i = 0; i < hooks.mapResponse.length; i++) {\n\t\t\t\t\t\tfnLiteral += `\\nif(mr === undefined) {\n\t\t\t\t\t\t\tmr = onMapResponse[${i}](c)\n\t\t\t\t\t\t\tif(mr instanceof Promise) mr = await mr\n\t\t\t\t\t\t\tif(mr !== undefined) c.response = mr\n\t\t\t\t\t\t}\\n`\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfnLiteral += encodeCookie\n\t\t\t\tfnLiteral += `return mapEarlyResponse(be, c.set, c.request)}\\n`\n\t\t\t}\n\t\t}\n\n\t\tendBeforeHandle()\n\t}\n\n\tif (hooks?.afterHandle.length) {\n\t\tconst endHandle = report('handle', {\n\t\t\tname: isHandleFn ? (handler as Function).name : undefined\n\t\t})\n\n\t\tif (hooks.afterHandle.length)\n\t\t\tfnLiteral += isAsyncHandler\n\t\t\t\t? `let r = c.response = await ${handle};\\n`\n\t\t\t\t: `let r = c.response = ${handle};\\n`\n\t\telse\n\t\t\tfnLiteral += isAsyncHandler\n\t\t\t\t? `let r = await ${handle};\\n`\n\t\t\t\t: `let r = ${handle};\\n`\n\n\t\tendHandle()\n\n\t\tconst endAfterHandle = report('afterHandle', {\n\t\t\tunit: hooks.afterHandle.length\n\t\t})\n\n\t\tfor (let i = 0; i < hooks.afterHandle.length; i++) {\n\t\t\tconst hook = hooks.afterHandle[i]\n\n\t\t\tconst returning = hasReturn(hook.fn.toString())\n\n\t\t\tconst endUnit = report('afterHandle.unit', {\n\t\t\t\tname: hook.fn.name\n\t\t\t})\n\n\t\t\tif (!returning) {\n\t\t\t\tfnLiteral += isAsync(hook.fn)\n\t\t\t\t\t? `await afterHandle[${i}](c)\\n`\n\t\t\t\t\t: `afterHandle[${i}](c)\\n`\n\n\t\t\t\tendUnit()\n\t\t\t} else {\n\t\t\t\tfnLiteral += isAsync(hook.fn)\n\t\t\t\t\t? `af = await afterHandle[${i}](c)\\n`\n\t\t\t\t\t: `af = afterHandle[${i}](c)\\n`\n\n\t\t\t\tendUnit()\n\n\t\t\t\tif (validator.response) {\n\t\t\t\t\tfnLiteral += `if(af !== undefined) {`\n\t\t\t\t\tendAfterHandle()\n\n\t\t\t\t\tfnLiteral += composeResponseValidation('af')\n\n\t\t\t\t\tfnLiteral += `c.response = af }`\n\t\t\t\t} else {\n\t\t\t\t\tfnLiteral += `if(af !== undefined) {`\n\t\t\t\t\tendAfterHandle()\n\n\t\t\t\t\tfnLiteral += `c.response = af}\\n`\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tendAfterHandle()\n\n\t\tfnLiteral += `r = c.response\\n`\n\n\t\tif (validator.response) fnLiteral += composeResponseValidation()\n\n\t\tfnLiteral += encodeCookie\n\n\t\tif (hooks.mapResponse.length) {\n\t\t\tfor (let i = 0; i < hooks.mapResponse.length; i++) {\n\t\t\t\tfnLiteral += `\\nmr = onMapResponse[${i}](c)\n\t\t\t\tif(mr instanceof Promise) mr = await mr\n\t\t\t\tif(mr !== undefined) c.response = mr\\n`\n\t\t\t}\n\t\t}\n\n\t\tif (hasSet) fnLiteral += `return mapResponse(r, c.set, c.request)\\n`\n\t\telse fnLiteral += `return mapCompactResponse(r, c.request)\\n`\n\t} else {\n\t\tconst endHandle = report('handle', {\n\t\t\tname: isHandleFn ? (handler as Function).name : undefined\n\t\t})\n\n\t\tif (validator.response || hooks.mapResponse.length) {\n\t\t\tfnLiteral += isAsyncHandler\n\t\t\t\t? `let r = await ${handle};\\n`\n\t\t\t\t: `let r = ${handle};\\n`\n\n\t\t\tendHandle()\n\n\t\t\tif (validator.response) fnLiteral += composeResponseValidation()\n\n\t\t\treport('afterHandle')()\n\n\t\t\tif (hooks.mapResponse.length) {\n\t\t\t\tfnLiteral += 'c.response = r'\n\t\t\t\tfor (let i = 0; i < hooks.mapResponse.length; i++) {\n\t\t\t\t\tfnLiteral += `\\nif(mr === undefined) {\n\t\t\t\t\t\tmr = onMapResponse[${i}](c)\n\t\t\t\t\t\tif(mr instanceof Promise) mr = await mr\n    \t\t\t\t\tif(mr !== undefined) r = c.response = mr\n\t\t\t\t\t}\\n`\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfnLiteral += encodeCookie\n\n\t\t\tif (handler instanceof Response) {\n\t\t\t\tfnLiteral += inference.set\n\t\t\t\t\t? `if(\n\t\t\t\t\tisNotEmpty(c.set.headers) ||\n\t\t\t\t\tc.set.status !== 200 ||\n\t\t\t\t\tc.set.redirect ||\n\t\t\t\t\tc.set.cookie\n\t\t\t\t)\n\t\t\t\t\treturn mapResponse(${handle}.clone(), c.set, c.request)\n\t\t\t\telse\n\t\t\t\t\treturn ${handle}.clone()`\n\t\t\t\t\t: `return ${handle}.clone()`\n\n\t\t\t\tfnLiteral += '\\n'\n\t\t\t} else if (hasSet)\n\t\t\t\tfnLiteral += `return mapResponse(r, c.set, c.request)\\n`\n\t\t\telse fnLiteral += `return mapCompactResponse(r, c.request)\\n`\n\t\t} else if (traceConditions.handle || hasCookie) {\n\t\t\tfnLiteral += isAsyncHandler\n\t\t\t\t? `let r = await ${handle};\\n`\n\t\t\t\t: `let r = ${handle};\\n`\n\n\t\t\tendHandle()\n\n\t\t\treport('afterHandle')()\n\n\t\t\tif (hooks.mapResponse.length) {\n\t\t\t\tfnLiteral += 'c.response = r'\n\t\t\t\tfor (let i = 0; i < hooks.mapResponse.length; i++) {\n\t\t\t\t\tfnLiteral += `\\nif(mr === undefined) {\n\t\t\t\t\t\t\tmr = onMapResponse[${i}](c)\n\t\t\t\t\t\t\tif(mr instanceof Promise) mr = await mr\n    \t\t\t\t\t\tif(mr !== undefined) r = c.response = mr\n\t\t\t\t\t\t}\\n`\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfnLiteral += encodeCookie\n\n\t\t\tif (hasSet) fnLiteral += `return mapResponse(r, c.set, c.request)\\n`\n\t\t\telse fnLiteral += `return mapCompactResponse(r, c.request)\\n`\n\t\t} else {\n\t\t\tendHandle()\n\n\t\t\tconst handled = isAsyncHandler ? `await ${handle}` : handle\n\n\t\t\treport('afterHandle')()\n\n\t\t\tif (handler instanceof Response) {\n\t\t\t\tfnLiteral += inference.set\n\t\t\t\t\t? `if(\n\t\t\t\t\tisNotEmpty(c.set.headers) ||\n\t\t\t\t\tc.set.status !== 200 ||\n\t\t\t\t\tc.set.redirect ||\n\t\t\t\t\tc.set.cookie\n\t\t\t\t)\n\t\t\t\t\treturn mapResponse(${handle}.clone(), c.set, c.request)\n\t\t\t\telse\n\t\t\t\t\treturn ${handle}.clone()`\n\t\t\t\t\t: `return ${handle}.clone()`\n\n\t\t\t\tfnLiteral += '\\n'\n\t\t\t} else if (hasSet)\n\t\t\t\tfnLiteral += `return mapResponse(${handled}, c.set, c.request)\\n`\n\t\t\telse\n\t\t\t\tfnLiteral += `return mapCompactResponse(${handled}, c.request)\\n`\n\t\t}\n\t}\n\n\tif (hasErrorHandler || handleResponse) {\n\t\tfnLiteral += `\\n} catch(error) {`\n\t\tif (!maybeAsync) fnLiteral += `return (async () => {`\n\n\t\tfnLiteral += `const set = c.set\\nif (!set.status || set.status < 300) set.status = error?.status || 500\\n`\n\n\t\tconst endError = report('error', {\n\t\t\tunit: hooks.error.length\n\t\t})\n\n\t\tif (hooks.error.length) {\n\t\t\tfnLiteral += `\n\t\t\t\tc.error = error\n\t\t\t\tc.code = error.code ?? error[ERROR_CODE] ?? \"UNKNOWN\"\n\t\t\t`\n\n\t\t\tfor (let i = 0; i < hooks.error.length; i++) {\n\t\t\t\tconst name = `er${i}`\n\t\t\t\tconst endUnit = report('error.unit', {\n\t\t\t\t\tname: hooks.error[i].fn.name\n\t\t\t\t})\n\n\t\t\t\tfnLiteral += `\\nlet ${name} = handleErrors[${i}](c)\\n`\n\n\t\t\t\tif (isAsync(hooks.error[i]))\n\t\t\t\t\tfnLiteral += `if (${name} instanceof Promise) ${name} = await ${name}\\n`\n\n\t\t\t\tendUnit()\n\n\t\t\t\tfnLiteral += `${name} = mapEarlyResponse(${name}, set, c.request)\\n`\n\t\t\t\tfnLiteral += `if (${name}) {`\n\t\t\t\tfnLiteral += `return ${name} }\\n`\n\t\t\t}\n\t\t}\n\n\t\tendError()\n\n\t\tfnLiteral += `return handleError(c, error, true)\\n\\n`\n\n\t\tif (!maybeAsync) fnLiteral += '})()'\n\n\t\tfnLiteral += '}'\n\n\t\tif (handleResponse || hasTrace) {\n\t\t\tfnLiteral += ` finally { `\n\n\t\t\tconst endResponse = report('response', {\n\t\t\t\tunit: hooks.onResponse.length\n\t\t\t})\n\n\t\t\tfnLiteral += handleResponse\n\n\t\t\tendResponse()\n\n\t\t\tfnLiteral += `}`\n\t\t}\n\t}\n\n\tfnLiteral = `const {\n\t\thandler,\n\t\thandleError,\n\t\thooks: {\n\t\t\ttransform,\n\t\t\tresolve,\n\t\t\tbeforeHandle,\n\t\t\tafterHandle,\n\t\t\tmapResponse: onMapResponse,\n\t\t\tparse,\n\t\t\terror: handleErrors,\n\t\t\tonResponse\n\t\t},\n\t\tvalidator: {\n\t\t\tbody,\n\t\t\theaders,\n\t\t\tparams,\n\t\t\tquery,\n\t\t\tresponse,\n\t\t\tcookie\n\t\t},\n\t\tutils: {\n\t\t\tmapResponse,\n\t\t\tmapCompactResponse,\n\t\t\tmapEarlyResponse,\n\t\t\tparseQuery,\n\t\t\tisNotEmpty\n\t\t},\n\t\terror: {\n\t\t\tNotFoundError,\n\t\t\tValidationError,\n\t\t\tInternalServerError,\n\t\t\tParseError\n\t\t},\n\t\tschema,\n\t\tdefinitions,\n\t\tERROR_CODE,\n\t\tgetReporter,\n\t\trequestId,\n\t\tparseCookie,\n\t\tsignCookie,\n\t\tdecodeURIComponent,\n\t\tELYSIA_RESPONSE\n\t} = hooks\n\n\t${\n\t\thooks.onResponse.length\n\t\t\t? `const ${hooks.onResponse\n\t\t\t\t\t.map((x, i) => `res${i} = onResponse[${i}]`)\n\t\t\t\t\t.join(',')}`\n\t\t\t: ''\n\t}\n\n\treturn ${maybeAsync ? 'async' : ''} function handle(c) {\n\t\t${hooks.beforeHandle.length ? 'let be' : ''}\n\t\t${hooks.afterHandle.length ? 'let af' : ''}\n\t\t${hooks.mapResponse.length ? 'let mr' : ''}\n\n\t\t${allowMeta ? 'c.schema = schema; c.defs = definitions' : ''}\n\t\t${fnLiteral}\n\t}`\n\n\t// console.log(fnLiteral)\n\n\tconst createHandler = Function('hooks', fnLiteral)\n\n\treturn createHandler({\n\t\thandler,\n\t\thooks: lifeCycleToFn(hooks),\n\t\tvalidator,\n\t\t// @ts-expect-error\n\t\thandleError: app.handleError,\n\t\tutils: {\n\t\t\tmapResponse,\n\t\t\tmapCompactResponse,\n\t\t\tmapEarlyResponse,\n\t\t\tparseQuery,\n\t\t\tisNotEmpty\n\t\t},\n\t\terror: {\n\t\t\tNotFoundError,\n\t\t\tValidationError,\n\t\t\tInternalServerError,\n\t\t\tParseError\n\t\t},\n\t\tschema: app.router.history,\n\t\t// @ts-expect-error\n\t\tdefinitions: app.definitions.type,\n\t\tERROR_CODE,\n\t\t// @ts-expect-error\n\t\tgetReporter: () => app.reporter,\n\t\trequestId,\n\t\tparseCookie,\n\t\tsignCookie,\n\t\tdecodeURIComponent,\n\t\tELYSIA_RESPONSE\n\t})\n}\n\nexport const composeGeneralHandler = (\n\tapp: Elysia<any, any, any, any, any, any, any, any>\n) => {\n\tconst inference = {\n\t\tevent: {\n\t\t\t// @ts-expect-error\n\t\t\t...app.inference.event,\n\t\t\t// @ts-expect-error\n\t\t\tqueries: [...app.inference.event.queries]\n\t\t},\n\t\t// @ts-expect-error\n\t\ttrace: { ...app.inference.trace }\n\t}\n\n\tlet decoratorsLiteral = ''\n\tlet fnLiteral = ''\n\n\t// @ts-expect-error private\n\tconst defaultHeaders = app.setHeaders\n\n\t// @ts-ignore\n\tfor (const key of Object.keys(app.singleton.decorator))\n\t\tdecoratorsLiteral += `,${key}: app.singleton.decorator.${key}`\n\n\tconst router = app.router\n\tconst hasTrace = app.event.trace.length > 0\n\n\tlet findDynamicRoute = `\n\tconst route = router.find(request.method, path) ${\n\t\trouter.http.root.ALL ? '?? router.find(\"ALL\", path)' : ''\n\t}\n\n\tif (route === null)\n\t\treturn ${\n\t\t\tapp.event.error.length\n\t\t\t\t? `app.handleError(ctx, notFound)`\n\t\t\t\t: app.event.request.length\n\t\t\t\t? `new Response(error404Message, {\n\t\t\t\t\tstatus: ctx.set.status === 200 ? 404 : ctx.set.status,\n\t\t\t\t\theaders: ctx.set.headers\n\t\t\t\t})`\n\t\t\t\t: `error404.clone()`\n\t\t}\n\n\tctx.params = route.params\\n`\n\n\tconst shouldPrecompile =\n\t\tapp.config.precompile === true ||\n\t\t(typeof app.config.precompile === 'object' &&\n\t\t\tapp.config.precompile.compose === true)\n\n\tif (!shouldPrecompile)\n\t\tfindDynamicRoute += `\n\t\t\tif(route.store.composed)\n\t\t\t\treturn route.store.composed(ctx)\n\n\t\t\tif(route.store.compose)\n\t\t\t\treturn (route.store.compose())(ctx)`\n\telse findDynamicRoute += `return route.store(ctx)`\n\n\tfindDynamicRoute += '\\n'\n\n\tlet switchMap = ``\n\tfor (const [path, { code, all }] of Object.entries(router.static.http.map))\n\t\tswitchMap += `case '${path}':\\nswitch(request.method) {\\n${code}\\n${\n\t\t\tall ?? `default: break map`\n\t\t}}\\n\\n`\n\n\tconst maybeAsync = app.event.request.some(isAsync)\n\n\tconst init = `\\n\n\tconst url = request.url\n\tconst s = url.indexOf('/', 11)\n\tconst qi = url.indexOf('?', s + 1)\n\tlet path\n\tif(qi === -1)\n\t\tpath = url.substring(s)\n\telse\n\t\tpath = url.substring(s, qi)\\n`\n\n\tfnLiteral += `const {\n\t\tapp,\n\t\tmapEarlyResponse,\n\t\tNotFoundError,\n\t\trequestId,\n\t\tgetReporter,\n\t\thandleError,\n\t\terror,\n\t\tredirect\n\t} = data\n\n\tconst store = app.singleton.store\n\tconst staticRouter = app.router.static.http\n\tconst wsRouter = app.router.ws\n\tconst router = app.router.http\n\n\tconst notFound = new NotFoundError()\n\n\t${\n\t\tapp.event.request.length\n\t\t\t? `const onRequest = app.event.request.map(x => x.fn)`\n\t\t\t: ''\n\t}\n\t${router.static.http.variables}\n\t${\n\t\tapp.event.error.length\n\t\t\t? ''\n\t\t\t: `\n\tconst error404Message = notFound.message.toString()\n\tconst error404 = new Response(error404Message, { status: 404 });\n\t`\n\t}\n\n\treturn ${maybeAsync ? 'async' : ''} function map(request) {\\n`\n\n\tif (app.event.request.length) fnLiteral += `let re`\n\n\tconst report = createReport({\n\t\thasTrace,\n\t\thasTraceSet: inference.trace.set,\n\t\tcondition: {\n\t\t\trequest: inference.trace.request\n\t\t},\n\t\taddFn: (word) => {\n\t\t\tfnLiteral += word\n\t\t}\n\t})\n\n\tif (app.event.request.length) {\n\t\tfnLiteral += `\n\t\t\t${hasTrace ? 'const id = +requestId.value++' : ''}\n\n\t\t\tconst ctx = {\n\t\t\t\trequest,\n\t\t\t\tstore,\n\t\t\t\tredirect,\n\t\t\t\tset: {\n\t\t\t\t\theaders: ${\n\t\t\t\t\t\tObject.keys(defaultHeaders ?? {}).length\n\t\t\t\t\t\t\t? 'Object.assign({}, app.setHeaders)'\n\t\t\t\t\t\t\t: '{}'\n\t\t\t\t\t},\n\t\t\t\t\tstatus: 200\n\t\t\t\t},\n\t\t\t\terror\n\t\t\t\t${hasTrace ? ',$$requestId: +id' : ''}\n\t\t\t\t${decoratorsLiteral}\n\t\t\t}\n\t\t`\n\n\t\tconst endReport = report('request', {\n\t\t\tattribute: 'ctx',\n\t\t\tunit: app.event.request.length\n\t\t})\n\n\t\tfnLiteral += `\\n try {\\n`\n\n\t\tfor (let i = 0; i < app.event.request.length; i++) {\n\t\t\tconst hook = app.event.request[i]\n\t\t\tconst withReturn = hasReturn(hook.fn.toString())\n\t\t\tconst maybeAsync = isAsync(hook)\n\n\t\t\tconst endUnit = report('request.unit', {\n\t\t\t\tname: app.event.request[i].fn.name\n\t\t\t})\n\n\t\t\tif (withReturn) {\n\t\t\t\tfnLiteral += `re = mapEarlyResponse(\n\t\t\t\t\t${maybeAsync ? 'await' : ''} onRequest[${i}](ctx),\n\t\t\t\t\tctx.set,\n\t\t\t\t\trequest\n\t\t\t\t)\\n`\n\n\t\t\t\tendUnit()\n\n\t\t\t\tfnLiteral += `if(re !== undefined) return re\\n`\n\t\t\t} else {\n\t\t\t\tfnLiteral += `${\n\t\t\t\t\tmaybeAsync ? 'await' : ''\n\t\t\t\t} onRequest[${i}](ctx)\\n`\n\t\t\t\tendUnit()\n\t\t\t}\n\t\t}\n\n\t\tfnLiteral += `} catch (error) {\n\t\t\treturn app.handleError(ctx, error)\n\t\t}`\n\n\t\tendReport()\n\n\t\tfnLiteral += init\n\t\tfnLiteral += `\\nctx.qi = qi\\n ctx.path = path\\n`\n\t} else {\n\t\tfnLiteral += init\n\t\tfnLiteral += `${hasTrace ? 'const id = +requestId.value++' : ''}\n\t\tconst ctx = {\n\t\t\trequest,\n\t\t\tstore,\n\t\t\tqi,\n\t\t\tpath,\n\t\t\tredirect,\n\t\t\tset: {\n\t\t\t\theaders: ${\n\t\t\t\t\tObject.keys(defaultHeaders ?? {}).length\n\t\t\t\t\t\t? 'Object.assign({}, app.setHeaders)'\n\t\t\t\t\t\t: '{}'\n\t\t\t\t},\n\t\t\t\tstatus: 200\n\t\t\t},\n\t\t\terror\n\t\t\t${hasTrace ? ',$$requestId: id' : ''}\n\t\t\t${decoratorsLiteral}\n\t\t}`\n\n\t\treport('request', {\n\t\t\tunit: app.event.request.length,\n\t\t\tattribute:\n\t\t\t\tinference.trace.context ||\n\t\t\t\tinference.trace.store ||\n\t\t\t\tinference.trace.set\n\t\t\t\t\t? 'ctx'\n\t\t\t\t\t: ''\n\t\t})()\n\t}\n\n\tconst wsPaths = app.router.static.ws\n\tconst wsRouter = app.router.ws\n\n\tif (Object.keys(wsPaths).length || wsRouter.history.length) {\n\t\tfnLiteral += `\n\t\t\tif(request.method === 'GET') {\n\t\t\t\tswitch(path) {`\n\n\t\tfor (const [path, index] of Object.entries(wsPaths)) {\n\t\t\tfnLiteral += `\n\t\t\t\t\tcase '${path}':\n\t\t\t\t\t\tif(request.headers.get('upgrade') === 'websocket')\n\t\t\t\t\t\t\treturn st${index}(ctx)\n\n\t\t\t\t\t\tbreak`\n\t\t}\n\n\t\tfnLiteral += `\n\t\t\t\tdefault:\n\t\t\t\t\tif(request.headers.get('upgrade') === 'websocket') {\n\t\t\t\t\t\tconst route = wsRouter.find('ws', path)\n\n\t\t\t\t\t\tif(route) {\n\t\t\t\t\t\t\tctx.params = route.params\n\n\t\t\t\t\t\t\treturn route.store(ctx)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t}\\n`\n\t}\n\n\tfnLiteral += `\n\t\tmap: switch(path) {\n\t\t\t${switchMap}\n\n\t\t\tdefault:\n\t\t\t\tbreak\n\t\t}\n\n\t\t${findDynamicRoute}\n\t}`\n\n\tconst handleError = composeErrorHandler(app) as any\n\n\t// @ts-ignore\n\tapp.handleError = handleError\n\n\treturn Function(\n\t\t'data',\n\t\tfnLiteral\n\t)({\n\t\tapp,\n\t\tmapEarlyResponse,\n\t\tNotFoundError,\n\t\t// @ts-ignore\n\t\tgetReporter: () => app.reporter,\n\t\trequestId,\n\t\thandleError,\n\t\terror,\n\t\tredirect\n\t})\n}\n\nexport const composeErrorHandler = (\n\tapp: Elysia<any, any, any, any, any, any, any, any>\n) => {\n\tlet fnLiteral = `const {\n\t\tapp: { event: { error: onErrorContainer, onResponse: resContainer } },\n\t\tmapResponse,\n\t\tERROR_CODE,\n\t\tELYSIA_RESPONSE\n\t} = inject\n\n\tconst onError = onErrorContainer.map(x => x.fn)\n\tconst res = resContainer.map(x => x.fn)\n\n\treturn ${\n\t\tapp.event.error.find(isAsync) ? 'async' : ''\n\t} function(context, error, skipGlobal) {\n\t\tlet r\n\n\t\tconst { set } = context\n\n\t\tcontext.code = error.code\n\t\tcontext.error = error\n\n\t\tif(typeof error === \"object\" && ELYSIA_RESPONSE in error) {\n\t\t\terror.status = error[ELYSIA_RESPONSE]\n\t\t\terror.message = error.response\n\t\t}\\n`\n\n\tfor (let i = 0; i < app.event.error.length; i++) {\n\t\tconst handler = app.event.error[i]\n\n\t\tconst response = `${\n\t\t\tisAsync(handler) ? 'await ' : ''\n\t\t}onError[${i}](context)`\n\n\t\tfnLiteral += '\\nif(skipGlobal !== true) {\\n'\n\n\t\tif (hasReturn(handler.fn.toString()))\n\t\t\tfnLiteral += `r = ${response}; if(r !== undefined) {\n\t\t\t\tif(r instanceof Response) return r\n\n\t\t\t\tif(r[ELYSIA_RESPONSE]) {\n\t\t\t\t\terror.status = error[ELYSIA_RESPONSE]\n\t\t\t\t\terror.message = error.response\n\t\t\t\t}\n\n\t\t\t\tif(set.status === 200) set.status = error.status\n\t\t\t\treturn mapResponse(r, set, context.request)\n\t\t\t}\\n`\n\t\telse fnLiteral += response + '\\n'\n\n\t\tfnLiteral += '\\n}\\n'\n\t}\n\n\tfnLiteral += `if(error.constructor.name === \"ValidationError\" || error.constructor.name === \"TransformDecodeError\") {\n\t\tset.status = error.status ?? 422\n\t\treturn new Response(\n\t\t\terror.message,\n\t\t\t{\n\t\t\t\theaders: Object.assign(\n\t\t\t\t\t{ 'content-type': 'application/json'},\n\t\t\t\t\tset.headers\n\t\t\t\t),\n\t\t\t\tstatus: set.status\n\t\t\t}\n\t\t)\n\t} else {\n\t\tif(error.code && typeof error.status === \"number\")\n\t\t\treturn new Response(\n\t\t\t\terror.message,\n\t\t\t\t{ headers: set.headers, status: error.status }\n\t\t\t)\n\n\t\treturn mapResponse(error, set, context.request)\n\t}\n}`\n\n\treturn Function(\n\t\t'inject',\n\t\tfnLiteral\n\t)({\n\t\tapp,\n\t\tmapResponse,\n\t\tERROR_CODE,\n\t\tELYSIA_RESPONSE\n\t})\n}\n\nexport const jitRoute = (\n\tindex: number\n) => `if(stc${index}) return stc${index}(ctx)\nif(st${index}.compose) return (stc${index} = st${index}.compose())(ctx)\n\nreturn st${index}(ctx)`\n",
  "import { type Elysia } from '.'\n\nimport { Value } from '@sinclair/typebox/value'\nimport type { TAnySchema } from '@sinclair/typebox'\n\nimport { parse as parseQuery } from 'fast-querystring'\n\n// @ts-expect-error\nimport decodeURIComponent from 'fast-decode-uri-component'\n\nimport {\n\tgetCookieValidator,\n\tlifeCycleToFn,\n\tredirect,\n\tsignCookie\n} from './utils'\nimport { ParseError, error } from './error'\n\nimport {\n\tmapEarlyResponse,\n\tmapResponse,\n\tmapCompactResponse,\n\tisNotEmpty\n} from './handler'\nimport {\n\tNotFoundError,\n\tValidationError,\n\tInternalServerError,\n\tERROR_CODE,\n\tELYSIA_RESPONSE\n} from './error'\n\nimport { Sucrose, sucrose } from './sucrose'\nimport { parseCookie, type CookieOptions } from './cookies'\n\nimport type {\n\tComposedHandler,\n\tHandler,\n\tHookContainer,\n\tLifeCycleStore,\n\tSchemaValidator,\n\tTraceEvent\n} from './types'\n\nconst headersHasToJSON = (new Headers() as Headers).toJSON\nconst requestId = { value: 0 }\n\nconst createReport = ({\n\thasTrace,\n\thasTraceSet = false,\n\taddFn,\n\tcondition = {}\n}: {\n\thasTrace: boolean | number\n\thasTraceSet?: boolean\n\taddFn(string: string): void\n\tcondition: Partial<Record<TraceEvent, boolean>>\n}) => {\n\tif (hasTrace) {\n\t\taddFn(`\\nconst reporter = getReporter()\\n`)\n\n\t\treturn (\n\t\t\tevent: TraceEvent,\n\t\t\t{\n\t\t\t\tname,\n\t\t\t\tattribute = '',\n\t\t\t\tunit = 0\n\t\t\t}: {\n\t\t\t\tname?: string\n\t\t\t\tattribute?: string\n\t\t\t\tunit?: number\n\t\t\t} = {}\n\t\t) => {\n\t\t\tconst dotIndex = event.indexOf('.')\n\t\t\tconst isGroup = dotIndex === -1\n\n\t\t\tif (\n\t\t\t\tevent !== 'request' &&\n\t\t\t\tevent !== 'response' &&\n\t\t\t\t!condition[\n\t\t\t\t\t(isGroup\n\t\t\t\t\t\t? event\n\t\t\t\t\t\t: event.slice(0, dotIndex)) as keyof typeof condition\n\t\t\t\t]\n\t\t\t)\n\t\t\t\treturn () => {\n\t\t\t\t\tif (hasTraceSet && event === 'afterHandle')\n\t\t\t\t\t\taddFn(`\\nawait traceDone\\n`)\n\t\t\t\t}\n\n\t\t\tif (isGroup) name ||= event\n\t\t\telse name ||= 'anonymous'\n\n\t\t\taddFn(\n\t\t\t\t'\\n' +\n\t\t\t\t\t`reporter.emit('event', {\n\t\t\t\t\tid,\n\t\t\t\t\tevent: '${event}',\n\t\t\t\t\ttype: 'begin',\n\t\t\t\t\tname: '${name}',\n\t\t\t\t\ttime: performance.now(),\n\t\t\t\t\t${isGroup ? `unit: ${unit},` : ''}\n\t\t\t\t\t${attribute}\n\t\t\t\t})`.replace(/(\\t| |\\n)/g, '') +\n\t\t\t\t\t'\\n'\n\t\t\t)\n\n\t\t\treturn () => {\n\t\t\t\taddFn(\n\t\t\t\t\t'\\n' +\n\t\t\t\t\t\t`reporter.emit('event', {\n\t\t\t\t\t\t\tid,\n\t\t\t\t\t\t\tevent: '${event}',\n\t\t\t\t\t\t\ttype: 'end',\n\t\t\t\t\t\t\ttime: performance.now()\n\t\t\t\t\t\t})`.replace(/(\\t| |\\n)/g, '') +\n\t\t\t\t\t\t'\\n'\n\t\t\t\t)\n\n\t\t\t\tif (hasTraceSet && event === 'afterHandle')\n\t\t\t\t\taddFn(`\\nawait traceDone\\n`)\n\t\t\t}\n\t\t}\n\t} else {\n\t\treturn () => () => {}\n\t}\n}\n\nexport const hasReturn = (fnLiteral: string) => {\n\tconst parenthesisEnd = fnLiteral.indexOf(')')\n\n\t// Is direct arrow function return eg. () => 1\n\tif (\n\t\tfnLiteral.charCodeAt(parenthesisEnd + 2) === 61 &&\n\t\tfnLiteral.charCodeAt(parenthesisEnd + 5) !== 123\n\t) {\n\t\treturn true\n\t}\n\n\treturn fnLiteral.includes('return')\n}\n\nconst composeValidationFactory = (\n\thasErrorHandler: boolean,\n\t{\n\t\tinjectResponse = '',\n\t\tnormalize = false\n\t}: {\n\t\tinjectResponse?: string\n\t\tnormalize?: boolean\n\t} = {}\n) => ({\n\tcomposeValidation: (type: string, value = `c.${type}`) =>\n\t\thasErrorHandler\n\t\t\t? `c.set.status = 422; throw new ValidationError('${type}', ${type}, ${value})`\n\t\t\t: `c.set.status = 422; return new ValidationError('${type}', ${type}, ${value}).toResponse(c.set.headers)`,\n\tcomposeResponseValidation: (name = 'r') => {\n\t\tconst returnError = hasErrorHandler\n\t\t\t? `throw new ValidationError('response', response[c.set.status], ${name})`\n\t\t\t: `return new ValidationError('response', response[c.set.status], ${name}).toResponse(c.set.headers)`\n\n\t\tlet code = '\\n' + injectResponse + '\\n'\n\n\t\tcode += `let er\n\n\t\tif(${name} && typeof ${name} === \"object\" && ELYSIA_RESPONSE in ${name})\n\t\t\ter = ${name}[ELYSIA_RESPONSE]\\n`\n\n\t\tif (normalize)\n\t\t\tcode += `\n\t\t\tif(!er && response[c.set.status]?.Clean)\n\t\t\t\t${name} = response[c.set.status]?.Clean(${name})\n\t\t\telse if(response[er]?.Clean)\n\t\t\t\t${name}.response = response[er]?.Clean(${name}.response)`\n\n\t\tcode += `\n\t\t\tif(er) {\n\t\t\t\tif(!(${name} instanceof Response) && response[er]?.Check(${name}.response) === false) {\n\t\t\t\t\tif(!(response instanceof Error)) {\n\t\t\t\t\t\tc.set.status = ${name}[ELYSIA_RESPONSE]\n\n\t\t\t\t\t\t${returnError}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if(!(${name} instanceof Response) && response[c.set.status]?.Check(${name}) === false) {\n\t\t\t\tif(!(response instanceof Error))\n\t\t\t\t\t${returnError}\n\t\t\t}\\n`\n\n\t\treturn code\n\t}\n})\n\nconst KindSymbol = Symbol.for('TypeBox.Kind')\n\nexport const hasType = (type: string, schema: TAnySchema) => {\n\tif (!schema) return\n\n\tif (KindSymbol in schema && schema[KindSymbol] === type) return true\n\n\tif (schema.type === 'object') {\n\t\tconst properties = schema.properties as Record<string, TAnySchema>\n\t\tfor (const key of Object.keys(properties)) {\n\t\t\tconst property = properties[key]\n\n\t\t\tif (property.type === 'object') {\n\t\t\t\tif (hasType(type, property)) return true\n\t\t\t} else if (property.anyOf) {\n\t\t\t\tfor (let i = 0; i < property.anyOf.length; i++)\n\t\t\t\t\tif (hasType(type, property.anyOf[i])) return true\n\t\t\t}\n\n\t\t\tif (KindSymbol in property && property[KindSymbol] === type)\n\t\t\t\treturn true\n\t\t}\n\n\t\treturn false\n\t}\n\n\treturn (\n\t\tschema.properties &&\n\t\tKindSymbol in schema.properties &&\n\t\tschema.properties[KindSymbol] === type\n\t)\n}\n\nexport const hasProperty = (expectedProperty: string, schema: TAnySchema) => {\n\tif (!schema) return\n\n\tif (schema.type === 'object') {\n\t\tconst properties = schema.properties as Record<string, TAnySchema>\n\n\t\tif (!properties) return false\n\n\t\tfor (const key of Object.keys(properties)) {\n\t\t\tconst property = properties[key]\n\n\t\t\tif (expectedProperty in property) return true\n\n\t\t\tif (property.type === 'object') {\n\t\t\t\tif (hasProperty(expectedProperty, property)) return true\n\t\t\t} else if (property.anyOf) {\n\t\t\t\tfor (let i = 0; i < property.anyOf.length; i++) {\n\t\t\t\t\tif (hasProperty(expectedProperty, property.anyOf[i]))\n\t\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false\n\t}\n\n\treturn expectedProperty in schema\n}\n\nconst TransformSymbol = Symbol.for('TypeBox.Transform')\n\nexport const hasTransform = (schema: TAnySchema) => {\n\tif (!schema) return\n\n\tif (schema.type === 'object' && schema.properties) {\n\t\tconst properties = schema.properties as Record<string, TAnySchema>\n\t\tfor (const key of Object.keys(properties)) {\n\t\t\tconst property = properties[key]\n\n\t\t\tif (property.type === 'object') {\n\t\t\t\tif (hasTransform(property)) return true\n\t\t\t} else if (property.anyOf) {\n\t\t\t\tfor (let i = 0; i < property.anyOf.length; i++)\n\t\t\t\t\tif (hasTransform(property.anyOf[i])) return true\n\t\t\t}\n\n\t\t\tconst hasTransformSymbol = TransformSymbol in property\n\t\t\tif (hasTransformSymbol) return true\n\t\t}\n\n\t\treturn false\n\t}\n\n\treturn (\n\t\tTransformSymbol in schema ||\n\t\t(schema.properties && TransformSymbol in schema.properties)\n\t)\n}\n\n/**\n * This function will return the type of unioned if all unioned type is the same.\n * It's intent to use for content-type mapping only\n *\n * ```ts\n * t.Union([\n *   t.Object({\n *     password: t.String()\n *   }),\n *   t.Object({\n *     token: t.String()\n *   })\n * ])\n * ```\n */\n// const getUnionedType = (validator: TypeCheck<any> | undefined) => {\n// \tif (!validator) return\n\n// \t// @ts-ignore\n// \tconst schema = validator?.schema\n\n// \tif (schema && 'anyOf' in schema) {\n// \t\tlet foundDifference = false\n// \t\tconst type: string = schema.anyOf[0].type\n\n// \t\tfor (const validator of schema.anyOf as { type: string }[]) {\n// \t\t\tif (validator.type !== type) {\n// \t\t\t\tfoundDifference = true\n// \t\t\t\tbreak\n// \t\t\t}\n// \t\t}\n\n// \t\tif (!foundDifference) return type\n// \t}\n\n// \t// @ts-ignore\n// \treturn validator.schema?.type\n// }\n\nconst matchFnReturn = /(?:return|=>) \\S+\\(/g\n\nexport const isAsync = (v: Function | HookContainer) => {\n\tconst fn = 'fn' in v ? v.fn : v\n\n\tif (fn.constructor.name === 'AsyncFunction') return true\n\n\tconst literal = fn.toString()\n\tif (literal.includes('=> response.clone(')) return false\n\tif (literal.includes('await')) return true\n\tif (literal.includes('async')) return true\n\n\treturn !!literal.match(matchFnReturn)\n}\n\nexport const composeHandler = ({\n\tapp,\n\tpath,\n\tmethod,\n\tlocalHook,\n\thooks,\n\tvalidator,\n\thandler,\n\tallowMeta = false,\n\tappInference: { event: eventInference, trace: traceInference }\n}: {\n\tapp: Elysia<any, any, any, any, any, any, any, any>\n\tpath: string\n\tmethod: string\n\thooks: LifeCycleStore\n\tlocalHook: LifeCycleStore\n\tvalidator: SchemaValidator\n\thandler: unknown | Handler<any, any>\n\tallowMeta?: boolean\n\tappInference: {\n\t\tevent: Sucrose.Inference\n\t\ttrace: Sucrose.TraceInference\n\t}\n}): ComposedHandler => {\n\tconst isHandleFn = typeof handler === 'function'\n\n\tif (!isHandleFn)\n\t\thandler = mapResponse(handler, {\n\t\t\t// @ts-expect-error private property\n\t\t\theaders: app.setHeaders ?? {}\n\t\t})\n\n\tconst hasErrorHandler =\n\t\t(app.config.forceErrorEncapsulation &&\n\t\t\t(isHandleFn ||\n\t\t\t\thooks.afterHandle.length > 0 ||\n\t\t\t\thooks.beforeHandle.length > 0 ||\n\t\t\t\thooks.transform.length > 0)) ||\n\t\thooks.error.length > 0 ||\n\t\tapp.event.error.length > 0 ||\n\t\ttypeof Bun === 'undefined' ||\n\t\thooks.onResponse.length > 0 ||\n\t\t!!hooks.trace.length\n\n\tconst handle = isHandleFn ? `handler(c)` : `handler`\n\tconst handleResponse = hooks.onResponse.length\n\t\t? `\\n;(async () => {${hooks.onResponse\n\t\t\t\t.map((_, i) => `await res${i}(c)`)\n\t\t\t\t.join(';')}})();\\n`\n\t\t: ''\n\n\tconst traceConditions: Record<\n\t\tExclude<TraceEvent, `${string}.unit` | 'request' | 'response' | 'exit'>,\n\t\tboolean\n\t> = traceInference\n\n\tconst hasTrace = hooks.trace.length > 0\n\tlet fnLiteral = ''\n\n\tconst inference = sucrose(\n\t\tObject.assign(localHook, {\n\t\t\thandler: handler as any\n\t\t}),\n\t\teventInference\n\t)\n\n\tconst hasQuery = inference.query || !!validator.query\n\n\tconst hasBody =\n\t\tmethod !== '$INTERNALWS' &&\n\t\tmethod !== 'GET' &&\n\t\tmethod !== 'HEAD' &&\n\t\thooks.type !== 'none' &&\n\t\t(inference.body || !!validator.body)\n\n\t// @ts-expect-error private\n\tconst defaultHeaders = app.setHeaders\n\tconst hasDefaultHeaders =\n\t\tdefaultHeaders && !!Object.keys(defaultHeaders).length\n\n\t// ? defaultHeaders doesn't imply that user will use headers in handler\n\tconst hasHeaders = inference.headers || validator.headers\n\tconst hasCookie = inference.cookie || !!validator.cookie\n\n\tconst cookieValidator = hasCookie\n\t\t? getCookieValidator({\n\t\t\t\tvalidator: validator.cookie as any,\n\t\t\t\tdefaultConfig: app.config.cookie,\n\t\t\t\tdynamic: !!app.config.aot,\n\t\t\t\t// @ts-expect-error\n\t\t\t\tconfig: validator.cookie?.config ?? {},\n\t\t\t\t// @ts-expect-error\n\t\t\t\tmodels: app.definitions.type\n\t\t  })\n\t\t: undefined\n\n\t// @ts-ignore private property\n\tconst cookieMeta = cookieValidator?.config as {\n\t\tsecrets?: string | string[]\n\t\tsign: string[] | true\n\t\tproperties: { [x: string]: Object }\n\t}\n\n\tlet encodeCookie = ''\n\n\tif (cookieMeta?.sign) {\n\t\tif (!cookieMeta.secrets)\n\t\t\tthrow new Error(\n\t\t\t\t`t.Cookie required secret which is not set in (${method}) ${path}.`\n\t\t\t)\n\n\t\tconst secret = !cookieMeta.secrets\n\t\t\t? undefined\n\t\t\t: typeof cookieMeta.secrets === 'string'\n\t\t\t? cookieMeta.secrets\n\t\t\t: cookieMeta.secrets[0]\n\n\t\tencodeCookie += `const _setCookie = c.set.cookie\n\t\tif(_setCookie) {`\n\n\t\tif (cookieMeta.sign === true) {\n\t\t\tencodeCookie += `for(const [key, cookie] of Object.entries(_setCookie)) {\n\t\t\t\tc.set.cookie[key].value = await signCookie(cookie.value, '${secret}')\n\t\t\t}`\n\t\t} else\n\t\t\tfor (const name of cookieMeta.sign) {\n\t\t\t\tencodeCookie += `if(_setCookie['${name}']?.value) { c.set.cookie['${name}'].value = await signCookie(_setCookie['${name}'].value, '${secret}') }\\n`\n\t\t\t}\n\n\t\tencodeCookie += '}\\n'\n\t}\n\n\tconst normalize = app.config.normalize\n\n\tconst { composeValidation, composeResponseValidation } =\n\t\tcomposeValidationFactory(hasErrorHandler, {\n\t\t\tnormalize\n\t\t})\n\n\tif (hasHeaders) {\n\t\t// This function is Bun specific\n\t\t// @ts-ignore\n\t\tfnLiteral += headersHasToJSON\n\t\t\t? `c.headers = c.request.headers.toJSON()\\n`\n\t\t\t: `c.headers = {}\n                for (const [key, value] of c.request.headers.entries())\n\t\t\t\t\tc.headers[key] = value\n\t\t\t\t`\n\t}\n\n\tif (hasCookie) {\n\t\tconst get = (name: keyof CookieOptions, defaultValue?: unknown) => {\n\t\t\t// @ts-ignore\n\t\t\tconst value = cookieMeta?.[name] ?? defaultValue\n\t\t\tif (!value)\n\t\t\t\treturn typeof defaultValue === 'string'\n\t\t\t\t\t? `${name}: \"${defaultValue}\",`\n\t\t\t\t\t: `${name}: ${defaultValue},`\n\n\t\t\tif (typeof value === 'string') return `${name}: '${value}',`\n\t\t\tif (value instanceof Date)\n\t\t\t\treturn `${name}: new Date(${value.getTime()}),`\n\n\t\t\treturn `${name}: ${value},`\n\t\t}\n\n\t\tconst options = cookieMeta\n\t\t\t? `{\n\t\t\tsecrets: ${\n\t\t\t\tcookieMeta.secrets !== undefined\n\t\t\t\t\t? typeof cookieMeta.secrets === 'string'\n\t\t\t\t\t\t? `'${cookieMeta.secrets}'`\n\t\t\t\t\t\t: '[' +\n\t\t\t\t\t\t  cookieMeta.secrets.reduce(\n\t\t\t\t\t\t\t\t(a, b) => a + `'${b}',`,\n\t\t\t\t\t\t\t\t''\n\t\t\t\t\t\t  ) +\n\t\t\t\t\t\t  ']'\n\t\t\t\t\t: 'undefined'\n\t\t\t},\n\t\t\tsign: ${\n\t\t\t\tcookieMeta.sign === true\n\t\t\t\t\t? true\n\t\t\t\t\t: cookieMeta.sign !== undefined\n\t\t\t\t\t? '[' +\n\t\t\t\t\t  cookieMeta.sign.reduce((a, b) => a + `'${b}',`, '') +\n\t\t\t\t\t  ']'\n\t\t\t\t\t: 'undefined'\n\t\t\t},\n\t\t\t${get('domain')}\n\t\t\t${get('expires')}\n\t\t\t${get('httpOnly')}\n\t\t\t${get('maxAge')}\n\t\t\t${get('path', '/')}\n\t\t\t${get('priority')}\n\t\t\t${get('sameSite')}\n\t\t\t${get('secure')}\n\t\t}`\n\t\t\t: 'undefined'\n\n\t\tif (hasHeaders)\n\t\t\tfnLiteral += `\\nc.cookie = await parseCookie(c.set, c.headers.cookie, ${options})\\n`\n\t\telse\n\t\t\tfnLiteral += `\\nc.cookie = await parseCookie(c.set, c.request.headers.get('cookie'), ${options})\\n`\n\t}\n\n\tif (hasQuery) {\n\t\tlet destructured = [] as string[]\n\n\t\t// @ts-ignore\n\t\tif (validator.query && validator.query.schema.type === 'object') {\n\t\t\t// @ts-ignore\n\t\t\tdestructured = Object.keys(validator.query.schema.properties)\n\t\t} else\n\t\t\tfor (const query of inference.queries)\n\t\t\t\tif (destructured.indexOf(query) === -1) destructured.push(query)\n\n\t\tif (\n\t\t\tapp.config.forceDynamicQuery === true ||\n\t\t\tinference.unknownQueries === true ||\n\t\t\t!destructured.length\n\t\t) {\n\t\t\tfnLiteral += `if(c.qi !== -1) {\n\t\t\t\tc.query = parseQuery(c.request.url.slice(c.qi + 1).replace(/\\\\+/g, ' '))\n\n\t\t\t\tfor(const key of Object.keys(c.query))\n\t\t\t\t\tc.query[key] = decodeURIComponent(c.query[key])\n\t\t\t} else c.query = {}`\n\t\t} else {\n\t\t\tfnLiteral += `if(c.qi !== -1) {\n\t\t\t\tlet url = c.request.url.slice(c.qi).replace(/\\\\+/g, ' ')\n\n\t\t\t\t${destructured\n\t\t\t\t\t.map(\n\t\t\t\t\t\t(name, index) => `\n\t\t\t\t\t\t${index === 0 ? 'let' : ''} memory = url.indexOf('&${name}=')\n\t\t\t\t\t\tif(memory === -1) memory = url.indexOf('?${name}=')\n\t\t\t\t\t\tlet a${index}\n\n\t\t\t\t\t\tif(memory !== -1) {\n\t\t\t\t\t\t\tconst start = memory + ${name.length + 2}\n\t\t\t\t\t\t\tmemory = url.indexOf('&', start)\n\n\t\t\t\t\t\t\tif(memory === -1) a${index} = decodeURIComponent(url.slice(start))\n\t\t\t\t\t\t\telse a${index} = decodeURIComponent(url.slice(start, memory))\n\t\t\t\t\t\t}`\n\t\t\t\t\t)\n\t\t\t\t\t.join('\\n')}\n\n\t\t\t\tc.query = {\n\t\t\t\t\t${destructured.map((name, index) => `'${name}': a${index}`).join(', ')}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tc.query = {}\n\t\t\t}`\n\t\t}\n\t}\n\n\tconst hasTraceSet = traceInference.set\n\tconst hasSet =\n\t\tinference.cookie ||\n\t\tinference.set ||\n\t\thasTraceSet ||\n\t\thasHeaders ||\n\t\t(isHandleFn && hasDefaultHeaders)\n\n\tif (hasTrace) fnLiteral += '\\nconst id = c.$$requestId\\n'\n\n\tconst report = createReport({\n\t\thasTrace,\n\t\thasTraceSet,\n\t\tcondition: traceConditions,\n\t\taddFn: (word) => {\n\t\t\tfnLiteral += word\n\t\t}\n\t})\n\n\tfnLiteral += hasErrorHandler ? '\\n try {\\n' : ''\n\n\tif (hasTraceSet) {\n\t\tfnLiteral += `\\nconst traceDone = Promise.all([`\n\t\tfor (let i = 0; i < hooks.trace.length; i++) {\n\t\t\tfnLiteral += `new Promise(r => { reporter.once(\\`res\\${id}.${i}\\`, r) }),`\n\t\t}\n\t\tfnLiteral += `])\\n`\n\t}\n\n\tconst isAsyncHandler = typeof handler === 'function' && isAsync(handler)\n\n\tconst maybeAsync =\n\t\thasCookie ||\n\t\thasBody ||\n\t\thasTraceSet ||\n\t\tisAsyncHandler ||\n\t\t!!hooks.mapResponse.length ||\n\t\thooks.parse.length > 0 ||\n\t\thooks.afterHandle.some(isAsync) ||\n\t\thooks.beforeHandle.some(isAsync) ||\n\t\thooks.transform.some(isAsync)\n\n\tconst endParse = report('parse', {\n\t\tunit: hooks.parse.length\n\t})\n\n\tif (hasBody) {\n\t\tconst hasBodyInference =\n\t\t\thooks.parse.length || inference.body || validator.body\n\n\t\tif (hooks.type && !hooks.parse.length) {\n\t\t\tswitch (hooks.type) {\n\t\t\t\tcase 'json':\n\t\t\t\tcase 'application/json':\n\t\t\t\t\tif (hasErrorHandler)\n\t\t\t\t\t\tfnLiteral += `const tempBody = await c.request.text()\n\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tc.body = JSON.parse(tempBody)\n\t\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\t\tthrow new ParseError('Failed to parse body as found: ' + (typeof body === \"string\" ? \"'\" + body + \"'\" : body), body)\n\t\t\t\t\t\t\t}`\n\t\t\t\t\telse fnLiteral += `c.body = await c.request.json()`\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'text':\n\t\t\t\tcase 'text/plain':\n\t\t\t\t\tfnLiteral += `c.body = await c.request.text()\\n`\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'urlencoded':\n\t\t\t\tcase 'application/x-www-form-urlencoded':\n\t\t\t\t\tfnLiteral += `c.body = parseQuery(await c.request.text())\\n`\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'arrayBuffer':\n\t\t\t\tcase 'application/octet-stream':\n\t\t\t\t\tfnLiteral += `c.body = await c.request.arrayBuffer()\\n`\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'formdata':\n\t\t\t\tcase 'multipart/form-data':\n\t\t\t\t\tfnLiteral += `c.body = {}\n\n\t\t\t\t\t\tconst form = await c.request.formData()\n\t\t\t\t\t\tfor (const key of form.keys()) {\n\t\t\t\t\t\t\tif (c.body[key])\n\t\t\t\t\t\t\t\tcontinue\n\n\t\t\t\t\t\t\tconst value = form.getAll(key)\n\t\t\t\t\t\t\tif (value.length === 1)\n\t\t\t\t\t\t\t\tc.body[key] = value[0]\n\t\t\t\t\t\t\telse c.body[key] = value\n\t\t\t\t\t\t}\\n`\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t} else if (hasBodyInference) {\n\t\t\tfnLiteral += '\\n'\n\t\t\tfnLiteral += hasHeaders\n\t\t\t\t? `let contentType = c.headers['content-type']`\n\t\t\t\t: `let contentType = c.request.headers.get('content-type')`\n\n\t\t\tfnLiteral += `\n\t\t\t\tif (contentType) {\n\t\t\t\t\tconst index = contentType.indexOf(';')\n\t\t\t\t\tif (index !== -1) contentType = contentType.substring(0, index)\\n\n\t\t\t\t\tc.contentType = contentType\\n`\n\n\t\t\tif (hooks.parse.length) {\n\t\t\t\tfnLiteral += `let used = false\\n`\n\n\t\t\t\tconst endReport = report('parse', {\n\t\t\t\t\tunit: hooks.parse.length\n\t\t\t\t})\n\n\t\t\t\tfor (let i = 0; i < hooks.parse.length; i++) {\n\t\t\t\t\tconst endUnit = report('parse.unit', {\n\t\t\t\t\t\tname: hooks.parse[i].fn.name\n\t\t\t\t\t})\n\n\t\t\t\t\tconst name = `bo${i}`\n\n\t\t\t\t\tif (i !== 0) fnLiteral += `if(!used) {\\n`\n\n\t\t\t\t\tfnLiteral += `let ${name} = parse[${i}](c, contentType)\\n`\n\t\t\t\t\tfnLiteral += `if(${name} instanceof Promise) ${name} = await ${name}\\n`\n\t\t\t\t\tfnLiteral += `if(${name} !== undefined) { c.body = ${name}; used = true }\\n`\n\n\t\t\t\t\tendUnit()\n\n\t\t\t\t\tif (i !== 0) fnLiteral += `}`\n\t\t\t\t}\n\n\t\t\t\tendReport()\n\t\t\t}\n\n\t\t\tfnLiteral += '\\ndelete c.contentType\\n'\n\n\t\t\tif (hooks.parse.length) fnLiteral += `if (!used) {`\n\n\t\t\tif (hooks.type && !Array.isArray(hooks.type)) {\n\t\t\t\tswitch (hooks.type) {\n\t\t\t\t\tcase 'json':\n\t\t\t\t\tcase 'application/json':\n\t\t\t\t\t\tif (hasErrorHandler)\n\t\t\t\t\t\t\tfnLiteral += `const tempBody = await c.request.text()\n\t\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tc.body = JSON.parse(tempBody)\n\t\t\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\t\t\tthrow new ParseError('Failed to parse body as found: ' + (typeof body === \"string\" ? \"'\" + body + \"'\" : body), body)\n\t\t\t\t\t\t\t\t}`\n\t\t\t\t\t\telse fnLiteral += `c.body = await c.request.json()`\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'text':\n\t\t\t\t\tcase 'text/plain':\n\t\t\t\t\t\tfnLiteral += `c.body = await c.request.text()\\n`\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'urlencoded':\n\t\t\t\t\tcase 'application/x-www-form-urlencoded':\n\t\t\t\t\t\tfnLiteral += `c.body = parseQuery(await c.request.text())\\n`\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'arrayBuffer':\n\t\t\t\t\tcase 'application/octet-stream':\n\t\t\t\t\t\tfnLiteral += `c.body = await c.request.arrayBuffer()\\n`\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'formdata':\n\t\t\t\t\tcase 'multipart/form-data':\n\t\t\t\t\t\tfnLiteral += `c.body = {}\n\t\n\t\t\t\t\t\t\tconst form = await c.request.formData()\n\t\t\t\t\t\t\tfor (const key of form.keys()) {\n\t\t\t\t\t\t\t\tif (c.body[key])\n\t\t\t\t\t\t\t\t\tcontinue\n\t\n\t\t\t\t\t\t\t\tconst value = form.getAll(key)\n\t\t\t\t\t\t\t\tif (value.length === 1)\n\t\t\t\t\t\t\t\t\tc.body[key] = value[0]\n\t\t\t\t\t\t\t\telse c.body[key] = value\n\t\t\t\t\t\t\t}\\n`\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfnLiteral += `\n\t\t\t\t\tswitch (contentType) {\n\t\t\t\t\t\tcase 'application/json':\n\t\t\t\t\t\t\t${\n\t\t\t\t\t\t\t\thasErrorHandler\n\t\t\t\t\t\t\t\t\t? `\n\t\t\t\t\t\t\tconst tempBody = await c.request.text()\n\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tc.body = JSON.parse(tempBody)\n\t\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\t\tthrow new ParseError('Failed to parse body as found: ' + (typeof body === \"string\" ? \"'\" + body + \"'\" : body), body)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t`\n\t\t\t\t\t\t\t\t\t: `c.body = await c.request.json()\\n`\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'text/plain':\n\t\t\t\t\t\t\tc.body = await c.request.text()\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'application/x-www-form-urlencoded':\n\t\t\t\t\t\t\tc.body = parseQuery(await c.request.text())\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'application/octet-stream':\n\t\t\t\t\t\t\tc.body = await c.request.arrayBuffer();\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'multipart/form-data':\n\t\t\t\t\t\t\tc.body = {}\n\n\t\t\t\t\t\t\tconst form = await c.request.formData()\n\t\t\t\t\t\t\tfor (const key of form.keys()) {\n\t\t\t\t\t\t\t\tif (c.body[key])\n\t\t\t\t\t\t\t\t\tcontinue\n\n\t\t\t\t\t\t\t\tconst value = form.getAll(key)\n\t\t\t\t\t\t\t\tif (value.length === 1)\n\t\t\t\t\t\t\t\t\tc.body[key] = value[0]\n\t\t\t\t\t\t\t\telse c.body[key] = value\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t}`\n\t\t\t}\n\n\t\t\tif (hooks.parse.length) fnLiteral += `}`\n\n\t\t\tfnLiteral += '}\\n'\n\t\t}\n\n\t\tfnLiteral += '\\n'\n\t}\n\n\tendParse()\n\n\tif (hooks?.transform) {\n\t\tconst endTransform = report('transform', {\n\t\t\tunit: hooks.transform.length\n\t\t})\n\n\t\tif (hooks.transform.length) fnLiteral += '\\nlet transformed\\n'\n\n\t\tfor (let i = 0; i < hooks.transform.length; i++) {\n\t\t\tconst transform = hooks.transform[i]\n\n\t\t\tconst endUnit = report('transform.unit', {\n\t\t\t\tname: transform.fn.name\n\t\t\t})\n\n\t\t\tfnLiteral += isAsync(transform)\n\t\t\t\t? `transformed = await transform[${i}](c)\\n`\n\t\t\t\t: `transformed = transform[${i}](c)\\n`\n\n\t\t\tfnLiteral += `if(transformed?.[ELYSIA_RESPONSE])\n\t\t\t\tthrow transformed\n\t\t\telse\n\t\t\t\tObject.assign(c, transformed)\\n`\n\n\t\t\tendUnit()\n\t\t}\n\n\t\tendTransform()\n\t}\n\n\tif (validator) {\n\t\tfnLiteral += '\\n'\n\n\t\tif (validator.headers) {\n\t\t\t// @ts-ignore\n\t\t\tif (hasProperty('default', validator.headers.params))\n\t\t\t\tfor (const [key, value] of Object.entries(\n\t\t\t\t\tValue.Default(\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tvalidator.headers.schema,\n\t\t\t\t\t\t{}\n\t\t\t\t\t) as Object\n\t\t\t\t)) {\n\t\t\t\t\tconst parsed =\n\t\t\t\t\t\ttypeof value === 'object'\n\t\t\t\t\t\t\t? JSON.stringify(value)\n\t\t\t\t\t\t\t: `'${value}'`\n\n\t\t\t\t\tif (parsed)\n\t\t\t\t\t\tfnLiteral += `c.headers['${key}'] ??= ${parsed}\\n`\n\t\t\t\t}\n\n\t\t\tfnLiteral += `if(headers.Check(c.headers) === false) {\n\t\t\t\t${composeValidation('headers')}\n\t\t\t}`\n\n\t\t\t// @ts-ignore\n\t\t\tif (hasTransform(validator.headers.schema))\n\t\t\t\tfnLiteral += `\\nc.headers = headers.Decode(c.headers)\\n`\n\t\t}\n\n\t\tif (validator.params) {\n\t\t\t// @ts-ignore\n\t\t\tif (hasProperty('default', validator.params.schema))\n\t\t\t\tfor (const [key, value] of Object.entries(\n\t\t\t\t\tValue.Default(\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tvalidator.params.schema,\n\t\t\t\t\t\t{}\n\t\t\t\t\t) as Object\n\t\t\t\t)) {\n\t\t\t\t\tconst parsed =\n\t\t\t\t\t\ttypeof value === 'object'\n\t\t\t\t\t\t\t? JSON.stringify(value)\n\t\t\t\t\t\t\t: `'${value}'`\n\n\t\t\t\t\tif (parsed)\n\t\t\t\t\t\tfnLiteral += `c.params['${key}'] ??= ${parsed}\\n`\n\t\t\t\t}\n\n\t\t\tfnLiteral += `if(params.Check(c.params) === false) {\n\t\t\t\t${composeValidation('params')}\n\t\t\t}`\n\n\t\t\t// @ts-ignore\n\t\t\tif (hasTransform(validator.params.schema))\n\t\t\t\tfnLiteral += `\\nc.params = params.Decode(c.params)\\n`\n\t\t}\n\n\t\tif (validator.query) {\n\t\t\tif (normalize) fnLiteral += 'c.query = query.Clean(c.query);\\n'\n\n\t\t\t// @ts-ignore\n\t\t\tif (hasProperty('default', validator.query.schema))\n\t\t\t\tfor (const [key, value] of Object.entries(\n\t\t\t\t\tValue.Default(\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tvalidator.query.schema,\n\t\t\t\t\t\t{}\n\t\t\t\t\t) as Object\n\t\t\t\t)) {\n\t\t\t\t\tconst parsed =\n\t\t\t\t\t\ttypeof value === 'object'\n\t\t\t\t\t\t\t? JSON.stringify(value)\n\t\t\t\t\t\t\t: `'${value}'`\n\n\t\t\t\t\tif (parsed) fnLiteral += `c.query['${key}'] ??= ${parsed}\\n`\n\t\t\t\t}\n\n\t\t\tfnLiteral += `if(query.Check(c.query) === false) {\n\t\t\t\t${composeValidation('query')}\n\t\t\t}`\n\n\t\t\t// @ts-ignore\n\t\t\tif (hasTransform(validator.query.schema))\n\t\t\t\t// Decode doesn't work with Object.create(null)\n\t\t\t\tfnLiteral += `\\nc.query = query.Decode(Object.assign({}, c.query))\\n`\n\t\t}\n\n\t\tif (validator.body) {\n\t\t\tif (normalize) fnLiteral += 'c.body = body.Clean(c.body);\\n'\n\t\t\t// @ts-ignore\n\t\t\tif (hasProperty('default', validator.body.schema))\n\t\t\t\tfnLiteral += `if(body.Check(c.body) === false) {\n    \t\t\t\tc.body = Object.assign(${JSON.stringify(\n\t\t\t\t\t\tValue.Default(\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\tvalidator.body.schema,\n\t\t\t\t\t\t\tnull\n\t\t\t\t\t\t) ?? {}\n\t\t\t\t\t)}, c.body)\n\n    \t\t\t\tif(body.Check(c.query) === false) {\n        \t\t\t\t${composeValidation('body')}\n     \t\t\t}\n            }`\n\t\t\telse\n\t\t\t\tfnLiteral += `if(body.Check(c.body) === false) {\n\t\t\t${composeValidation('body')}\n\t\t}`\n\n\t\t\t// @ts-ignore\n\t\t\tif (hasTransform(validator.body.schema))\n\t\t\t\tfnLiteral += `\\nc.body = body.Decode(c.body)\\n`\n\t\t}\n\n\t\t// @ts-ignore\n\t\tif (isNotEmpty(cookieValidator?.schema.properties ?? {})) {\n\t\t\tfnLiteral += `const cookieValue = {}\n    \t\t\tfor(const [key, value] of Object.entries(c.cookie))\n    \t\t\t\tcookieValue[key] = value.value\\n`\n\n\t\t\t// @ts-ignore\n\t\t\tif (hasProperty('default', cookieValidator.schema))\n\t\t\t\tfor (const [key, value] of Object.entries(\n\t\t\t\t\tValue.Default(\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tcookieValidator.schema,\n\t\t\t\t\t\t{}\n\t\t\t\t\t) as Object\n\t\t\t\t)) {\n\t\t\t\t\tfnLiteral += `cookieValue['${key}'] = ${\n\t\t\t\t\t\ttypeof value === 'object'\n\t\t\t\t\t\t\t? JSON.stringify(value)\n\t\t\t\t\t\t\t: value\n\t\t\t\t\t}\\n`\n\t\t\t\t}\n\n\t\t\tfnLiteral += `if(cookie.Check(cookieValue) === false) {\n\t\t\t\t${composeValidation('cookie', 'cookieValue')}\n\t\t\t}`\n\n\t\t\t// // @ts-ignore\n\t\t\t// if (hasTransform(validator.cookie.schema))\n\t\t\t// \tfnLiteral += `\\nc.cookie = params.Decode(c.cookie)\\n`\n\t\t}\n\t}\n\n\tif (hooks?.beforeHandle) {\n\t\tconst endBeforeHandle = report('beforeHandle', {\n\t\t\tunit: hooks.beforeHandle.length\n\t\t})\n\n\t\tlet hasResolve = false\n\n\t\tfor (let i = 0; i < hooks.beforeHandle.length; i++) {\n\t\t\tconst beforeHandle = hooks.beforeHandle[i]\n\n\t\t\tconst endUnit = report('beforeHandle.unit', {\n\t\t\t\tname: beforeHandle.fn.name\n\t\t\t})\n\n\t\t\tconst returning = hasReturn(beforeHandle.fn.toString())\n\n\t\t\tconst isResolver = beforeHandle.subType === 'resolve'\n\n\t\t\tif (isResolver) {\n\t\t\t\tif (!hasResolve) {\n\t\t\t\t\thasResolve = true\n\t\t\t\t\tfnLiteral += '\\nlet resolved\\n'\n\t\t\t\t}\n\n\t\t\t\tfnLiteral += isAsync(beforeHandle)\n\t\t\t\t\t? `resolved = await beforeHandle[${i}](c);\\n`\n\t\t\t\t\t: `resolved = beforeHandle[${i}](c);\\n`\n\n\t\t\t\tfnLiteral += `if(resolved[ELYSIA_RESPONSE])\n\t\t\t\t\t\tthrow resolved\n\t\t\t\t\telse\n\t\t\t\t\t\tObject.assign(c, resolved)\\n`\n\t\t\t} else if (!returning) {\n\t\t\t\tfnLiteral += isAsync(beforeHandle)\n\t\t\t\t\t? `await beforeHandle[${i}](c);\\n`\n\t\t\t\t\t: `beforeHandle[${i}](c);\\n`\n\n\t\t\t\tendUnit()\n\t\t\t} else {\n\t\t\t\tfnLiteral += `Object.assign(c, be);`\n\t\t\t\tfnLiteral += isAsync(beforeHandle)\n\t\t\t\t\t? `be = await beforeHandle[${i}](c);\\n`\n\t\t\t\t\t: `be = beforeHandle[${i}](c);\\n`\n\n\t\t\t\tendUnit()\n\n\t\t\t\tfnLiteral += `if(be !== undefined) {\\n`\n\t\t\t\tendBeforeHandle()\n\t\t\t\tconst endAfterHandle = report('afterHandle', {\n\t\t\t\t\tunit: hooks.transform.length\n\t\t\t\t})\n\t\t\t\tif (hooks.afterHandle) {\n\t\t\t\t\treport('handle', {\n\t\t\t\t\t\tname: isHandleFn\n\t\t\t\t\t\t\t? (handler as Function).name\n\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t})()\n\n\t\t\t\t\tfor (let i = 0; i < hooks.afterHandle.length; i++) {\n\t\t\t\t\t\tconst hook = hooks.afterHandle[i]\n\n\t\t\t\t\t\tconst returning = hasReturn(hook.fn.toString())\n\n\t\t\t\t\t\tconst endUnit = report('afterHandle.unit', {\n\t\t\t\t\t\t\tname: hook.fn.name\n\t\t\t\t\t\t})\n\n\t\t\t\t\t\tfnLiteral += `c.response = be\\n`\n\n\t\t\t\t\t\tif (!returning) {\n\t\t\t\t\t\t\tfnLiteral += isAsync(hook.fn)\n\t\t\t\t\t\t\t\t? `await afterHandle[${i}](c, be)\\n`\n\t\t\t\t\t\t\t\t: `afterHandle[${i}](c, be)\\n`\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfnLiteral += isAsync(hook.fn)\n\t\t\t\t\t\t\t\t? `af = await afterHandle[${i}](c)\\n`\n\t\t\t\t\t\t\t\t: `af = afterHandle[${i}](c)\\n`\n\n\t\t\t\t\t\t\tfnLiteral += `if(af !== undefined) { c.response = be = af }\\n`\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tendUnit()\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tendAfterHandle()\n\n\t\t\t\tif (validator.response)\n\t\t\t\t\tfnLiteral += composeResponseValidation('be')\n\n\t\t\t\tif (hooks.mapResponse.length) {\n\t\t\t\t\tfnLiteral += `c.response = be`\n\n\t\t\t\t\tfor (let i = 0; i < hooks.mapResponse.length; i++) {\n\t\t\t\t\t\tfnLiteral += `\\nif(mr === undefined) {\n\t\t\t\t\t\t\tmr = onMapResponse[${i}](c)\n\t\t\t\t\t\t\tif(mr instanceof Promise) mr = await mr\n\t\t\t\t\t\t\tif(mr !== undefined) c.response = mr\n\t\t\t\t\t\t}\\n`\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfnLiteral += encodeCookie\n\t\t\t\tfnLiteral += `return mapEarlyResponse(be, c.set, c.request)}\\n`\n\t\t\t}\n\t\t}\n\n\t\tendBeforeHandle()\n\t}\n\n\tif (hooks?.afterHandle.length) {\n\t\tconst endHandle = report('handle', {\n\t\t\tname: isHandleFn ? (handler as Function).name : undefined\n\t\t})\n\n\t\tif (hooks.afterHandle.length)\n\t\t\tfnLiteral += isAsyncHandler\n\t\t\t\t? `let r = c.response = await ${handle};\\n`\n\t\t\t\t: `let r = c.response = ${handle};\\n`\n\t\telse\n\t\t\tfnLiteral += isAsyncHandler\n\t\t\t\t? `let r = await ${handle};\\n`\n\t\t\t\t: `let r = ${handle};\\n`\n\n\t\tendHandle()\n\n\t\tconst endAfterHandle = report('afterHandle', {\n\t\t\tunit: hooks.afterHandle.length\n\t\t})\n\n\t\tfor (let i = 0; i < hooks.afterHandle.length; i++) {\n\t\t\tconst hook = hooks.afterHandle[i]\n\n\t\t\tconst returning = hasReturn(hook.fn.toString())\n\n\t\t\tconst endUnit = report('afterHandle.unit', {\n\t\t\t\tname: hook.fn.name\n\t\t\t})\n\n\t\t\tif (!returning) {\n\t\t\t\tfnLiteral += isAsync(hook.fn)\n\t\t\t\t\t? `await afterHandle[${i}](c)\\n`\n\t\t\t\t\t: `afterHandle[${i}](c)\\n`\n\n\t\t\t\tendUnit()\n\t\t\t} else {\n\t\t\t\tfnLiteral += isAsync(hook.fn)\n\t\t\t\t\t? `af = await afterHandle[${i}](c)\\n`\n\t\t\t\t\t: `af = afterHandle[${i}](c)\\n`\n\n\t\t\t\tendUnit()\n\n\t\t\t\tif (validator.response) {\n\t\t\t\t\tfnLiteral += `if(af !== undefined) {`\n\t\t\t\t\tendAfterHandle()\n\n\t\t\t\t\tfnLiteral += composeResponseValidation('af')\n\n\t\t\t\t\tfnLiteral += `c.response = af }`\n\t\t\t\t} else {\n\t\t\t\t\tfnLiteral += `if(af !== undefined) {`\n\t\t\t\t\tendAfterHandle()\n\n\t\t\t\t\tfnLiteral += `c.response = af}\\n`\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tendAfterHandle()\n\n\t\tfnLiteral += `r = c.response\\n`\n\n\t\tif (validator.response) fnLiteral += composeResponseValidation()\n\n\t\tfnLiteral += encodeCookie\n\n\t\tif (hooks.mapResponse.length) {\n\t\t\tfor (let i = 0; i < hooks.mapResponse.length; i++) {\n\t\t\t\tfnLiteral += `\\nmr = onMapResponse[${i}](c)\n\t\t\t\tif(mr instanceof Promise) mr = await mr\n\t\t\t\tif(mr !== undefined) c.response = mr\\n`\n\t\t\t}\n\t\t}\n\n\t\tif (hasSet) fnLiteral += `return mapResponse(r, c.set, c.request)\\n`\n\t\telse fnLiteral += `return mapCompactResponse(r, c.request)\\n`\n\t} else {\n\t\tconst endHandle = report('handle', {\n\t\t\tname: isHandleFn ? (handler as Function).name : undefined\n\t\t})\n\n\t\tif (validator.response || hooks.mapResponse.length) {\n\t\t\tfnLiteral += isAsyncHandler\n\t\t\t\t? `let r = await ${handle};\\n`\n\t\t\t\t: `let r = ${handle};\\n`\n\n\t\t\tendHandle()\n\n\t\t\tif (validator.response) fnLiteral += composeResponseValidation()\n\n\t\t\treport('afterHandle')()\n\n\t\t\tif (hooks.mapResponse.length) {\n\t\t\t\tfnLiteral += 'c.response = r'\n\t\t\t\tfor (let i = 0; i < hooks.mapResponse.length; i++) {\n\t\t\t\t\tfnLiteral += `\\nif(mr === undefined) {\n\t\t\t\t\t\tmr = onMapResponse[${i}](c)\n\t\t\t\t\t\tif(mr instanceof Promise) mr = await mr\n    \t\t\t\t\tif(mr !== undefined) r = c.response = mr\n\t\t\t\t\t}\\n`\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfnLiteral += encodeCookie\n\n\t\t\tif (handler instanceof Response) {\n\t\t\t\tfnLiteral += inference.set\n\t\t\t\t\t? `if(\n\t\t\t\t\tisNotEmpty(c.set.headers) ||\n\t\t\t\t\tc.set.status !== 200 ||\n\t\t\t\t\tc.set.redirect ||\n\t\t\t\t\tc.set.cookie\n\t\t\t\t)\n\t\t\t\t\treturn mapResponse(${handle}.clone(), c.set, c.request)\n\t\t\t\telse\n\t\t\t\t\treturn ${handle}.clone()`\n\t\t\t\t\t: `return ${handle}.clone()`\n\n\t\t\t\tfnLiteral += '\\n'\n\t\t\t} else if (hasSet)\n\t\t\t\tfnLiteral += `return mapResponse(r, c.set, c.request)\\n`\n\t\t\telse fnLiteral += `return mapCompactResponse(r, c.request)\\n`\n\t\t} else if (traceConditions.handle || hasCookie) {\n\t\t\tfnLiteral += isAsyncHandler\n\t\t\t\t? `let r = await ${handle};\\n`\n\t\t\t\t: `let r = ${handle};\\n`\n\n\t\t\tendHandle()\n\n\t\t\treport('afterHandle')()\n\n\t\t\tif (hooks.mapResponse.length) {\n\t\t\t\tfnLiteral += 'c.response = r'\n\t\t\t\tfor (let i = 0; i < hooks.mapResponse.length; i++) {\n\t\t\t\t\tfnLiteral += `\\nif(mr === undefined) {\n\t\t\t\t\t\t\tmr = onMapResponse[${i}](c)\n\t\t\t\t\t\t\tif(mr instanceof Promise) mr = await mr\n    \t\t\t\t\t\tif(mr !== undefined) r = c.response = mr\n\t\t\t\t\t\t}\\n`\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfnLiteral += encodeCookie\n\n\t\t\tif (hasSet) fnLiteral += `return mapResponse(r, c.set, c.request)\\n`\n\t\t\telse fnLiteral += `return mapCompactResponse(r, c.request)\\n`\n\t\t} else {\n\t\t\tendHandle()\n\n\t\t\tconst handled = isAsyncHandler ? `await ${handle}` : handle\n\n\t\t\treport('afterHandle')()\n\n\t\t\tif (handler instanceof Response) {\n\t\t\t\tfnLiteral += inference.set\n\t\t\t\t\t? `if(\n\t\t\t\t\tisNotEmpty(c.set.headers) ||\n\t\t\t\t\tc.set.status !== 200 ||\n\t\t\t\t\tc.set.redirect ||\n\t\t\t\t\tc.set.cookie\n\t\t\t\t)\n\t\t\t\t\treturn mapResponse(${handle}.clone(), c.set, c.request)\n\t\t\t\telse\n\t\t\t\t\treturn ${handle}.clone()`\n\t\t\t\t\t: `return ${handle}.clone()`\n\n\t\t\t\tfnLiteral += '\\n'\n\t\t\t} else if (hasSet)\n\t\t\t\tfnLiteral += `return mapResponse(${handled}, c.set, c.request)\\n`\n\t\t\telse\n\t\t\t\tfnLiteral += `return mapCompactResponse(${handled}, c.request)\\n`\n\t\t}\n\t}\n\n\tif (hasErrorHandler || handleResponse) {\n\t\tfnLiteral += `\\n} catch(error) {`\n\t\tif (!maybeAsync) fnLiteral += `return (async () => {`\n\n\t\tfnLiteral += `const set = c.set\\nif (!set.status || set.status < 300) set.status = error?.status || 500\\n`\n\n\t\tconst endError = report('error', {\n\t\t\tunit: hooks.error.length\n\t\t})\n\n\t\tif (hooks.error.length) {\n\t\t\tfnLiteral += `\n\t\t\t\tc.error = error\n\t\t\t\tc.code = error.code ?? error[ERROR_CODE] ?? \"UNKNOWN\"\n\t\t\t`\n\n\t\t\tfor (let i = 0; i < hooks.error.length; i++) {\n\t\t\t\tconst name = `er${i}`\n\t\t\t\tconst endUnit = report('error.unit', {\n\t\t\t\t\tname: hooks.error[i].fn.name\n\t\t\t\t})\n\n\t\t\t\tfnLiteral += `\\nlet ${name} = handleErrors[${i}](c)\\n`\n\n\t\t\t\tif (isAsync(hooks.error[i]))\n\t\t\t\t\tfnLiteral += `if (${name} instanceof Promise) ${name} = await ${name}\\n`\n\n\t\t\t\tendUnit()\n\n\t\t\t\tfnLiteral += `${name} = mapEarlyResponse(${name}, set, c.request)\\n`\n\t\t\t\tfnLiteral += `if (${name}) {`\n\t\t\t\tfnLiteral += `return ${name} }\\n`\n\t\t\t}\n\t\t}\n\n\t\tendError()\n\n\t\tfnLiteral += `return handleError(c, error, true)\\n\\n`\n\n\t\tif (!maybeAsync) fnLiteral += '})()'\n\n\t\tfnLiteral += '}'\n\n\t\tif (handleResponse || hasTrace) {\n\t\t\tfnLiteral += ` finally { `\n\n\t\t\tconst endResponse = report('response', {\n\t\t\t\tunit: hooks.onResponse.length\n\t\t\t})\n\n\t\t\tfnLiteral += handleResponse\n\n\t\t\tendResponse()\n\n\t\t\tfnLiteral += `}`\n\t\t}\n\t}\n\n\tfnLiteral = `const {\n\t\thandler,\n\t\thandleError,\n\t\thooks: {\n\t\t\ttransform,\n\t\t\tresolve,\n\t\t\tbeforeHandle,\n\t\t\tafterHandle,\n\t\t\tmapResponse: onMapResponse,\n\t\t\tparse,\n\t\t\terror: handleErrors,\n\t\t\tonResponse\n\t\t},\n\t\tvalidator: {\n\t\t\tbody,\n\t\t\theaders,\n\t\t\tparams,\n\t\t\tquery,\n\t\t\tresponse,\n\t\t\tcookie\n\t\t},\n\t\tutils: {\n\t\t\tmapResponse,\n\t\t\tmapCompactResponse,\n\t\t\tmapEarlyResponse,\n\t\t\tparseQuery,\n\t\t\tisNotEmpty\n\t\t},\n\t\terror: {\n\t\t\tNotFoundError,\n\t\t\tValidationError,\n\t\t\tInternalServerError,\n\t\t\tParseError\n\t\t},\n\t\tschema,\n\t\tdefinitions,\n\t\tERROR_CODE,\n\t\tgetReporter,\n\t\trequestId,\n\t\tparseCookie,\n\t\tsignCookie,\n\t\tdecodeURIComponent,\n\t\tELYSIA_RESPONSE\n\t} = hooks\n\n\t${\n\t\thooks.onResponse.length\n\t\t\t? `const ${hooks.onResponse\n\t\t\t\t\t.map((x, i) => `res${i} = onResponse[${i}]`)\n\t\t\t\t\t.join(',')}`\n\t\t\t: ''\n\t}\n\n\treturn ${maybeAsync ? 'async' : ''} function handle(c) {\n\t\t${hooks.beforeHandle.length ? 'let be' : ''}\n\t\t${hooks.afterHandle.length ? 'let af' : ''}\n\t\t${hooks.mapResponse.length ? 'let mr' : ''}\n\n\t\t${allowMeta ? 'c.schema = schema; c.defs = definitions' : ''}\n\t\t${fnLiteral}\n\t}`\n\n\t// console.log(fnLiteral)\n\n\tconst createHandler = Function('hooks', fnLiteral)\n\n\treturn createHandler({\n\t\thandler,\n\t\thooks: lifeCycleToFn(hooks),\n\t\tvalidator,\n\t\t// @ts-expect-error\n\t\thandleError: app.handleError,\n\t\tutils: {\n\t\t\tmapResponse,\n\t\t\tmapCompactResponse,\n\t\t\tmapEarlyResponse,\n\t\t\tparseQuery,\n\t\t\tisNotEmpty\n\t\t},\n\t\terror: {\n\t\t\tNotFoundError,\n\t\t\tValidationError,\n\t\t\tInternalServerError,\n\t\t\tParseError\n\t\t},\n\t\tschema: app.router.history,\n\t\t// @ts-expect-error\n\t\tdefinitions: app.definitions.type,\n\t\tERROR_CODE,\n\t\t// @ts-expect-error\n\t\tgetReporter: () => app.reporter,\n\t\trequestId,\n\t\tparseCookie,\n\t\tsignCookie,\n\t\tdecodeURIComponent,\n\t\tELYSIA_RESPONSE\n\t})\n}\n\nexport const composeGeneralHandler = (\n\tapp: Elysia<any, any, any, any, any, any, any, any>\n) => {\n\tconst inference = {\n\t\tevent: {\n\t\t\t// @ts-expect-error\n\t\t\t...app.inference.event,\n\t\t\t// @ts-expect-error\n\t\t\tqueries: [...app.inference.event.queries]\n\t\t},\n\t\t// @ts-expect-error\n\t\ttrace: { ...app.inference.trace }\n\t}\n\n\tlet decoratorsLiteral = ''\n\tlet fnLiteral = ''\n\n\t// @ts-expect-error private\n\tconst defaultHeaders = app.setHeaders\n\n\t// @ts-ignore\n\tfor (const key of Object.keys(app.singleton.decorator))\n\t\tdecoratorsLiteral += `,${key}: app.singleton.decorator.${key}`\n\n\tconst router = app.router\n\tconst hasTrace = app.event.trace.length > 0\n\n\tlet findDynamicRoute = `\n\tconst route = router.find(request.method, path) ${\n\t\trouter.http.root.ALL ? '?? router.find(\"ALL\", path)' : ''\n\t}\n\n\tif (route === null)\n\t\treturn ${\n\t\t\tapp.event.error.length\n\t\t\t\t? `app.handleError(ctx, notFound)`\n\t\t\t\t: app.event.request.length\n\t\t\t\t? `new Response(error404Message, {\n\t\t\t\t\tstatus: ctx.set.status === 200 ? 404 : ctx.set.status,\n\t\t\t\t\theaders: ctx.set.headers\n\t\t\t\t})`\n\t\t\t\t: `error404.clone()`\n\t\t}\n\n\tctx.params = route.params\\n`\n\n\tconst shouldPrecompile =\n\t\tapp.config.precompile === true ||\n\t\t(typeof app.config.precompile === 'object' &&\n\t\t\tapp.config.precompile.compose === true)\n\n\tif (!shouldPrecompile)\n\t\tfindDynamicRoute += `\n\t\t\tif(route.store.composed)\n\t\t\t\treturn route.store.composed(ctx)\n\n\t\t\tif(route.store.compose)\n\t\t\t\treturn (route.store.compose())(ctx)`\n\telse findDynamicRoute += `return route.store(ctx)`\n\n\tfindDynamicRoute += '\\n'\n\n\tlet switchMap = ``\n\tfor (const [path, { code, all }] of Object.entries(router.static.http.map))\n\t\tswitchMap += `case '${path}':\\nswitch(request.method) {\\n${code}\\n${\n\t\t\tall ?? `default: break map`\n\t\t}}\\n\\n`\n\n\tconst maybeAsync = app.event.request.some(isAsync)\n\n\tconst init = `\\n\n\tconst url = request.url\n\tconst s = url.indexOf('/', 11)\n\tconst qi = url.indexOf('?', s + 1)\n\tlet path\n\tif(qi === -1)\n\t\tpath = url.substring(s)\n\telse\n\t\tpath = url.substring(s, qi)\\n`\n\n\tfnLiteral += `const {\n\t\tapp,\n\t\tmapEarlyResponse,\n\t\tNotFoundError,\n\t\trequestId,\n\t\tgetReporter,\n\t\thandleError,\n\t\terror,\n\t\tredirect\n\t} = data\n\n\tconst store = app.singleton.store\n\tconst staticRouter = app.router.static.http\n\tconst wsRouter = app.router.ws\n\tconst router = app.router.http\n\n\tconst notFound = new NotFoundError()\n\n\t${\n\t\tapp.event.request.length\n\t\t\t? `const onRequest = app.event.request.map(x => x.fn)`\n\t\t\t: ''\n\t}\n\t${router.static.http.variables}\n\t${\n\t\tapp.event.error.length\n\t\t\t? ''\n\t\t\t: `\n\tconst error404Message = notFound.message.toString()\n\tconst error404 = new Response(error404Message, { status: 404 });\n\t`\n\t}\n\n\treturn ${maybeAsync ? 'async' : ''} function map(request) {\\n`\n\n\tif (app.event.request.length) fnLiteral += `let re`\n\n\tconst report = createReport({\n\t\thasTrace,\n\t\thasTraceSet: inference.trace.set,\n\t\tcondition: {\n\t\t\trequest: inference.trace.request\n\t\t},\n\t\taddFn: (word) => {\n\t\t\tfnLiteral += word\n\t\t}\n\t})\n\n\tif (app.event.request.length) {\n\t\tfnLiteral += `\n\t\t\t${hasTrace ? 'const id = +requestId.value++' : ''}\n\n\t\t\tconst ctx = {\n\t\t\t\trequest,\n\t\t\t\tstore,\n\t\t\t\tredirect,\n\t\t\t\tset: {\n\t\t\t\t\theaders: ${\n\t\t\t\t\t\tObject.keys(defaultHeaders ?? {}).length\n\t\t\t\t\t\t\t? 'Object.assign({}, app.setHeaders)'\n\t\t\t\t\t\t\t: '{}'\n\t\t\t\t\t},\n\t\t\t\t\tstatus: 200\n\t\t\t\t},\n\t\t\t\terror\n\t\t\t\t${hasTrace ? ',$$requestId: +id' : ''}\n\t\t\t\t${decoratorsLiteral}\n\t\t\t}\n\t\t`\n\n\t\tconst endReport = report('request', {\n\t\t\tattribute: 'ctx',\n\t\t\tunit: app.event.request.length\n\t\t})\n\n\t\tfnLiteral += `\\n try {\\n`\n\n\t\tfor (let i = 0; i < app.event.request.length; i++) {\n\t\t\tconst hook = app.event.request[i]\n\t\t\tconst withReturn = hasReturn(hook.fn.toString())\n\t\t\tconst maybeAsync = isAsync(hook)\n\n\t\t\tconst endUnit = report('request.unit', {\n\t\t\t\tname: app.event.request[i].fn.name\n\t\t\t})\n\n\t\t\tif (withReturn) {\n\t\t\t\tfnLiteral += `re = mapEarlyResponse(\n\t\t\t\t\t${maybeAsync ? 'await' : ''} onRequest[${i}](ctx),\n\t\t\t\t\tctx.set,\n\t\t\t\t\trequest\n\t\t\t\t)\\n`\n\n\t\t\t\tendUnit()\n\n\t\t\t\tfnLiteral += `if(re !== undefined) return re\\n`\n\t\t\t} else {\n\t\t\t\tfnLiteral += `${\n\t\t\t\t\tmaybeAsync ? 'await' : ''\n\t\t\t\t} onRequest[${i}](ctx)\\n`\n\t\t\t\tendUnit()\n\t\t\t}\n\t\t}\n\n\t\tfnLiteral += `} catch (error) {\n\t\t\treturn app.handleError(ctx, error)\n\t\t}`\n\n\t\tendReport()\n\n\t\tfnLiteral += init\n\t\tfnLiteral += `\\nctx.qi = qi\\n ctx.path = path\\n`\n\t} else {\n\t\tfnLiteral += init\n\t\tfnLiteral += `${hasTrace ? 'const id = +requestId.value++' : ''}\n\t\tconst ctx = {\n\t\t\trequest,\n\t\t\tstore,\n\t\t\tqi,\n\t\t\tpath,\n\t\t\tredirect,\n\t\t\tset: {\n\t\t\t\theaders: ${\n\t\t\t\t\tObject.keys(defaultHeaders ?? {}).length\n\t\t\t\t\t\t? 'Object.assign({}, app.setHeaders)'\n\t\t\t\t\t\t: '{}'\n\t\t\t\t},\n\t\t\t\tstatus: 200\n\t\t\t},\n\t\t\terror\n\t\t\t${hasTrace ? ',$$requestId: id' : ''}\n\t\t\t${decoratorsLiteral}\n\t\t}`\n\n\t\treport('request', {\n\t\t\tunit: app.event.request.length,\n\t\t\tattribute:\n\t\t\t\tinference.trace.context ||\n\t\t\t\tinference.trace.store ||\n\t\t\t\tinference.trace.set\n\t\t\t\t\t? 'ctx'\n\t\t\t\t\t: ''\n\t\t})()\n\t}\n\n\tconst wsPaths = app.router.static.ws\n\tconst wsRouter = app.router.ws\n\n\tif (Object.keys(wsPaths).length || wsRouter.history.length) {\n\t\tfnLiteral += `\n\t\t\tif(request.method === 'GET') {\n\t\t\t\tswitch(path) {`\n\n\t\tfor (const [path, index] of Object.entries(wsPaths)) {\n\t\t\tfnLiteral += `\n\t\t\t\t\tcase '${path}':\n\t\t\t\t\t\tif(request.headers.get('upgrade') === 'websocket')\n\t\t\t\t\t\t\treturn st${index}(ctx)\n\n\t\t\t\t\t\tbreak`\n\t\t}\n\n\t\tfnLiteral += `\n\t\t\t\tdefault:\n\t\t\t\t\tif(request.headers.get('upgrade') === 'websocket') {\n\t\t\t\t\t\tconst route = wsRouter.find('ws', path)\n\n\t\t\t\t\t\tif(route) {\n\t\t\t\t\t\t\tctx.params = route.params\n\n\t\t\t\t\t\t\treturn route.store(ctx)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t}\\n`\n\t}\n\n\tfnLiteral += `\n\t\tmap: switch(path) {\n\t\t\t${switchMap}\n\n\t\t\tdefault:\n\t\t\t\tbreak\n\t\t}\n\n\t\t${findDynamicRoute}\n\t}`\n\n\tconst handleError = composeErrorHandler(app) as any\n\n\t// @ts-ignore\n\tapp.handleError = handleError\n\n\treturn Function(\n\t\t'data',\n\t\tfnLiteral\n\t)({\n\t\tapp,\n\t\tmapEarlyResponse,\n\t\tNotFoundError,\n\t\t// @ts-ignore\n\t\tgetReporter: () => app.reporter,\n\t\trequestId,\n\t\thandleError,\n\t\terror,\n\t\tredirect\n\t})\n}\n\nexport const composeErrorHandler = (\n\tapp: Elysia<any, any, any, any, any, any, any, any>\n) => {\n\tlet fnLiteral = `const {\n\t\tapp: { event: { error: onErrorContainer, onResponse: resContainer } },\n\t\tmapResponse,\n\t\tERROR_CODE,\n\t\tELYSIA_RESPONSE\n\t} = inject\n\n\tconst onError = onErrorContainer.map(x => x.fn)\n\tconst res = resContainer.map(x => x.fn)\n\n\treturn ${\n\t\tapp.event.error.find(isAsync) ? 'async' : ''\n\t} function(context, error, skipGlobal) {\n\t\tlet r\n\n\t\tconst { set } = context\n\n\t\tcontext.code = error.code\n\t\tcontext.error = error\n\n\t\tif(typeof error === \"object\" && ELYSIA_RESPONSE in error) {\n\t\t\terror.status = error[ELYSIA_RESPONSE]\n\t\t\terror.message = error.response\n\t\t}\\n`\n\n\tfor (let i = 0; i < app.event.error.length; i++) {\n\t\tconst handler = app.event.error[i]\n\n\t\tconst response = `${\n\t\t\tisAsync(handler) ? 'await ' : ''\n\t\t}onError[${i}](context)`\n\n\t\tfnLiteral += '\\nif(skipGlobal !== true) {\\n'\n\n\t\tif (hasReturn(handler.fn.toString()))\n\t\t\tfnLiteral += `r = ${response}; if(r !== undefined) {\n\t\t\t\tif(r instanceof Response) return r\n\n\t\t\t\tif(r[ELYSIA_RESPONSE]) {\n\t\t\t\t\terror.status = error[ELYSIA_RESPONSE]\n\t\t\t\t\terror.message = error.response\n\t\t\t\t}\n\n\t\t\t\tif(set.status === 200) set.status = error.status\n\t\t\t\treturn mapResponse(r, set, context.request)\n\t\t\t}\\n`\n\t\telse fnLiteral += response + '\\n'\n\n\t\tfnLiteral += '\\n}\\n'\n\t}\n\n\tfnLiteral += `if(error.constructor.name === \"ValidationError\" || error.constructor.name === \"TransformDecodeError\") {\n\t\tset.status = error.status ?? 422\n\t\treturn new Response(\n\t\t\terror.message,\n\t\t\t{\n\t\t\t\theaders: Object.assign(\n\t\t\t\t\t{ 'content-type': 'application/json'},\n\t\t\t\t\tset.headers\n\t\t\t\t),\n\t\t\t\tstatus: set.status\n\t\t\t}\n\t\t)\n\t} else {\n\t\tif(error.code && typeof error.status === \"number\")\n\t\t\treturn new Response(\n\t\t\t\terror.message,\n\t\t\t\t{ headers: set.headers, status: error.status }\n\t\t\t)\n\n\t\treturn mapResponse(error, set, context.request)\n\t}\n}`\n\n\treturn Function(\n\t\t'inject',\n\t\tfnLiteral\n\t)({\n\t\tapp,\n\t\tmapResponse,\n\t\tERROR_CODE,\n\t\tELYSIA_RESPONSE\n\t})\n}\n\nexport const jitRoute = (\n\tindex: number\n) => `if(stc${index}) return stc${index}(ctx)\nif(st${index}.compose) return (stc${index} = st${index}.compose())(ctx)\n\nreturn st${index}(ctx)`\n",
  "import { type Elysia } from '.'\n\nimport { Value } from '@sinclair/typebox/value'\nimport type { TAnySchema } from '@sinclair/typebox'\n\nimport { parse as parseQuery } from 'fast-querystring'\n\n// @ts-expect-error\nimport decodeURIComponent from 'fast-decode-uri-component'\n\nimport {\n\tgetCookieValidator,\n\tlifeCycleToFn,\n\tredirect,\n\tsignCookie\n} from './utils'\nimport { ParseError, error } from './error'\n\nimport {\n\tmapEarlyResponse,\n\tmapResponse,\n\tmapCompactResponse,\n\tisNotEmpty\n} from './handler'\nimport {\n\tNotFoundError,\n\tValidationError,\n\tInternalServerError,\n\tERROR_CODE,\n\tELYSIA_RESPONSE\n} from './error'\n\nimport { Sucrose, sucrose } from './sucrose'\nimport { parseCookie, type CookieOptions } from './cookies'\n\nimport type {\n\tComposedHandler,\n\tHandler,\n\tHookContainer,\n\tLifeCycleStore,\n\tSchemaValidator,\n\tTraceEvent\n} from './types'\n\nconst headersHasToJSON = (new Headers() as Headers).toJSON\nconst requestId = { value: 0 }\n\nconst createReport = ({\n\thasTrace,\n\thasTraceSet = false,\n\taddFn,\n\tcondition = {}\n}: {\n\thasTrace: boolean | number\n\thasTraceSet?: boolean\n\taddFn(string: string): void\n\tcondition: Partial<Record<TraceEvent, boolean>>\n}) => {\n\tif (hasTrace) {\n\t\taddFn(`\\nconst reporter = getReporter()\\n`)\n\n\t\treturn (\n\t\t\tevent: TraceEvent,\n\t\t\t{\n\t\t\t\tname,\n\t\t\t\tattribute = '',\n\t\t\t\tunit = 0\n\t\t\t}: {\n\t\t\t\tname?: string\n\t\t\t\tattribute?: string\n\t\t\t\tunit?: number\n\t\t\t} = {}\n\t\t) => {\n\t\t\tconst dotIndex = event.indexOf('.')\n\t\t\tconst isGroup = dotIndex === -1\n\n\t\t\tif (\n\t\t\t\tevent !== 'request' &&\n\t\t\t\tevent !== 'response' &&\n\t\t\t\t!condition[\n\t\t\t\t\t(isGroup\n\t\t\t\t\t\t? event\n\t\t\t\t\t\t: event.slice(0, dotIndex)) as keyof typeof condition\n\t\t\t\t]\n\t\t\t)\n\t\t\t\treturn () => {\n\t\t\t\t\tif (hasTraceSet && event === 'afterHandle')\n\t\t\t\t\t\taddFn(`\\nawait traceDone\\n`)\n\t\t\t\t}\n\n\t\t\tif (isGroup) name ||= event\n\t\t\telse name ||= 'anonymous'\n\n\t\t\taddFn(\n\t\t\t\t'\\n' +\n\t\t\t\t\t`reporter.emit('event', {\n\t\t\t\t\tid,\n\t\t\t\t\tevent: '${event}',\n\t\t\t\t\ttype: 'begin',\n\t\t\t\t\tname: '${name}',\n\t\t\t\t\ttime: performance.now(),\n\t\t\t\t\t${isGroup ? `unit: ${unit},` : ''}\n\t\t\t\t\t${attribute}\n\t\t\t\t})`.replace(/(\\t| |\\n)/g, '') +\n\t\t\t\t\t'\\n'\n\t\t\t)\n\n\t\t\treturn () => {\n\t\t\t\taddFn(\n\t\t\t\t\t'\\n' +\n\t\t\t\t\t\t`reporter.emit('event', {\n\t\t\t\t\t\t\tid,\n\t\t\t\t\t\t\tevent: '${event}',\n\t\t\t\t\t\t\ttype: 'end',\n\t\t\t\t\t\t\ttime: performance.now()\n\t\t\t\t\t\t})`.replace(/(\\t| |\\n)/g, '') +\n\t\t\t\t\t\t'\\n'\n\t\t\t\t)\n\n\t\t\t\tif (hasTraceSet && event === 'afterHandle')\n\t\t\t\t\taddFn(`\\nawait traceDone\\n`)\n\t\t\t}\n\t\t}\n\t} else {\n\t\treturn () => () => {}\n\t}\n}\n\nexport const hasReturn = (fnLiteral: string) => {\n\tconst parenthesisEnd = fnLiteral.indexOf(')')\n\n\t// Is direct arrow function return eg. () => 1\n\tif (\n\t\tfnLiteral.charCodeAt(parenthesisEnd + 2) === 61 &&\n\t\tfnLiteral.charCodeAt(parenthesisEnd + 5) !== 123\n\t) {\n\t\treturn true\n\t}\n\n\treturn fnLiteral.includes('return')\n}\n\nconst composeValidationFactory = (\n\thasErrorHandler: boolean,\n\t{\n\t\tinjectResponse = '',\n\t\tnormalize = false\n\t}: {\n\t\tinjectResponse?: string\n\t\tnormalize?: boolean\n\t} = {}\n) => ({\n\tcomposeValidation: (type: string, value = `c.${type}`) =>\n\t\thasErrorHandler\n\t\t\t? `c.set.status = 422; throw new ValidationError('${type}', ${type}, ${value})`\n\t\t\t: `c.set.status = 422; return new ValidationError('${type}', ${type}, ${value}).toResponse(c.set.headers)`,\n\tcomposeResponseValidation: (name = 'r') => {\n\t\tconst returnError = hasErrorHandler\n\t\t\t? `throw new ValidationError('response', response[c.set.status], ${name})`\n\t\t\t: `return new ValidationError('response', response[c.set.status], ${name}).toResponse(c.set.headers)`\n\n\t\tlet code = '\\n' + injectResponse + '\\n'\n\n\t\tcode += `let er\n\n\t\tif(${name} && typeof ${name} === \"object\" && ELYSIA_RESPONSE in ${name})\n\t\t\ter = ${name}[ELYSIA_RESPONSE]\\n`\n\n\t\tif (normalize)\n\t\t\tcode += `\n\t\t\tif(!er && response[c.set.status]?.Clean)\n\t\t\t\t${name} = response[c.set.status]?.Clean(${name})\n\t\t\telse if(response[er]?.Clean)\n\t\t\t\t${name}.response = response[er]?.Clean(${name}.response)`\n\n\t\tcode += `\n\t\t\tif(er) {\n\t\t\t\tif(!(${name} instanceof Response) && response[er]?.Check(${name}.response) === false) {\n\t\t\t\t\tif(!(response instanceof Error)) {\n\t\t\t\t\t\tc.set.status = ${name}[ELYSIA_RESPONSE]\n\n\t\t\t\t\t\t${returnError}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if(!(${name} instanceof Response) && response[c.set.status]?.Check(${name}) === false) {\n\t\t\t\tif(!(response instanceof Error))\n\t\t\t\t\t${returnError}\n\t\t\t}\\n`\n\n\t\treturn code\n\t}\n})\n\nconst KindSymbol = Symbol.for('TypeBox.Kind')\n\nexport const hasType = (type: string, schema: TAnySchema) => {\n\tif (!schema) return\n\n\tif (KindSymbol in schema && schema[KindSymbol] === type) return true\n\n\tif (schema.type === 'object') {\n\t\tconst properties = schema.properties as Record<string, TAnySchema>\n\t\tfor (const key of Object.keys(properties)) {\n\t\t\tconst property = properties[key]\n\n\t\t\tif (property.type === 'object') {\n\t\t\t\tif (hasType(type, property)) return true\n\t\t\t} else if (property.anyOf) {\n\t\t\t\tfor (let i = 0; i < property.anyOf.length; i++)\n\t\t\t\t\tif (hasType(type, property.anyOf[i])) return true\n\t\t\t}\n\n\t\t\tif (KindSymbol in property && property[KindSymbol] === type)\n\t\t\t\treturn true\n\t\t}\n\n\t\treturn false\n\t}\n\n\treturn (\n\t\tschema.properties &&\n\t\tKindSymbol in schema.properties &&\n\t\tschema.properties[KindSymbol] === type\n\t)\n}\n\nexport const hasProperty = (expectedProperty: string, schema: TAnySchema) => {\n\tif (!schema) return\n\n\tif (schema.type === 'object') {\n\t\tconst properties = schema.properties as Record<string, TAnySchema>\n\n\t\tif (!properties) return false\n\n\t\tfor (const key of Object.keys(properties)) {\n\t\t\tconst property = properties[key]\n\n\t\t\tif (expectedProperty in property) return true\n\n\t\t\tif (property.type === 'object') {\n\t\t\t\tif (hasProperty(expectedProperty, property)) return true\n\t\t\t} else if (property.anyOf) {\n\t\t\t\tfor (let i = 0; i < property.anyOf.length; i++) {\n\t\t\t\t\tif (hasProperty(expectedProperty, property.anyOf[i]))\n\t\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false\n\t}\n\n\treturn expectedProperty in schema\n}\n\nconst TransformSymbol = Symbol.for('TypeBox.Transform')\n\nexport const hasTransform = (schema: TAnySchema) => {\n\tif (!schema) return\n\n\tif (schema.type === 'object' && schema.properties) {\n\t\tconst properties = schema.properties as Record<string, TAnySchema>\n\t\tfor (const key of Object.keys(properties)) {\n\t\t\tconst property = properties[key]\n\n\t\t\tif (property.type === 'object') {\n\t\t\t\tif (hasTransform(property)) return true\n\t\t\t} else if (property.anyOf) {\n\t\t\t\tfor (let i = 0; i < property.anyOf.length; i++)\n\t\t\t\t\tif (hasTransform(property.anyOf[i])) return true\n\t\t\t}\n\n\t\t\tconst hasTransformSymbol = TransformSymbol in property\n\t\t\tif (hasTransformSymbol) return true\n\t\t}\n\n\t\treturn false\n\t}\n\n\treturn (\n\t\tTransformSymbol in schema ||\n\t\t(schema.properties && TransformSymbol in schema.properties)\n\t)\n}\n\n/**\n * This function will return the type of unioned if all unioned type is the same.\n * It's intent to use for content-type mapping only\n *\n * ```ts\n * t.Union([\n *   t.Object({\n *     password: t.String()\n *   }),\n *   t.Object({\n *     token: t.String()\n *   })\n * ])\n * ```\n */\n// const getUnionedType = (validator: TypeCheck<any> | undefined) => {\n// \tif (!validator) return\n\n// \t// @ts-ignore\n// \tconst schema = validator?.schema\n\n// \tif (schema && 'anyOf' in schema) {\n// \t\tlet foundDifference = false\n// \t\tconst type: string = schema.anyOf[0].type\n\n// \t\tfor (const validator of schema.anyOf as { type: string }[]) {\n// \t\t\tif (validator.type !== type) {\n// \t\t\t\tfoundDifference = true\n// \t\t\t\tbreak\n// \t\t\t}\n// \t\t}\n\n// \t\tif (!foundDifference) return type\n// \t}\n\n// \t// @ts-ignore\n// \treturn validator.schema?.type\n// }\n\nconst matchFnReturn = /(?:return|=>) \\S+\\(/g\n\nexport const isAsync = (v: Function | HookContainer) => {\n\tconst fn = 'fn' in v ? v.fn : v\n\n\tif (fn.constructor.name === 'AsyncFunction') return true\n\n\tconst literal = fn.toString()\n\tif (literal.includes('=> response.clone(')) return false\n\tif (literal.includes('await')) return true\n\tif (literal.includes('async')) return true\n\n\treturn !!literal.match(matchFnReturn)\n}\n\nexport const composeHandler = ({\n\tapp,\n\tpath,\n\tmethod,\n\tlocalHook,\n\thooks,\n\tvalidator,\n\thandler,\n\tallowMeta = false,\n\tappInference: { event: eventInference, trace: traceInference }\n}: {\n\tapp: Elysia<any, any, any, any, any, any, any, any>\n\tpath: string\n\tmethod: string\n\thooks: LifeCycleStore\n\tlocalHook: LifeCycleStore\n\tvalidator: SchemaValidator\n\thandler: unknown | Handler<any, any>\n\tallowMeta?: boolean\n\tappInference: {\n\t\tevent: Sucrose.Inference\n\t\ttrace: Sucrose.TraceInference\n\t}\n}): ComposedHandler => {\n\tconst isHandleFn = typeof handler === 'function'\n\n\tif (!isHandleFn)\n\t\thandler = mapResponse(handler, {\n\t\t\t// @ts-expect-error private property\n\t\t\theaders: app.setHeaders ?? {}\n\t\t})\n\n\tconst hasErrorHandler =\n\t\t(app.config.forceErrorEncapsulation &&\n\t\t\t(isHandleFn ||\n\t\t\t\thooks.afterHandle.length > 0 ||\n\t\t\t\thooks.beforeHandle.length > 0 ||\n\t\t\t\thooks.transform.length > 0)) ||\n\t\thooks.error.length > 0 ||\n\t\tapp.event.error.length > 0 ||\n\t\ttypeof Bun === 'undefined' ||\n\t\thooks.onResponse.length > 0 ||\n\t\t!!hooks.trace.length\n\n\tconst handle = isHandleFn ? `handler(c)` : `handler`\n\tconst handleResponse = hooks.onResponse.length\n\t\t? `\\n;(async () => {${hooks.onResponse\n\t\t\t\t.map((_, i) => `await res${i}(c)`)\n\t\t\t\t.join(';')}})();\\n`\n\t\t: ''\n\n\tconst traceConditions: Record<\n\t\tExclude<TraceEvent, `${string}.unit` | 'request' | 'response' | 'exit'>,\n\t\tboolean\n\t> = traceInference\n\n\tconst hasTrace = hooks.trace.length > 0\n\tlet fnLiteral = ''\n\n\tconst inference = sucrose(\n\t\tObject.assign(localHook, {\n\t\t\thandler: handler as any\n\t\t}),\n\t\teventInference\n\t)\n\n\tconst hasQuery = inference.query || !!validator.query\n\n\tconst hasBody =\n\t\tmethod !== '$INTERNALWS' &&\n\t\tmethod !== 'GET' &&\n\t\tmethod !== 'HEAD' &&\n\t\thooks.type !== 'none' &&\n\t\t(inference.body || !!validator.body)\n\n\t// @ts-expect-error private\n\tconst defaultHeaders = app.setHeaders\n\tconst hasDefaultHeaders =\n\t\tdefaultHeaders && !!Object.keys(defaultHeaders).length\n\n\t// ? defaultHeaders doesn't imply that user will use headers in handler\n\tconst hasHeaders = inference.headers || validator.headers\n\tconst hasCookie = inference.cookie || !!validator.cookie\n\n\tconst cookieValidator = hasCookie\n\t\t? getCookieValidator({\n\t\t\t\tvalidator: validator.cookie as any,\n\t\t\t\tdefaultConfig: app.config.cookie,\n\t\t\t\tdynamic: !!app.config.aot,\n\t\t\t\t// @ts-expect-error\n\t\t\t\tconfig: validator.cookie?.config ?? {},\n\t\t\t\t// @ts-expect-error\n\t\t\t\tmodels: app.definitions.type\n\t\t  })\n\t\t: undefined\n\n\t// @ts-ignore private property\n\tconst cookieMeta = cookieValidator?.config as {\n\t\tsecrets?: string | string[]\n\t\tsign: string[] | true\n\t\tproperties: { [x: string]: Object }\n\t}\n\n\tlet encodeCookie = ''\n\n\tif (cookieMeta?.sign) {\n\t\tif (!cookieMeta.secrets)\n\t\t\tthrow new Error(\n\t\t\t\t`t.Cookie required secret which is not set in (${method}) ${path}.`\n\t\t\t)\n\n\t\tconst secret = !cookieMeta.secrets\n\t\t\t? undefined\n\t\t\t: typeof cookieMeta.secrets === 'string'\n\t\t\t? cookieMeta.secrets\n\t\t\t: cookieMeta.secrets[0]\n\n\t\tencodeCookie += `const _setCookie = c.set.cookie\n\t\tif(_setCookie) {`\n\n\t\tif (cookieMeta.sign === true) {\n\t\t\tencodeCookie += `for(const [key, cookie] of Object.entries(_setCookie)) {\n\t\t\t\tc.set.cookie[key].value = await signCookie(cookie.value, '${secret}')\n\t\t\t}`\n\t\t} else\n\t\t\tfor (const name of cookieMeta.sign) {\n\t\t\t\tencodeCookie += `if(_setCookie['${name}']?.value) { c.set.cookie['${name}'].value = await signCookie(_setCookie['${name}'].value, '${secret}') }\\n`\n\t\t\t}\n\n\t\tencodeCookie += '}\\n'\n\t}\n\n\tconst normalize = app.config.normalize\n\n\tconst { composeValidation, composeResponseValidation } =\n\t\tcomposeValidationFactory(hasErrorHandler, {\n\t\t\tnormalize\n\t\t})\n\n\tif (hasHeaders) {\n\t\t// This function is Bun specific\n\t\t// @ts-ignore\n\t\tfnLiteral += headersHasToJSON\n\t\t\t? `c.headers = c.request.headers.toJSON()\\n`\n\t\t\t: `c.headers = {}\n                for (const [key, value] of c.request.headers.entries())\n\t\t\t\t\tc.headers[key] = value\n\t\t\t\t`\n\t}\n\n\tif (hasCookie) {\n\t\tconst get = (name: keyof CookieOptions, defaultValue?: unknown) => {\n\t\t\t// @ts-ignore\n\t\t\tconst value = cookieMeta?.[name] ?? defaultValue\n\t\t\tif (!value)\n\t\t\t\treturn typeof defaultValue === 'string'\n\t\t\t\t\t? `${name}: \"${defaultValue}\",`\n\t\t\t\t\t: `${name}: ${defaultValue},`\n\n\t\t\tif (typeof value === 'string') return `${name}: '${value}',`\n\t\t\tif (value instanceof Date)\n\t\t\t\treturn `${name}: new Date(${value.getTime()}),`\n\n\t\t\treturn `${name}: ${value},`\n\t\t}\n\n\t\tconst options = cookieMeta\n\t\t\t? `{\n\t\t\tsecrets: ${\n\t\t\t\tcookieMeta.secrets !== undefined\n\t\t\t\t\t? typeof cookieMeta.secrets === 'string'\n\t\t\t\t\t\t? `'${cookieMeta.secrets}'`\n\t\t\t\t\t\t: '[' +\n\t\t\t\t\t\t  cookieMeta.secrets.reduce(\n\t\t\t\t\t\t\t\t(a, b) => a + `'${b}',`,\n\t\t\t\t\t\t\t\t''\n\t\t\t\t\t\t  ) +\n\t\t\t\t\t\t  ']'\n\t\t\t\t\t: 'undefined'\n\t\t\t},\n\t\t\tsign: ${\n\t\t\t\tcookieMeta.sign === true\n\t\t\t\t\t? true\n\t\t\t\t\t: cookieMeta.sign !== undefined\n\t\t\t\t\t? '[' +\n\t\t\t\t\t  cookieMeta.sign.reduce((a, b) => a + `'${b}',`, '') +\n\t\t\t\t\t  ']'\n\t\t\t\t\t: 'undefined'\n\t\t\t},\n\t\t\t${get('domain')}\n\t\t\t${get('expires')}\n\t\t\t${get('httpOnly')}\n\t\t\t${get('maxAge')}\n\t\t\t${get('path', '/')}\n\t\t\t${get('priority')}\n\t\t\t${get('sameSite')}\n\t\t\t${get('secure')}\n\t\t}`\n\t\t\t: 'undefined'\n\n\t\tif (hasHeaders)\n\t\t\tfnLiteral += `\\nc.cookie = await parseCookie(c.set, c.headers.cookie, ${options})\\n`\n\t\telse\n\t\t\tfnLiteral += `\\nc.cookie = await parseCookie(c.set, c.request.headers.get('cookie'), ${options})\\n`\n\t}\n\n\tif (hasQuery) {\n\t\tlet destructured = [] as string[]\n\n\t\t// @ts-ignore\n\t\tif (validator.query && validator.query.schema.type === 'object') {\n\t\t\t// @ts-ignore\n\t\t\tdestructured = Object.keys(validator.query.schema.properties)\n\t\t} else\n\t\t\tfor (const query of inference.queries)\n\t\t\t\tif (destructured.indexOf(query) === -1) destructured.push(query)\n\n\t\tif (\n\t\t\tapp.config.forceDynamicQuery === true ||\n\t\t\tinference.unknownQueries === true ||\n\t\t\t!destructured.length\n\t\t) {\n\t\t\tfnLiteral += `if(c.qi !== -1) {\n\t\t\t\tc.query = parseQuery(c.request.url.slice(c.qi + 1).replace(/\\\\+/g, ' '))\n\n\t\t\t\tfor(const key of Object.keys(c.query))\n\t\t\t\t\tc.query[key] = decodeURIComponent(c.query[key])\n\t\t\t} else c.query = {}`\n\t\t} else {\n\t\t\tfnLiteral += `if(c.qi !== -1) {\n\t\t\t\tlet url = c.request.url.slice(c.qi).replace(/\\\\+/g, ' ')\n\n\t\t\t\t${destructured\n\t\t\t\t\t.map(\n\t\t\t\t\t\t(name, index) => `\n\t\t\t\t\t\t${index === 0 ? 'let' : ''} memory = url.indexOf('&${name}=')\n\t\t\t\t\t\tif(memory === -1) memory = url.indexOf('?${name}=')\n\t\t\t\t\t\tlet a${index}\n\n\t\t\t\t\t\tif(memory !== -1) {\n\t\t\t\t\t\t\tconst start = memory + ${name.length + 2}\n\t\t\t\t\t\t\tmemory = url.indexOf('&', start)\n\n\t\t\t\t\t\t\tif(memory === -1) a${index} = decodeURIComponent(url.slice(start))\n\t\t\t\t\t\t\telse a${index} = decodeURIComponent(url.slice(start, memory))\n\t\t\t\t\t\t}`\n\t\t\t\t\t)\n\t\t\t\t\t.join('\\n')}\n\n\t\t\t\tc.query = {\n\t\t\t\t\t${destructured.map((name, index) => `'${name}': a${index}`).join(', ')}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tc.query = {}\n\t\t\t}`\n\t\t}\n\t}\n\n\tconst hasTraceSet = traceInference.set\n\tconst hasSet =\n\t\tinference.cookie ||\n\t\tinference.set ||\n\t\thasTraceSet ||\n\t\thasHeaders ||\n\t\t(isHandleFn && hasDefaultHeaders)\n\n\tif (hasTrace) fnLiteral += '\\nconst id = c.$$requestId\\n'\n\n\tconst report = createReport({\n\t\thasTrace,\n\t\thasTraceSet,\n\t\tcondition: traceConditions,\n\t\taddFn: (word) => {\n\t\t\tfnLiteral += word\n\t\t}\n\t})\n\n\tfnLiteral += hasErrorHandler ? '\\n try {\\n' : ''\n\n\tif (hasTraceSet) {\n\t\tfnLiteral += `\\nconst traceDone = Promise.all([`\n\t\tfor (let i = 0; i < hooks.trace.length; i++) {\n\t\t\tfnLiteral += `new Promise(r => { reporter.once(\\`res\\${id}.${i}\\`, r) }),`\n\t\t}\n\t\tfnLiteral += `])\\n`\n\t}\n\n\tconst isAsyncHandler = typeof handler === 'function' && isAsync(handler)\n\n\tconst maybeAsync =\n\t\thasCookie ||\n\t\thasBody ||\n\t\thasTraceSet ||\n\t\tisAsyncHandler ||\n\t\t!!hooks.mapResponse.length ||\n\t\thooks.parse.length > 0 ||\n\t\thooks.afterHandle.some(isAsync) ||\n\t\thooks.beforeHandle.some(isAsync) ||\n\t\thooks.transform.some(isAsync)\n\n\tconst endParse = report('parse', {\n\t\tunit: hooks.parse.length\n\t})\n\n\tif (hasBody) {\n\t\tconst hasBodyInference =\n\t\t\thooks.parse.length || inference.body || validator.body\n\n\t\tif (hooks.type && !hooks.parse.length) {\n\t\t\tswitch (hooks.type) {\n\t\t\t\tcase 'json':\n\t\t\t\tcase 'application/json':\n\t\t\t\t\tif (hasErrorHandler)\n\t\t\t\t\t\tfnLiteral += `const tempBody = await c.request.text()\n\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tc.body = JSON.parse(tempBody)\n\t\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\t\tthrow new ParseError('Failed to parse body as found: ' + (typeof body === \"string\" ? \"'\" + body + \"'\" : body), body)\n\t\t\t\t\t\t\t}`\n\t\t\t\t\telse fnLiteral += `c.body = await c.request.json()`\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'text':\n\t\t\t\tcase 'text/plain':\n\t\t\t\t\tfnLiteral += `c.body = await c.request.text()\\n`\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'urlencoded':\n\t\t\t\tcase 'application/x-www-form-urlencoded':\n\t\t\t\t\tfnLiteral += `c.body = parseQuery(await c.request.text())\\n`\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'arrayBuffer':\n\t\t\t\tcase 'application/octet-stream':\n\t\t\t\t\tfnLiteral += `c.body = await c.request.arrayBuffer()\\n`\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'formdata':\n\t\t\t\tcase 'multipart/form-data':\n\t\t\t\t\tfnLiteral += `c.body = {}\n\n\t\t\t\t\t\tconst form = await c.request.formData()\n\t\t\t\t\t\tfor (const key of form.keys()) {\n\t\t\t\t\t\t\tif (c.body[key])\n\t\t\t\t\t\t\t\tcontinue\n\n\t\t\t\t\t\t\tconst value = form.getAll(key)\n\t\t\t\t\t\t\tif (value.length === 1)\n\t\t\t\t\t\t\t\tc.body[key] = value[0]\n\t\t\t\t\t\t\telse c.body[key] = value\n\t\t\t\t\t\t}\\n`\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t} else if (hasBodyInference) {\n\t\t\tfnLiteral += '\\n'\n\t\t\tfnLiteral += hasHeaders\n\t\t\t\t? `let contentType = c.headers['content-type']`\n\t\t\t\t: `let contentType = c.request.headers.get('content-type')`\n\n\t\t\tfnLiteral += `\n\t\t\t\tif (contentType) {\n\t\t\t\t\tconst index = contentType.indexOf(';')\n\t\t\t\t\tif (index !== -1) contentType = contentType.substring(0, index)\\n\n\t\t\t\t\tc.contentType = contentType\\n`\n\n\t\t\tif (hooks.parse.length) {\n\t\t\t\tfnLiteral += `let used = false\\n`\n\n\t\t\t\tconst endReport = report('parse', {\n\t\t\t\t\tunit: hooks.parse.length\n\t\t\t\t})\n\n\t\t\t\tfor (let i = 0; i < hooks.parse.length; i++) {\n\t\t\t\t\tconst endUnit = report('parse.unit', {\n\t\t\t\t\t\tname: hooks.parse[i].fn.name\n\t\t\t\t\t})\n\n\t\t\t\t\tconst name = `bo${i}`\n\n\t\t\t\t\tif (i !== 0) fnLiteral += `if(!used) {\\n`\n\n\t\t\t\t\tfnLiteral += `let ${name} = parse[${i}](c, contentType)\\n`\n\t\t\t\t\tfnLiteral += `if(${name} instanceof Promise) ${name} = await ${name}\\n`\n\t\t\t\t\tfnLiteral += `if(${name} !== undefined) { c.body = ${name}; used = true }\\n`\n\n\t\t\t\t\tendUnit()\n\n\t\t\t\t\tif (i !== 0) fnLiteral += `}`\n\t\t\t\t}\n\n\t\t\t\tendReport()\n\t\t\t}\n\n\t\t\tfnLiteral += '\\ndelete c.contentType\\n'\n\n\t\t\tif (hooks.parse.length) fnLiteral += `if (!used) {`\n\n\t\t\tif (hooks.type && !Array.isArray(hooks.type)) {\n\t\t\t\tswitch (hooks.type) {\n\t\t\t\t\tcase 'json':\n\t\t\t\t\tcase 'application/json':\n\t\t\t\t\t\tif (hasErrorHandler)\n\t\t\t\t\t\t\tfnLiteral += `const tempBody = await c.request.text()\n\t\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tc.body = JSON.parse(tempBody)\n\t\t\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\t\t\tthrow new ParseError('Failed to parse body as found: ' + (typeof body === \"string\" ? \"'\" + body + \"'\" : body), body)\n\t\t\t\t\t\t\t\t}`\n\t\t\t\t\t\telse fnLiteral += `c.body = await c.request.json()`\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'text':\n\t\t\t\t\tcase 'text/plain':\n\t\t\t\t\t\tfnLiteral += `c.body = await c.request.text()\\n`\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'urlencoded':\n\t\t\t\t\tcase 'application/x-www-form-urlencoded':\n\t\t\t\t\t\tfnLiteral += `c.body = parseQuery(await c.request.text())\\n`\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'arrayBuffer':\n\t\t\t\t\tcase 'application/octet-stream':\n\t\t\t\t\t\tfnLiteral += `c.body = await c.request.arrayBuffer()\\n`\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'formdata':\n\t\t\t\t\tcase 'multipart/form-data':\n\t\t\t\t\t\tfnLiteral += `c.body = {}\n\t\n\t\t\t\t\t\t\tconst form = await c.request.formData()\n\t\t\t\t\t\t\tfor (const key of form.keys()) {\n\t\t\t\t\t\t\t\tif (c.body[key])\n\t\t\t\t\t\t\t\t\tcontinue\n\t\n\t\t\t\t\t\t\t\tconst value = form.getAll(key)\n\t\t\t\t\t\t\t\tif (value.length === 1)\n\t\t\t\t\t\t\t\t\tc.body[key] = value[0]\n\t\t\t\t\t\t\t\telse c.body[key] = value\n\t\t\t\t\t\t\t}\\n`\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfnLiteral += `\n\t\t\t\t\tswitch (contentType) {\n\t\t\t\t\t\tcase 'application/json':\n\t\t\t\t\t\t\t${\n\t\t\t\t\t\t\t\thasErrorHandler\n\t\t\t\t\t\t\t\t\t? `\n\t\t\t\t\t\t\tconst tempBody = await c.request.text()\n\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tc.body = JSON.parse(tempBody)\n\t\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\t\tthrow new ParseError('Failed to parse body as found: ' + (typeof body === \"string\" ? \"'\" + body + \"'\" : body), body)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t`\n\t\t\t\t\t\t\t\t\t: `c.body = await c.request.json()\\n`\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'text/plain':\n\t\t\t\t\t\t\tc.body = await c.request.text()\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'application/x-www-form-urlencoded':\n\t\t\t\t\t\t\tc.body = parseQuery(await c.request.text())\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'application/octet-stream':\n\t\t\t\t\t\t\tc.body = await c.request.arrayBuffer();\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'multipart/form-data':\n\t\t\t\t\t\t\tc.body = {}\n\n\t\t\t\t\t\t\tconst form = await c.request.formData()\n\t\t\t\t\t\t\tfor (const key of form.keys()) {\n\t\t\t\t\t\t\t\tif (c.body[key])\n\t\t\t\t\t\t\t\t\tcontinue\n\n\t\t\t\t\t\t\t\tconst value = form.getAll(key)\n\t\t\t\t\t\t\t\tif (value.length === 1)\n\t\t\t\t\t\t\t\t\tc.body[key] = value[0]\n\t\t\t\t\t\t\t\telse c.body[key] = value\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t}`\n\t\t\t}\n\n\t\t\tif (hooks.parse.length) fnLiteral += `}`\n\n\t\t\tfnLiteral += '}\\n'\n\t\t}\n\n\t\tfnLiteral += '\\n'\n\t}\n\n\tendParse()\n\n\tif (hooks?.transform) {\n\t\tconst endTransform = report('transform', {\n\t\t\tunit: hooks.transform.length\n\t\t})\n\n\t\tif (hooks.transform.length) fnLiteral += '\\nlet transformed\\n'\n\n\t\tfor (let i = 0; i < hooks.transform.length; i++) {\n\t\t\tconst transform = hooks.transform[i]\n\n\t\t\tconst endUnit = report('transform.unit', {\n\t\t\t\tname: transform.fn.name\n\t\t\t})\n\n\t\t\tfnLiteral += isAsync(transform)\n\t\t\t\t? `transformed = await transform[${i}](c)\\n`\n\t\t\t\t: `transformed = transform[${i}](c)\\n`\n\n\t\t\tfnLiteral += `if(transformed?.[ELYSIA_RESPONSE])\n\t\t\t\tthrow transformed\n\t\t\telse\n\t\t\t\tObject.assign(c, transformed)\\n`\n\n\t\t\tendUnit()\n\t\t}\n\n\t\tendTransform()\n\t}\n\n\tif (validator) {\n\t\tfnLiteral += '\\n'\n\n\t\tif (validator.headers) {\n\t\t\t// @ts-ignore\n\t\t\tif (hasProperty('default', validator.headers.params))\n\t\t\t\tfor (const [key, value] of Object.entries(\n\t\t\t\t\tValue.Default(\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tvalidator.headers.schema,\n\t\t\t\t\t\t{}\n\t\t\t\t\t) as Object\n\t\t\t\t)) {\n\t\t\t\t\tconst parsed =\n\t\t\t\t\t\ttypeof value === 'object'\n\t\t\t\t\t\t\t? JSON.stringify(value)\n\t\t\t\t\t\t\t: `'${value}'`\n\n\t\t\t\t\tif (parsed)\n\t\t\t\t\t\tfnLiteral += `c.headers['${key}'] ??= ${parsed}\\n`\n\t\t\t\t}\n\n\t\t\tfnLiteral += `if(headers.Check(c.headers) === false) {\n\t\t\t\t${composeValidation('headers')}\n\t\t\t}`\n\n\t\t\t// @ts-ignore\n\t\t\tif (hasTransform(validator.headers.schema))\n\t\t\t\tfnLiteral += `\\nc.headers = headers.Decode(c.headers)\\n`\n\t\t}\n\n\t\tif (validator.params) {\n\t\t\t// @ts-ignore\n\t\t\tif (hasProperty('default', validator.params.schema))\n\t\t\t\tfor (const [key, value] of Object.entries(\n\t\t\t\t\tValue.Default(\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tvalidator.params.schema,\n\t\t\t\t\t\t{}\n\t\t\t\t\t) as Object\n\t\t\t\t)) {\n\t\t\t\t\tconst parsed =\n\t\t\t\t\t\ttypeof value === 'object'\n\t\t\t\t\t\t\t? JSON.stringify(value)\n\t\t\t\t\t\t\t: `'${value}'`\n\n\t\t\t\t\tif (parsed)\n\t\t\t\t\t\tfnLiteral += `c.params['${key}'] ??= ${parsed}\\n`\n\t\t\t\t}\n\n\t\t\tfnLiteral += `if(params.Check(c.params) === false) {\n\t\t\t\t${composeValidation('params')}\n\t\t\t}`\n\n\t\t\t// @ts-ignore\n\t\t\tif (hasTransform(validator.params.schema))\n\t\t\t\tfnLiteral += `\\nc.params = params.Decode(c.params)\\n`\n\t\t}\n\n\t\tif (validator.query) {\n\t\t\tif (normalize) fnLiteral += 'c.query = query.Clean(c.query);\\n'\n\n\t\t\t// @ts-ignore\n\t\t\tif (hasProperty('default', validator.query.schema))\n\t\t\t\tfor (const [key, value] of Object.entries(\n\t\t\t\t\tValue.Default(\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tvalidator.query.schema,\n\t\t\t\t\t\t{}\n\t\t\t\t\t) as Object\n\t\t\t\t)) {\n\t\t\t\t\tconst parsed =\n\t\t\t\t\t\ttypeof value === 'object'\n\t\t\t\t\t\t\t? JSON.stringify(value)\n\t\t\t\t\t\t\t: `'${value}'`\n\n\t\t\t\t\tif (parsed) fnLiteral += `c.query['${key}'] ??= ${parsed}\\n`\n\t\t\t\t}\n\n\t\t\tfnLiteral += `if(query.Check(c.query) === false) {\n\t\t\t\t${composeValidation('query')}\n\t\t\t}`\n\n\t\t\t// @ts-ignore\n\t\t\tif (hasTransform(validator.query.schema))\n\t\t\t\t// Decode doesn't work with Object.create(null)\n\t\t\t\tfnLiteral += `\\nc.query = query.Decode(Object.assign({}, c.query))\\n`\n\t\t}\n\n\t\tif (validator.body) {\n\t\t\tif (normalize) fnLiteral += 'c.body = body.Clean(c.body);\\n'\n\t\t\t// @ts-ignore\n\t\t\tif (hasProperty('default', validator.body.schema))\n\t\t\t\tfnLiteral += `if(body.Check(c.body) === false) {\n    \t\t\t\tc.body = Object.assign(${JSON.stringify(\n\t\t\t\t\t\tValue.Default(\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\tvalidator.body.schema,\n\t\t\t\t\t\t\tnull\n\t\t\t\t\t\t) ?? {}\n\t\t\t\t\t)}, c.body)\n\n    \t\t\t\tif(body.Check(c.query) === false) {\n        \t\t\t\t${composeValidation('body')}\n     \t\t\t}\n            }`\n\t\t\telse\n\t\t\t\tfnLiteral += `if(body.Check(c.body) === false) {\n\t\t\t${composeValidation('body')}\n\t\t}`\n\n\t\t\t// @ts-ignore\n\t\t\tif (hasTransform(validator.body.schema))\n\t\t\t\tfnLiteral += `\\nc.body = body.Decode(c.body)\\n`\n\t\t}\n\n\t\t// @ts-ignore\n\t\tif (isNotEmpty(cookieValidator?.schema.properties ?? {})) {\n\t\t\tfnLiteral += `const cookieValue = {}\n    \t\t\tfor(const [key, value] of Object.entries(c.cookie))\n    \t\t\t\tcookieValue[key] = value.value\\n`\n\n\t\t\t// @ts-ignore\n\t\t\tif (hasProperty('default', cookieValidator.schema))\n\t\t\t\tfor (const [key, value] of Object.entries(\n\t\t\t\t\tValue.Default(\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tcookieValidator.schema,\n\t\t\t\t\t\t{}\n\t\t\t\t\t) as Object\n\t\t\t\t)) {\n\t\t\t\t\tfnLiteral += `cookieValue['${key}'] = ${\n\t\t\t\t\t\ttypeof value === 'object'\n\t\t\t\t\t\t\t? JSON.stringify(value)\n\t\t\t\t\t\t\t: value\n\t\t\t\t\t}\\n`\n\t\t\t\t}\n\n\t\t\tfnLiteral += `if(cookie.Check(cookieValue) === false) {\n\t\t\t\t${composeValidation('cookie', 'cookieValue')}\n\t\t\t}`\n\n\t\t\t// // @ts-ignore\n\t\t\t// if (hasTransform(validator.cookie.schema))\n\t\t\t// \tfnLiteral += `\\nc.cookie = params.Decode(c.cookie)\\n`\n\t\t}\n\t}\n\n\tif (hooks?.beforeHandle) {\n\t\tconst endBeforeHandle = report('beforeHandle', {\n\t\t\tunit: hooks.beforeHandle.length\n\t\t})\n\n\t\tlet hasResolve = false\n\n\t\tfor (let i = 0; i < hooks.beforeHandle.length; i++) {\n\t\t\tconst beforeHandle = hooks.beforeHandle[i]\n\n\t\t\tconst endUnit = report('beforeHandle.unit', {\n\t\t\t\tname: beforeHandle.fn.name\n\t\t\t})\n\n\t\t\tconst returning = hasReturn(beforeHandle.fn.toString())\n\n\t\t\tconst isResolver = beforeHandle.subType === 'resolve'\n\n\t\t\tif (isResolver) {\n\t\t\t\tif (!hasResolve) {\n\t\t\t\t\thasResolve = true\n\t\t\t\t\tfnLiteral += '\\nlet resolved\\n'\n\t\t\t\t}\n\n\t\t\t\tfnLiteral += isAsync(beforeHandle)\n\t\t\t\t\t? `resolved = await beforeHandle[${i}](c);\\n`\n\t\t\t\t\t: `resolved = beforeHandle[${i}](c);\\n`\n\n\t\t\t\tfnLiteral += `if(resolved[ELYSIA_RESPONSE])\n\t\t\t\t\t\tthrow resolved\n\t\t\t\t\telse\n\t\t\t\t\t\tObject.assign(c, resolved)\\n`\n\t\t\t} else if (!returning) {\n\t\t\t\tfnLiteral += isAsync(beforeHandle)\n\t\t\t\t\t? `await beforeHandle[${i}](c);\\n`\n\t\t\t\t\t: `beforeHandle[${i}](c);\\n`\n\n\t\t\t\tendUnit()\n\t\t\t} else {\n\t\t\t\tfnLiteral += `Object.assign(c, be);`\n\t\t\t\tfnLiteral += isAsync(beforeHandle)\n\t\t\t\t\t? `be = await beforeHandle[${i}](c);\\n`\n\t\t\t\t\t: `be = beforeHandle[${i}](c);\\n`\n\n\t\t\t\tendUnit()\n\n\t\t\t\tfnLiteral += `if(be !== undefined) {\\n`\n\t\t\t\tendBeforeHandle()\n\t\t\t\tconst endAfterHandle = report('afterHandle', {\n\t\t\t\t\tunit: hooks.transform.length\n\t\t\t\t})\n\t\t\t\tif (hooks.afterHandle) {\n\t\t\t\t\treport('handle', {\n\t\t\t\t\t\tname: isHandleFn\n\t\t\t\t\t\t\t? (handler as Function).name\n\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t})()\n\n\t\t\t\t\tfor (let i = 0; i < hooks.afterHandle.length; i++) {\n\t\t\t\t\t\tconst hook = hooks.afterHandle[i]\n\n\t\t\t\t\t\tconst returning = hasReturn(hook.fn.toString())\n\n\t\t\t\t\t\tconst endUnit = report('afterHandle.unit', {\n\t\t\t\t\t\t\tname: hook.fn.name\n\t\t\t\t\t\t})\n\n\t\t\t\t\t\tfnLiteral += `c.response = be\\n`\n\n\t\t\t\t\t\tif (!returning) {\n\t\t\t\t\t\t\tfnLiteral += isAsync(hook.fn)\n\t\t\t\t\t\t\t\t? `await afterHandle[${i}](c, be)\\n`\n\t\t\t\t\t\t\t\t: `afterHandle[${i}](c, be)\\n`\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfnLiteral += isAsync(hook.fn)\n\t\t\t\t\t\t\t\t? `af = await afterHandle[${i}](c)\\n`\n\t\t\t\t\t\t\t\t: `af = afterHandle[${i}](c)\\n`\n\n\t\t\t\t\t\t\tfnLiteral += `if(af !== undefined) { c.response = be = af }\\n`\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tendUnit()\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tendAfterHandle()\n\n\t\t\t\tif (validator.response)\n\t\t\t\t\tfnLiteral += composeResponseValidation('be')\n\n\t\t\t\tif (hooks.mapResponse.length) {\n\t\t\t\t\tfnLiteral += `c.response = be`\n\n\t\t\t\t\tfor (let i = 0; i < hooks.mapResponse.length; i++) {\n\t\t\t\t\t\tfnLiteral += `\\nif(mr === undefined) {\n\t\t\t\t\t\t\tmr = onMapResponse[${i}](c)\n\t\t\t\t\t\t\tif(mr instanceof Promise) mr = await mr\n\t\t\t\t\t\t\tif(mr !== undefined) c.response = mr\n\t\t\t\t\t\t}\\n`\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfnLiteral += encodeCookie\n\t\t\t\tfnLiteral += `return mapEarlyResponse(be, c.set, c.request)}\\n`\n\t\t\t}\n\t\t}\n\n\t\tendBeforeHandle()\n\t}\n\n\tif (hooks?.afterHandle.length) {\n\t\tconst endHandle = report('handle', {\n\t\t\tname: isHandleFn ? (handler as Function).name : undefined\n\t\t})\n\n\t\tif (hooks.afterHandle.length)\n\t\t\tfnLiteral += isAsyncHandler\n\t\t\t\t? `let r = c.response = await ${handle};\\n`\n\t\t\t\t: `let r = c.response = ${handle};\\n`\n\t\telse\n\t\t\tfnLiteral += isAsyncHandler\n\t\t\t\t? `let r = await ${handle};\\n`\n\t\t\t\t: `let r = ${handle};\\n`\n\n\t\tendHandle()\n\n\t\tconst endAfterHandle = report('afterHandle', {\n\t\t\tunit: hooks.afterHandle.length\n\t\t})\n\n\t\tfor (let i = 0; i < hooks.afterHandle.length; i++) {\n\t\t\tconst hook = hooks.afterHandle[i]\n\n\t\t\tconst returning = hasReturn(hook.fn.toString())\n\n\t\t\tconst endUnit = report('afterHandle.unit', {\n\t\t\t\tname: hook.fn.name\n\t\t\t})\n\n\t\t\tif (!returning) {\n\t\t\t\tfnLiteral += isAsync(hook.fn)\n\t\t\t\t\t? `await afterHandle[${i}](c)\\n`\n\t\t\t\t\t: `afterHandle[${i}](c)\\n`\n\n\t\t\t\tendUnit()\n\t\t\t} else {\n\t\t\t\tfnLiteral += isAsync(hook.fn)\n\t\t\t\t\t? `af = await afterHandle[${i}](c)\\n`\n\t\t\t\t\t: `af = afterHandle[${i}](c)\\n`\n\n\t\t\t\tendUnit()\n\n\t\t\t\tif (validator.response) {\n\t\t\t\t\tfnLiteral += `if(af !== undefined) {`\n\t\t\t\t\tendAfterHandle()\n\n\t\t\t\t\tfnLiteral += composeResponseValidation('af')\n\n\t\t\t\t\tfnLiteral += `c.response = af }`\n\t\t\t\t} else {\n\t\t\t\t\tfnLiteral += `if(af !== undefined) {`\n\t\t\t\t\tendAfterHandle()\n\n\t\t\t\t\tfnLiteral += `c.response = af}\\n`\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tendAfterHandle()\n\n\t\tfnLiteral += `r = c.response\\n`\n\n\t\tif (validator.response) fnLiteral += composeResponseValidation()\n\n\t\tfnLiteral += encodeCookie\n\n\t\tif (hooks.mapResponse.length) {\n\t\t\tfor (let i = 0; i < hooks.mapResponse.length; i++) {\n\t\t\t\tfnLiteral += `\\nmr = onMapResponse[${i}](c)\n\t\t\t\tif(mr instanceof Promise) mr = await mr\n\t\t\t\tif(mr !== undefined) c.response = mr\\n`\n\t\t\t}\n\t\t}\n\n\t\tif (hasSet) fnLiteral += `return mapResponse(r, c.set, c.request)\\n`\n\t\telse fnLiteral += `return mapCompactResponse(r, c.request)\\n`\n\t} else {\n\t\tconst endHandle = report('handle', {\n\t\t\tname: isHandleFn ? (handler as Function).name : undefined\n\t\t})\n\n\t\tif (validator.response || hooks.mapResponse.length) {\n\t\t\tfnLiteral += isAsyncHandler\n\t\t\t\t? `let r = await ${handle};\\n`\n\t\t\t\t: `let r = ${handle};\\n`\n\n\t\t\tendHandle()\n\n\t\t\tif (validator.response) fnLiteral += composeResponseValidation()\n\n\t\t\treport('afterHandle')()\n\n\t\t\tif (hooks.mapResponse.length) {\n\t\t\t\tfnLiteral += 'c.response = r'\n\t\t\t\tfor (let i = 0; i < hooks.mapResponse.length; i++) {\n\t\t\t\t\tfnLiteral += `\\nif(mr === undefined) {\n\t\t\t\t\t\tmr = onMapResponse[${i}](c)\n\t\t\t\t\t\tif(mr instanceof Promise) mr = await mr\n    \t\t\t\t\tif(mr !== undefined) r = c.response = mr\n\t\t\t\t\t}\\n`\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfnLiteral += encodeCookie\n\n\t\t\tif (handler instanceof Response) {\n\t\t\t\tfnLiteral += inference.set\n\t\t\t\t\t? `if(\n\t\t\t\t\tisNotEmpty(c.set.headers) ||\n\t\t\t\t\tc.set.status !== 200 ||\n\t\t\t\t\tc.set.redirect ||\n\t\t\t\t\tc.set.cookie\n\t\t\t\t)\n\t\t\t\t\treturn mapResponse(${handle}.clone(), c.set, c.request)\n\t\t\t\telse\n\t\t\t\t\treturn ${handle}.clone()`\n\t\t\t\t\t: `return ${handle}.clone()`\n\n\t\t\t\tfnLiteral += '\\n'\n\t\t\t} else if (hasSet)\n\t\t\t\tfnLiteral += `return mapResponse(r, c.set, c.request)\\n`\n\t\t\telse fnLiteral += `return mapCompactResponse(r, c.request)\\n`\n\t\t} else if (traceConditions.handle || hasCookie) {\n\t\t\tfnLiteral += isAsyncHandler\n\t\t\t\t? `let r = await ${handle};\\n`\n\t\t\t\t: `let r = ${handle};\\n`\n\n\t\t\tendHandle()\n\n\t\t\treport('afterHandle')()\n\n\t\t\tif (hooks.mapResponse.length) {\n\t\t\t\tfnLiteral += 'c.response = r'\n\t\t\t\tfor (let i = 0; i < hooks.mapResponse.length; i++) {\n\t\t\t\t\tfnLiteral += `\\nif(mr === undefined) {\n\t\t\t\t\t\t\tmr = onMapResponse[${i}](c)\n\t\t\t\t\t\t\tif(mr instanceof Promise) mr = await mr\n    \t\t\t\t\t\tif(mr !== undefined) r = c.response = mr\n\t\t\t\t\t\t}\\n`\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfnLiteral += encodeCookie\n\n\t\t\tif (hasSet) fnLiteral += `return mapResponse(r, c.set, c.request)\\n`\n\t\t\telse fnLiteral += `return mapCompactResponse(r, c.request)\\n`\n\t\t} else {\n\t\t\tendHandle()\n\n\t\t\tconst handled = isAsyncHandler ? `await ${handle}` : handle\n\n\t\t\treport('afterHandle')()\n\n\t\t\tif (handler instanceof Response) {\n\t\t\t\tfnLiteral += inference.set\n\t\t\t\t\t? `if(\n\t\t\t\t\tisNotEmpty(c.set.headers) ||\n\t\t\t\t\tc.set.status !== 200 ||\n\t\t\t\t\tc.set.redirect ||\n\t\t\t\t\tc.set.cookie\n\t\t\t\t)\n\t\t\t\t\treturn mapResponse(${handle}.clone(), c.set, c.request)\n\t\t\t\telse\n\t\t\t\t\treturn ${handle}.clone()`\n\t\t\t\t\t: `return ${handle}.clone()`\n\n\t\t\t\tfnLiteral += '\\n'\n\t\t\t} else if (hasSet)\n\t\t\t\tfnLiteral += `return mapResponse(${handled}, c.set, c.request)\\n`\n\t\t\telse\n\t\t\t\tfnLiteral += `return mapCompactResponse(${handled}, c.request)\\n`\n\t\t}\n\t}\n\n\tif (hasErrorHandler || handleResponse) {\n\t\tfnLiteral += `\\n} catch(error) {`\n\t\tif (!maybeAsync) fnLiteral += `return (async () => {`\n\n\t\tfnLiteral += `const set = c.set\\nif (!set.status || set.status < 300) set.status = error?.status || 500\\n`\n\n\t\tconst endError = report('error', {\n\t\t\tunit: hooks.error.length\n\t\t})\n\n\t\tif (hooks.error.length) {\n\t\t\tfnLiteral += `\n\t\t\t\tc.error = error\n\t\t\t\tc.code = error.code ?? error[ERROR_CODE] ?? \"UNKNOWN\"\n\t\t\t`\n\n\t\t\tfor (let i = 0; i < hooks.error.length; i++) {\n\t\t\t\tconst name = `er${i}`\n\t\t\t\tconst endUnit = report('error.unit', {\n\t\t\t\t\tname: hooks.error[i].fn.name\n\t\t\t\t})\n\n\t\t\t\tfnLiteral += `\\nlet ${name} = handleErrors[${i}](c)\\n`\n\n\t\t\t\tif (isAsync(hooks.error[i]))\n\t\t\t\t\tfnLiteral += `if (${name} instanceof Promise) ${name} = await ${name}\\n`\n\n\t\t\t\tendUnit()\n\n\t\t\t\tfnLiteral += `${name} = mapEarlyResponse(${name}, set, c.request)\\n`\n\t\t\t\tfnLiteral += `if (${name}) {`\n\t\t\t\tfnLiteral += `return ${name} }\\n`\n\t\t\t}\n\t\t}\n\n\t\tendError()\n\n\t\tfnLiteral += `return handleError(c, error, true)\\n\\n`\n\n\t\tif (!maybeAsync) fnLiteral += '})()'\n\n\t\tfnLiteral += '}'\n\n\t\tif (handleResponse || hasTrace) {\n\t\t\tfnLiteral += ` finally { `\n\n\t\t\tconst endResponse = report('response', {\n\t\t\t\tunit: hooks.onResponse.length\n\t\t\t})\n\n\t\t\tfnLiteral += handleResponse\n\n\t\t\tendResponse()\n\n\t\t\tfnLiteral += `}`\n\t\t}\n\t}\n\n\tfnLiteral = `const {\n\t\thandler,\n\t\thandleError,\n\t\thooks: {\n\t\t\ttransform,\n\t\t\tresolve,\n\t\t\tbeforeHandle,\n\t\t\tafterHandle,\n\t\t\tmapResponse: onMapResponse,\n\t\t\tparse,\n\t\t\terror: handleErrors,\n\t\t\tonResponse\n\t\t},\n\t\tvalidator: {\n\t\t\tbody,\n\t\t\theaders,\n\t\t\tparams,\n\t\t\tquery,\n\t\t\tresponse,\n\t\t\tcookie\n\t\t},\n\t\tutils: {\n\t\t\tmapResponse,\n\t\t\tmapCompactResponse,\n\t\t\tmapEarlyResponse,\n\t\t\tparseQuery,\n\t\t\tisNotEmpty\n\t\t},\n\t\terror: {\n\t\t\tNotFoundError,\n\t\t\tValidationError,\n\t\t\tInternalServerError,\n\t\t\tParseError\n\t\t},\n\t\tschema,\n\t\tdefinitions,\n\t\tERROR_CODE,\n\t\tgetReporter,\n\t\trequestId,\n\t\tparseCookie,\n\t\tsignCookie,\n\t\tdecodeURIComponent,\n\t\tELYSIA_RESPONSE\n\t} = hooks\n\n\t${\n\t\thooks.onResponse.length\n\t\t\t? `const ${hooks.onResponse\n\t\t\t\t\t.map((x, i) => `res${i} = onResponse[${i}]`)\n\t\t\t\t\t.join(',')}`\n\t\t\t: ''\n\t}\n\n\treturn ${maybeAsync ? 'async' : ''} function handle(c) {\n\t\t${hooks.beforeHandle.length ? 'let be' : ''}\n\t\t${hooks.afterHandle.length ? 'let af' : ''}\n\t\t${hooks.mapResponse.length ? 'let mr' : ''}\n\n\t\t${allowMeta ? 'c.schema = schema; c.defs = definitions' : ''}\n\t\t${fnLiteral}\n\t}`\n\n\t// console.log(fnLiteral)\n\n\tconst createHandler = Function('hooks', fnLiteral)\n\n\treturn createHandler({\n\t\thandler,\n\t\thooks: lifeCycleToFn(hooks),\n\t\tvalidator,\n\t\t// @ts-expect-error\n\t\thandleError: app.handleError,\n\t\tutils: {\n\t\t\tmapResponse,\n\t\t\tmapCompactResponse,\n\t\t\tmapEarlyResponse,\n\t\t\tparseQuery,\n\t\t\tisNotEmpty\n\t\t},\n\t\terror: {\n\t\t\tNotFoundError,\n\t\t\tValidationError,\n\t\t\tInternalServerError,\n\t\t\tParseError\n\t\t},\n\t\tschema: app.router.history,\n\t\t// @ts-expect-error\n\t\tdefinitions: app.definitions.type,\n\t\tERROR_CODE,\n\t\t// @ts-expect-error\n\t\tgetReporter: () => app.reporter,\n\t\trequestId,\n\t\tparseCookie,\n\t\tsignCookie,\n\t\tdecodeURIComponent,\n\t\tELYSIA_RESPONSE\n\t})\n}\n\nexport const composeGeneralHandler = (\n\tapp: Elysia<any, any, any, any, any, any, any, any>\n) => {\n\tconst inference = {\n\t\tevent: {\n\t\t\t// @ts-expect-error\n\t\t\t...app.inference.event,\n\t\t\t// @ts-expect-error\n\t\t\tqueries: [...app.inference.event.queries]\n\t\t},\n\t\t// @ts-expect-error\n\t\ttrace: { ...app.inference.trace }\n\t}\n\n\tlet decoratorsLiteral = ''\n\tlet fnLiteral = ''\n\n\t// @ts-expect-error private\n\tconst defaultHeaders = app.setHeaders\n\n\t// @ts-ignore\n\tfor (const key of Object.keys(app.singleton.decorator))\n\t\tdecoratorsLiteral += `,${key}: app.singleton.decorator.${key}`\n\n\tconst router = app.router\n\tconst hasTrace = app.event.trace.length > 0\n\n\tlet findDynamicRoute = `\n\tconst route = router.find(request.method, path) ${\n\t\trouter.http.root.ALL ? '?? router.find(\"ALL\", path)' : ''\n\t}\n\n\tif (route === null)\n\t\treturn ${\n\t\t\tapp.event.error.length\n\t\t\t\t? `app.handleError(ctx, notFound)`\n\t\t\t\t: app.event.request.length\n\t\t\t\t? `new Response(error404Message, {\n\t\t\t\t\tstatus: ctx.set.status === 200 ? 404 : ctx.set.status,\n\t\t\t\t\theaders: ctx.set.headers\n\t\t\t\t})`\n\t\t\t\t: `error404.clone()`\n\t\t}\n\n\tctx.params = route.params\\n`\n\n\tconst shouldPrecompile =\n\t\tapp.config.precompile === true ||\n\t\t(typeof app.config.precompile === 'object' &&\n\t\t\tapp.config.precompile.compose === true)\n\n\tif (!shouldPrecompile)\n\t\tfindDynamicRoute += `\n\t\t\tif(route.store.composed)\n\t\t\t\treturn route.store.composed(ctx)\n\n\t\t\tif(route.store.compose)\n\t\t\t\treturn (route.store.compose())(ctx)`\n\telse findDynamicRoute += `return route.store(ctx)`\n\n\tfindDynamicRoute += '\\n'\n\n\tlet switchMap = ``\n\tfor (const [path, { code, all }] of Object.entries(router.static.http.map))\n\t\tswitchMap += `case '${path}':\\nswitch(request.method) {\\n${code}\\n${\n\t\t\tall ?? `default: break map`\n\t\t}}\\n\\n`\n\n\tconst maybeAsync = app.event.request.some(isAsync)\n\n\tconst init = `\\n\n\tconst url = request.url\n\tconst s = url.indexOf('/', 11)\n\tconst qi = url.indexOf('?', s + 1)\n\tlet path\n\tif(qi === -1)\n\t\tpath = url.substring(s)\n\telse\n\t\tpath = url.substring(s, qi)\\n`\n\n\tfnLiteral += `const {\n\t\tapp,\n\t\tmapEarlyResponse,\n\t\tNotFoundError,\n\t\trequestId,\n\t\tgetReporter,\n\t\thandleError,\n\t\terror,\n\t\tredirect\n\t} = data\n\n\tconst store = app.singleton.store\n\tconst staticRouter = app.router.static.http\n\tconst wsRouter = app.router.ws\n\tconst router = app.router.http\n\n\tconst notFound = new NotFoundError()\n\n\t${\n\t\tapp.event.request.length\n\t\t\t? `const onRequest = app.event.request.map(x => x.fn)`\n\t\t\t: ''\n\t}\n\t${router.static.http.variables}\n\t${\n\t\tapp.event.error.length\n\t\t\t? ''\n\t\t\t: `\n\tconst error404Message = notFound.message.toString()\n\tconst error404 = new Response(error404Message, { status: 404 });\n\t`\n\t}\n\n\treturn ${maybeAsync ? 'async' : ''} function map(request) {\\n`\n\n\tif (app.event.request.length) fnLiteral += `let re`\n\n\tconst report = createReport({\n\t\thasTrace,\n\t\thasTraceSet: inference.trace.set,\n\t\tcondition: {\n\t\t\trequest: inference.trace.request\n\t\t},\n\t\taddFn: (word) => {\n\t\t\tfnLiteral += word\n\t\t}\n\t})\n\n\tif (app.event.request.length) {\n\t\tfnLiteral += `\n\t\t\t${hasTrace ? 'const id = +requestId.value++' : ''}\n\n\t\t\tconst ctx = {\n\t\t\t\trequest,\n\t\t\t\tstore,\n\t\t\t\tredirect,\n\t\t\t\tset: {\n\t\t\t\t\theaders: ${\n\t\t\t\t\t\tObject.keys(defaultHeaders ?? {}).length\n\t\t\t\t\t\t\t? 'Object.assign({}, app.setHeaders)'\n\t\t\t\t\t\t\t: '{}'\n\t\t\t\t\t},\n\t\t\t\t\tstatus: 200\n\t\t\t\t},\n\t\t\t\terror\n\t\t\t\t${hasTrace ? ',$$requestId: +id' : ''}\n\t\t\t\t${decoratorsLiteral}\n\t\t\t}\n\t\t`\n\n\t\tconst endReport = report('request', {\n\t\t\tattribute: 'ctx',\n\t\t\tunit: app.event.request.length\n\t\t})\n\n\t\tfnLiteral += `\\n try {\\n`\n\n\t\tfor (let i = 0; i < app.event.request.length; i++) {\n\t\t\tconst hook = app.event.request[i]\n\t\t\tconst withReturn = hasReturn(hook.fn.toString())\n\t\t\tconst maybeAsync = isAsync(hook)\n\n\t\t\tconst endUnit = report('request.unit', {\n\t\t\t\tname: app.event.request[i].fn.name\n\t\t\t})\n\n\t\t\tif (withReturn) {\n\t\t\t\tfnLiteral += `re = mapEarlyResponse(\n\t\t\t\t\t${maybeAsync ? 'await' : ''} onRequest[${i}](ctx),\n\t\t\t\t\tctx.set,\n\t\t\t\t\trequest\n\t\t\t\t)\\n`\n\n\t\t\t\tendUnit()\n\n\t\t\t\tfnLiteral += `if(re !== undefined) return re\\n`\n\t\t\t} else {\n\t\t\t\tfnLiteral += `${\n\t\t\t\t\tmaybeAsync ? 'await' : ''\n\t\t\t\t} onRequest[${i}](ctx)\\n`\n\t\t\t\tendUnit()\n\t\t\t}\n\t\t}\n\n\t\tfnLiteral += `} catch (error) {\n\t\t\treturn app.handleError(ctx, error)\n\t\t}`\n\n\t\tendReport()\n\n\t\tfnLiteral += init\n\t\tfnLiteral += `\\nctx.qi = qi\\n ctx.path = path\\n`\n\t} else {\n\t\tfnLiteral += init\n\t\tfnLiteral += `${hasTrace ? 'const id = +requestId.value++' : ''}\n\t\tconst ctx = {\n\t\t\trequest,\n\t\t\tstore,\n\t\t\tqi,\n\t\t\tpath,\n\t\t\tredirect,\n\t\t\tset: {\n\t\t\t\theaders: ${\n\t\t\t\t\tObject.keys(defaultHeaders ?? {}).length\n\t\t\t\t\t\t? 'Object.assign({}, app.setHeaders)'\n\t\t\t\t\t\t: '{}'\n\t\t\t\t},\n\t\t\t\tstatus: 200\n\t\t\t},\n\t\t\terror\n\t\t\t${hasTrace ? ',$$requestId: id' : ''}\n\t\t\t${decoratorsLiteral}\n\t\t}`\n\n\t\treport('request', {\n\t\t\tunit: app.event.request.length,\n\t\t\tattribute:\n\t\t\t\tinference.trace.context ||\n\t\t\t\tinference.trace.store ||\n\t\t\t\tinference.trace.set\n\t\t\t\t\t? 'ctx'\n\t\t\t\t\t: ''\n\t\t})()\n\t}\n\n\tconst wsPaths = app.router.static.ws\n\tconst wsRouter = app.router.ws\n\n\tif (Object.keys(wsPaths).length || wsRouter.history.length) {\n\t\tfnLiteral += `\n\t\t\tif(request.method === 'GET') {\n\t\t\t\tswitch(path) {`\n\n\t\tfor (const [path, index] of Object.entries(wsPaths)) {\n\t\t\tfnLiteral += `\n\t\t\t\t\tcase '${path}':\n\t\t\t\t\t\tif(request.headers.get('upgrade') === 'websocket')\n\t\t\t\t\t\t\treturn st${index}(ctx)\n\n\t\t\t\t\t\tbreak`\n\t\t}\n\n\t\tfnLiteral += `\n\t\t\t\tdefault:\n\t\t\t\t\tif(request.headers.get('upgrade') === 'websocket') {\n\t\t\t\t\t\tconst route = wsRouter.find('ws', path)\n\n\t\t\t\t\t\tif(route) {\n\t\t\t\t\t\t\tctx.params = route.params\n\n\t\t\t\t\t\t\treturn route.store(ctx)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t}\\n`\n\t}\n\n\tfnLiteral += `\n\t\tmap: switch(path) {\n\t\t\t${switchMap}\n\n\t\t\tdefault:\n\t\t\t\tbreak\n\t\t}\n\n\t\t${findDynamicRoute}\n\t}`\n\n\tconst handleError = composeErrorHandler(app) as any\n\n\t// @ts-ignore\n\tapp.handleError = handleError\n\n\treturn Function(\n\t\t'data',\n\t\tfnLiteral\n\t)({\n\t\tapp,\n\t\tmapEarlyResponse,\n\t\tNotFoundError,\n\t\t// @ts-ignore\n\t\tgetReporter: () => app.reporter,\n\t\trequestId,\n\t\thandleError,\n\t\terror,\n\t\tredirect\n\t})\n}\n\nexport const composeErrorHandler = (\n\tapp: Elysia<any, any, any, any, any, any, any, any>\n) => {\n\tlet fnLiteral = `const {\n\t\tapp: { event: { error: onErrorContainer, onResponse: resContainer } },\n\t\tmapResponse,\n\t\tERROR_CODE,\n\t\tELYSIA_RESPONSE\n\t} = inject\n\n\tconst onError = onErrorContainer.map(x => x.fn)\n\tconst res = resContainer.map(x => x.fn)\n\n\treturn ${\n\t\tapp.event.error.find(isAsync) ? 'async' : ''\n\t} function(context, error, skipGlobal) {\n\t\tlet r\n\n\t\tconst { set } = context\n\n\t\tcontext.code = error.code\n\t\tcontext.error = error\n\n\t\tif(typeof error === \"object\" && ELYSIA_RESPONSE in error) {\n\t\t\terror.status = error[ELYSIA_RESPONSE]\n\t\t\terror.message = error.response\n\t\t}\\n`\n\n\tfor (let i = 0; i < app.event.error.length; i++) {\n\t\tconst handler = app.event.error[i]\n\n\t\tconst response = `${\n\t\t\tisAsync(handler) ? 'await ' : ''\n\t\t}onError[${i}](context)`\n\n\t\tfnLiteral += '\\nif(skipGlobal !== true) {\\n'\n\n\t\tif (hasReturn(handler.fn.toString()))\n\t\t\tfnLiteral += `r = ${response}; if(r !== undefined) {\n\t\t\t\tif(r instanceof Response) return r\n\n\t\t\t\tif(r[ELYSIA_RESPONSE]) {\n\t\t\t\t\terror.status = error[ELYSIA_RESPONSE]\n\t\t\t\t\terror.message = error.response\n\t\t\t\t}\n\n\t\t\t\tif(set.status === 200) set.status = error.status\n\t\t\t\treturn mapResponse(r, set, context.request)\n\t\t\t}\\n`\n\t\telse fnLiteral += response + '\\n'\n\n\t\tfnLiteral += '\\n}\\n'\n\t}\n\n\tfnLiteral += `if(error.constructor.name === \"ValidationError\" || error.constructor.name === \"TransformDecodeError\") {\n\t\tset.status = error.status ?? 422\n\t\treturn new Response(\n\t\t\terror.message,\n\t\t\t{\n\t\t\t\theaders: Object.assign(\n\t\t\t\t\t{ 'content-type': 'application/json'},\n\t\t\t\t\tset.headers\n\t\t\t\t),\n\t\t\t\tstatus: set.status\n\t\t\t}\n\t\t)\n\t} else {\n\t\tif(error.code && typeof error.status === \"number\")\n\t\t\treturn new Response(\n\t\t\t\terror.message,\n\t\t\t\t{ headers: set.headers, status: error.status }\n\t\t\t)\n\n\t\treturn mapResponse(error, set, context.request)\n\t}\n}`\n\n\treturn Function(\n\t\t'inject',\n\t\tfnLiteral\n\t)({\n\t\tapp,\n\t\tmapResponse,\n\t\tERROR_CODE,\n\t\tELYSIA_RESPONSE\n\t})\n}\n\nexport const jitRoute = (\n\tindex: number\n) => `if(stc${index}) return stc${index}(ctx)\nif(st${index}.compose) return (stc${index} = st${index}.compose())(ctx)\n\nreturn st${index}(ctx)`\n",
  "import type { Elysia } from '.'\n\nimport { mapEarlyResponse, mapResponse } from './handler'\nimport { ElysiaErrors, NotFoundError, ValidationError } from './error'\n\nimport type { Context } from './context'\n\nimport { parse as parseQuery } from 'fast-querystring'\n\nimport { signCookie } from './utils'\nimport { parseCookie } from './cookies'\n\nimport type { Handler, LifeCycleStore, SchemaValidator } from './types'\n\n// JIT Handler\nexport type DynamicHandler = {\n\thandle: Handler<any, any>\n\tcontent?: string\n\thooks: LifeCycleStore\n\tvalidator?: SchemaValidator\n}\n\nexport const createDynamicHandler =\n\t(app: Elysia<any, any, any, any, any, any, any, any>) =>\n\tasync (request: Request): Promise<Response> => {\n\t\tconst url = request.url,\n\t\t\ts = url.indexOf('/', 11),\n\t\t\tqi = url.indexOf('?', s + 1),\n\t\t\tpath = qi === -1 ? url.substring(s) : url.substring(s, qi)\n\n\t\tconst set: Context['set'] = {\n\t\t\tcookie: {},\n\t\t\tstatus: 200,\n\t\t\theaders: {}\n\t\t}\n\n\t\tconst context = Object.assign(\n\t\t\t{},\n\t\t\t// @ts-expect-error\n\t\t\tapp.singleton.decorator,\n\t\t\t{\n\t\t\t\tset,\n\t\t\t\t// @ts-expect-error\n\t\t\t\tstore: app.singleton.store,\n\t\t\t\trequest,\n\t\t\t\tpath,\n\t\t\t\tqi\n\t\t\t}\n\t\t) as unknown as Context\n\n\t\ttry {\n\t\t\tfor (let i = 0; i < app.event.request.length; i++) {\n\t\t\t\tconst onRequest = app.event.request[i].fn\n\t\t\t\tlet response = onRequest(context as any)\n\t\t\t\tif (response instanceof Promise) response = await response\n\n\t\t\t\tresponse = mapEarlyResponse(response, set)\n\t\t\t\tif (response) return response\n\t\t\t}\n\n\t\t\tconst handler =\n\t\t\t\tapp.router.dynamic.find(request.method, path) ??\n\t\t\t\tapp.router.dynamic.find('ALL', path)\n\n\t\t\tif (!handler) throw new NotFoundError()\n\n\t\t\tconst { handle, hooks, validator, content } = handler.store\n\n\t\t\tlet body: string | Record<string, any> | undefined\n\t\t\tif (request.method !== 'GET' && request.method !== 'HEAD') {\n\t\t\t\tif (content) {\n\t\t\t\t\tswitch (content) {\n\t\t\t\t\t\tcase 'application/json':\n\t\t\t\t\t\t\tbody = (await request.json()) as any\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'text/plain':\n\t\t\t\t\t\t\tbody = await request.text()\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'application/x-www-form-urlencoded':\n\t\t\t\t\t\t\tbody = parseQuery(await request.text())\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'application/octet-stream':\n\t\t\t\t\t\t\tbody = await request.arrayBuffer()\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'multipart/form-data':\n\t\t\t\t\t\t\tbody = {}\n\n\t\t\t\t\t\t\tconst form = await request.formData()\n\t\t\t\t\t\t\tfor (const key of form.keys()) {\n\t\t\t\t\t\t\t\tif (body[key]) continue\n\n\t\t\t\t\t\t\t\tconst value = form.getAll(key)\n\t\t\t\t\t\t\t\tif (value.length === 1) body[key] = value[0]\n\t\t\t\t\t\t\t\telse body[key] = value\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet contentType = request.headers.get('content-type')\n\n\t\t\t\t\tif (contentType) {\n\t\t\t\t\t\tconst index = contentType.indexOf(';')\n\t\t\t\t\t\tif (index !== -1)\n\t\t\t\t\t\t\tcontentType = contentType.slice(0, index)\n\n\t\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\t\tcontext.contentType = contentType\n\n\t\t\t\t\t\tfor (let i = 0; i < hooks.parse.length; i++) {\n\t\t\t\t\t\t\tconst hook = hooks.parse[i].fn\n\t\t\t\t\t\t\tlet temp = hook(context as any, contentType)\n\t\t\t\t\t\t\tif (temp instanceof Promise) temp = await temp\n\n\t\t\t\t\t\t\tif (temp) {\n\t\t\t\t\t\t\t\tbody = temp\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\t\tdelete context.contentType\n\n\t\t\t\t\t\t// body might be empty string thus can't use !body\n\t\t\t\t\t\tif (body === undefined) {\n\t\t\t\t\t\t\tswitch (contentType) {\n\t\t\t\t\t\t\t\tcase 'application/json':\n\t\t\t\t\t\t\t\t\tbody = (await request.json()) as any\n\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\tcase 'text/plain':\n\t\t\t\t\t\t\t\t\tbody = await request.text()\n\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\tcase 'application/x-www-form-urlencoded':\n\t\t\t\t\t\t\t\t\tbody = parseQuery(await request.text())\n\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\tcase 'application/octet-stream':\n\t\t\t\t\t\t\t\t\tbody = await request.arrayBuffer()\n\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\tcase 'multipart/form-data':\n\t\t\t\t\t\t\t\t\tbody = {}\n\n\t\t\t\t\t\t\t\t\tconst form = await request.formData()\n\t\t\t\t\t\t\t\t\tfor (const key of form.keys()) {\n\t\t\t\t\t\t\t\t\t\tif (body[key]) continue\n\n\t\t\t\t\t\t\t\t\t\tconst value = form.getAll(key)\n\t\t\t\t\t\t\t\t\t\tif (value.length === 1)\n\t\t\t\t\t\t\t\t\t\t\tbody[key] = value[0]\n\t\t\t\t\t\t\t\t\t\telse body[key] = value\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcontext.body = body\n\t\t\t// @ts-expect-error\n\t\t\tcontext.params = handler?.params || undefined\n\t\t\tcontext.query = qi === -1 ? {} : parseQuery(url.substring(qi + 1))\n\n\t\t\tcontext.headers = {}\n\t\t\tfor (const [key, value] of request.headers.entries())\n\t\t\t\tcontext.headers[key] = value\n\n\t\t\tconst cookieMeta = Object.assign(\n\t\t\t\t{},\n\t\t\t\tapp.config?.cookie,\n\t\t\t\t// @ts-expect-error\n\t\t\t\tvalidator?.cookie?.config\n\t\t\t) as {\n\t\t\t\tsecrets?: string | string[]\n\t\t\t\tsign: string[] | true\n\t\t\t\tproperties: { [x: string]: Object }\n\t\t\t}\n\n\t\t\tconst cookieHeaderValue = request.headers.get('cookie')\n\n\t\t\tcontext.cookie = await parseCookie(\n\t\t\t\tcontext.set,\n\t\t\t\tcookieHeaderValue,\n\t\t\t\tcookieMeta\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tsecrets:\n\t\t\t\t\t\t\t\tcookieMeta.secrets !== undefined\n\t\t\t\t\t\t\t\t\t? typeof cookieMeta.secrets === 'string'\n\t\t\t\t\t\t\t\t\t\t? cookieMeta.secrets\n\t\t\t\t\t\t\t\t\t\t: cookieMeta.secrets.join(',')\n\t\t\t\t\t\t\t\t\t: undefined,\n\t\t\t\t\t\t\tsign:\n\t\t\t\t\t\t\t\tcookieMeta.sign === true\n\t\t\t\t\t\t\t\t\t? true\n\t\t\t\t\t\t\t\t\t: cookieMeta.sign !== undefined\n\t\t\t\t\t\t\t\t\t? typeof cookieMeta.sign === 'string'\n\t\t\t\t\t\t\t\t\t\t? cookieMeta.sign\n\t\t\t\t\t\t\t\t\t\t: cookieMeta.sign.join(',')\n\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t  }\n\t\t\t\t\t: undefined\n\t\t\t)\n\n\t\t\tfor (let i = 0; i < hooks.transform.length; i++) {\n\t\t\t\tconst hook = hooks.transform[i]\n\t\t\t\tconst operation = hook.fn(context)\n\n\t\t\t\tif (hook.subType === 'derive') {\n\t\t\t\t\tif (operation instanceof Promise)\n\t\t\t\t\t\tObject.assign(context, await operation)\n\t\t\t\t\telse Object.assign(context, operation)\n\t\t\t\t} else if (operation instanceof Promise) await operation\n\t\t\t}\n\n\t\t\tif (validator) {\n\t\t\t\tif (validator.headers) {\n\t\t\t\t\tconst _header: Record<string, string> = {}\n\t\t\t\t\tfor (const key in request.headers)\n\t\t\t\t\t\t_header[key] = request.headers.get(key)!\n\n\t\t\t\t\tif (validator.headers.Check(_header) === false)\n\t\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t\t'header',\n\t\t\t\t\t\t\tvalidator.headers,\n\t\t\t\t\t\t\t_header\n\t\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\tif (validator.params?.Check(context.params) === false)\n\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t'params',\n\t\t\t\t\t\tvalidator.params,\n\t\t\t\t\t\tcontext.params\n\t\t\t\t\t)\n\n\t\t\t\tif (validator.query?.Check(context.query) === false)\n\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t'query',\n\t\t\t\t\t\tvalidator.query,\n\t\t\t\t\t\tcontext.query\n\t\t\t\t\t)\n\n\t\t\t\tif (validator.cookie) {\n\t\t\t\t\tconst cookieValue: Record<string, unknown> = {}\n\t\t\t\t\tfor (const [key, value] of Object.entries(context.cookie))\n\t\t\t\t\t\tcookieValue[key] = value.value\n\n\t\t\t\t\tif (validator.cookie?.Check(cookieValue) === false)\n\t\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t\t'cookie',\n\t\t\t\t\t\t\tvalidator.cookie,\n\t\t\t\t\t\t\tcookieValue\n\t\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\tif (validator.body?.Check(body) === false)\n\t\t\t\t\tthrow new ValidationError('body', validator.body, body)\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < hooks.beforeHandle.length; i++) {\n\t\t\t\tlet response = hooks.beforeHandle[i].fn(context)\n\t\t\t\tif (response instanceof Promise) response = await response\n\n\t\t\t\t// `false` is a falsey value, check for undefined instead\n\t\t\t\tif (response !== undefined) {\n\t\t\t\t\t;(\n\t\t\t\t\t\tcontext as Context & {\n\t\t\t\t\t\t\tresponse: unknown\n\t\t\t\t\t\t}\n\t\t\t\t\t).response = response\n\n\t\t\t\t\tfor (let i = 0; i < hooks.afterHandle.length; i++) {\n\t\t\t\t\t\tlet newResponse = hooks.afterHandle[i].fn(\n\t\t\t\t\t\t\tcontext as Context & {\n\t\t\t\t\t\t\t\tresponse: unknown\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)\n\t\t\t\t\t\tif (newResponse instanceof Promise)\n\t\t\t\t\t\t\tnewResponse = await newResponse\n\n\t\t\t\t\t\tif (newResponse) response = newResponse\n\t\t\t\t\t}\n\n\t\t\t\t\tconst result = mapEarlyResponse(response, context.set)\n\t\t\t\t\tif (result) return result\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet response = handle(context)\n\t\t\tif (response instanceof Promise) response = await response\n\n\t\t\tif (!hooks.afterHandle.length) {\n\t\t\t\tconst responseValidator = validator?.response?.[response.status]\n\n\t\t\t\tif (responseValidator?.Check(response) === false)\n\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t'response',\n\t\t\t\t\t\tresponseValidator,\n\t\t\t\t\t\tresponse\n\t\t\t\t\t)\n\t\t\t} else {\n\t\t\t\t;(\n\t\t\t\t\tcontext as Context & {\n\t\t\t\t\t\tresponse: unknown\n\t\t\t\t\t}\n\t\t\t\t).response = response\n\n\t\t\t\tfor (let i = 0; i < hooks.afterHandle.length; i++) {\n\t\t\t\t\tlet newResponse = hooks.afterHandle[i].fn(\n\t\t\t\t\t\tcontext as Context & {\n\t\t\t\t\t\t\tresponse: unknown\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t\tif (newResponse instanceof Promise)\n\t\t\t\t\t\tnewResponse = await newResponse\n\n\t\t\t\t\tconst result = mapEarlyResponse(newResponse, context.set)\n\t\t\t\t\tif (result !== undefined) {\n\t\t\t\t\t\tconst responseValidator =\n\t\t\t\t\t\t\tvalidator?.response?.[response.status]\n\n\t\t\t\t\t\tif (responseValidator?.Check(result) === false)\n\t\t\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t\t\t'response',\n\t\t\t\t\t\t\t\tresponseValidator,\n\t\t\t\t\t\t\t\tresult\n\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\treturn result\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (context.set.cookie && cookieMeta?.sign) {\n\t\t\t\tconst secret = !cookieMeta.secrets\n\t\t\t\t\t? undefined\n\t\t\t\t\t: typeof cookieMeta.secrets === 'string'\n\t\t\t\t\t? cookieMeta.secrets\n\t\t\t\t\t: cookieMeta.secrets[0]\n\n\t\t\t\tif (cookieMeta.sign === true)\n\t\t\t\t\tfor (const [key, cookie] of Object.entries(\n\t\t\t\t\t\tcontext.set.cookie\n\t\t\t\t\t))\n\t\t\t\t\t\tcontext.set.cookie[key].value = await signCookie(\n\t\t\t\t\t\t\tcookie.value as any,\n\t\t\t\t\t\t\t'${secret}'\n\t\t\t\t\t\t)\n\t\t\t\telse {\n\t\t\t\t\t// @ts-expect-error private\n\t\t\t\t\tconst properties = validator?.cookie?.schema?.properties\n\n\t\t\t\t\tfor (const name of cookieMeta.sign) {\n\t\t\t\t\t\tif (!(name in properties))\n\t\t\t\t\t\t\tcontinue\n\n\t\t\t\t\t\tif (context.set.cookie[name]?.value) {\n\t\t\t\t\t\t\tcontext.set.cookie[name].value = await signCookie(\n\t\t\t\t\t\t\t\tcontext.set.cookie[name].value as any,\n\t\t\t\t\t\t\t\tsecret as any\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn mapResponse(response, context.set)\n\t\t} catch (error) {\n\t\t\tif ((error as ElysiaErrors).status)\n\t\t\t\tset.status = (error as ElysiaErrors).status\n\n\t\t\t// @ts-expect-error private\n\t\t\treturn app.handleError(context, error)\n\t\t} finally {\n\t\t\tfor (const onResponse of app.event.onResponse)\n\t\t\t\tawait onResponse.fn(context)\n\t\t}\n\t}\n\nexport const createDynamicErrorHandler =\n\t(app: Elysia<any, any, any, any, any, any, any, any>) =>\n\tasync (context: Context, error: ElysiaErrors) => {\n\t\tconst errorContext = Object.assign(context, { error, code: error.code })\n\t\terrorContext.set = context.set\n\n\t\tfor (let i = 0; i < app.event.error.length; i++) {\n\t\t\tconst hook = app.event.error[i]\n\t\t\tlet response = hook.fn(errorContext as any)\n\t\t\tif (response instanceof Promise) response = await response\n\t\t\tif (response !== undefined && response !== null)\n\t\t\t\treturn mapResponse(response, context.set)\n\t\t}\n\n\t\treturn new Response(\n\t\t\ttypeof error.cause === 'string' ? error.cause : error.message,\n\t\t\t{\n\t\t\t\theaders: context.set.headers,\n\t\t\t\tstatus: error.status ?? 500\n\t\t\t}\n\t\t)\n\t}\n",
  "import type { Elysia } from '.'\n\nimport { mapEarlyResponse, mapResponse } from './handler'\nimport { ElysiaErrors, NotFoundError, ValidationError } from './error'\n\nimport type { Context } from './context'\n\nimport { parse as parseQuery } from 'fast-querystring'\n\nimport { signCookie } from './utils'\nimport { parseCookie } from './cookies'\n\nimport type { Handler, LifeCycleStore, SchemaValidator } from './types'\n\n// JIT Handler\nexport type DynamicHandler = {\n\thandle: Handler<any, any>\n\tcontent?: string\n\thooks: LifeCycleStore\n\tvalidator?: SchemaValidator\n}\n\nexport const createDynamicHandler =\n\t(app: Elysia<any, any, any, any, any, any, any, any>) =>\n\tasync (request: Request): Promise<Response> => {\n\t\tconst url = request.url,\n\t\t\ts = url.indexOf('/', 11),\n\t\t\tqi = url.indexOf('?', s + 1),\n\t\t\tpath = qi === -1 ? url.substring(s) : url.substring(s, qi)\n\n\t\tconst set: Context['set'] = {\n\t\t\tcookie: {},\n\t\t\tstatus: 200,\n\t\t\theaders: {}\n\t\t}\n\n\t\tconst context = Object.assign(\n\t\t\t{},\n\t\t\t// @ts-expect-error\n\t\t\tapp.singleton.decorator,\n\t\t\t{\n\t\t\t\tset,\n\t\t\t\t// @ts-expect-error\n\t\t\t\tstore: app.singleton.store,\n\t\t\t\trequest,\n\t\t\t\tpath,\n\t\t\t\tqi\n\t\t\t}\n\t\t) as unknown as Context\n\n\t\ttry {\n\t\t\tfor (let i = 0; i < app.event.request.length; i++) {\n\t\t\t\tconst onRequest = app.event.request[i].fn\n\t\t\t\tlet response = onRequest(context as any)\n\t\t\t\tif (response instanceof Promise) response = await response\n\n\t\t\t\tresponse = mapEarlyResponse(response, set)\n\t\t\t\tif (response) return response\n\t\t\t}\n\n\t\t\tconst handler =\n\t\t\t\tapp.router.dynamic.find(request.method, path) ??\n\t\t\t\tapp.router.dynamic.find('ALL', path)\n\n\t\t\tif (!handler) throw new NotFoundError()\n\n\t\t\tconst { handle, hooks, validator, content } = handler.store\n\n\t\t\tlet body: string | Record<string, any> | undefined\n\t\t\tif (request.method !== 'GET' && request.method !== 'HEAD') {\n\t\t\t\tif (content) {\n\t\t\t\t\tswitch (content) {\n\t\t\t\t\t\tcase 'application/json':\n\t\t\t\t\t\t\tbody = (await request.json()) as any\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'text/plain':\n\t\t\t\t\t\t\tbody = await request.text()\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'application/x-www-form-urlencoded':\n\t\t\t\t\t\t\tbody = parseQuery(await request.text())\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'application/octet-stream':\n\t\t\t\t\t\t\tbody = await request.arrayBuffer()\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'multipart/form-data':\n\t\t\t\t\t\t\tbody = {}\n\n\t\t\t\t\t\t\tconst form = await request.formData()\n\t\t\t\t\t\t\tfor (const key of form.keys()) {\n\t\t\t\t\t\t\t\tif (body[key]) continue\n\n\t\t\t\t\t\t\t\tconst value = form.getAll(key)\n\t\t\t\t\t\t\t\tif (value.length === 1) body[key] = value[0]\n\t\t\t\t\t\t\t\telse body[key] = value\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet contentType = request.headers.get('content-type')\n\n\t\t\t\t\tif (contentType) {\n\t\t\t\t\t\tconst index = contentType.indexOf(';')\n\t\t\t\t\t\tif (index !== -1)\n\t\t\t\t\t\t\tcontentType = contentType.slice(0, index)\n\n\t\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\t\tcontext.contentType = contentType\n\n\t\t\t\t\t\tfor (let i = 0; i < hooks.parse.length; i++) {\n\t\t\t\t\t\t\tconst hook = hooks.parse[i].fn\n\t\t\t\t\t\t\tlet temp = hook(context as any, contentType)\n\t\t\t\t\t\t\tif (temp instanceof Promise) temp = await temp\n\n\t\t\t\t\t\t\tif (temp) {\n\t\t\t\t\t\t\t\tbody = temp\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\t\tdelete context.contentType\n\n\t\t\t\t\t\t// body might be empty string thus can't use !body\n\t\t\t\t\t\tif (body === undefined) {\n\t\t\t\t\t\t\tswitch (contentType) {\n\t\t\t\t\t\t\t\tcase 'application/json':\n\t\t\t\t\t\t\t\t\tbody = (await request.json()) as any\n\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\tcase 'text/plain':\n\t\t\t\t\t\t\t\t\tbody = await request.text()\n\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\tcase 'application/x-www-form-urlencoded':\n\t\t\t\t\t\t\t\t\tbody = parseQuery(await request.text())\n\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\tcase 'application/octet-stream':\n\t\t\t\t\t\t\t\t\tbody = await request.arrayBuffer()\n\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\tcase 'multipart/form-data':\n\t\t\t\t\t\t\t\t\tbody = {}\n\n\t\t\t\t\t\t\t\t\tconst form = await request.formData()\n\t\t\t\t\t\t\t\t\tfor (const key of form.keys()) {\n\t\t\t\t\t\t\t\t\t\tif (body[key]) continue\n\n\t\t\t\t\t\t\t\t\t\tconst value = form.getAll(key)\n\t\t\t\t\t\t\t\t\t\tif (value.length === 1)\n\t\t\t\t\t\t\t\t\t\t\tbody[key] = value[0]\n\t\t\t\t\t\t\t\t\t\telse body[key] = value\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcontext.body = body\n\t\t\t// @ts-expect-error\n\t\t\tcontext.params = handler?.params || undefined\n\t\t\tcontext.query = qi === -1 ? {} : parseQuery(url.substring(qi + 1))\n\n\t\t\tcontext.headers = {}\n\t\t\tfor (const [key, value] of request.headers.entries())\n\t\t\t\tcontext.headers[key] = value\n\n\t\t\tconst cookieMeta = Object.assign(\n\t\t\t\t{},\n\t\t\t\tapp.config?.cookie,\n\t\t\t\t// @ts-expect-error\n\t\t\t\tvalidator?.cookie?.config\n\t\t\t) as {\n\t\t\t\tsecrets?: string | string[]\n\t\t\t\tsign: string[] | true\n\t\t\t\tproperties: { [x: string]: Object }\n\t\t\t}\n\n\t\t\tconst cookieHeaderValue = request.headers.get('cookie')\n\n\t\t\tcontext.cookie = await parseCookie(\n\t\t\t\tcontext.set,\n\t\t\t\tcookieHeaderValue,\n\t\t\t\tcookieMeta\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tsecrets:\n\t\t\t\t\t\t\t\tcookieMeta.secrets !== undefined\n\t\t\t\t\t\t\t\t\t? typeof cookieMeta.secrets === 'string'\n\t\t\t\t\t\t\t\t\t\t? cookieMeta.secrets\n\t\t\t\t\t\t\t\t\t\t: cookieMeta.secrets.join(',')\n\t\t\t\t\t\t\t\t\t: undefined,\n\t\t\t\t\t\t\tsign:\n\t\t\t\t\t\t\t\tcookieMeta.sign === true\n\t\t\t\t\t\t\t\t\t? true\n\t\t\t\t\t\t\t\t\t: cookieMeta.sign !== undefined\n\t\t\t\t\t\t\t\t\t? typeof cookieMeta.sign === 'string'\n\t\t\t\t\t\t\t\t\t\t? cookieMeta.sign\n\t\t\t\t\t\t\t\t\t\t: cookieMeta.sign.join(',')\n\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t  }\n\t\t\t\t\t: undefined\n\t\t\t)\n\n\t\t\tfor (let i = 0; i < hooks.transform.length; i++) {\n\t\t\t\tconst hook = hooks.transform[i]\n\t\t\t\tconst operation = hook.fn(context)\n\n\t\t\t\tif (hook.subType === 'derive') {\n\t\t\t\t\tif (operation instanceof Promise)\n\t\t\t\t\t\tObject.assign(context, await operation)\n\t\t\t\t\telse Object.assign(context, operation)\n\t\t\t\t} else if (operation instanceof Promise) await operation\n\t\t\t}\n\n\t\t\tif (validator) {\n\t\t\t\tif (validator.headers) {\n\t\t\t\t\tconst _header: Record<string, string> = {}\n\t\t\t\t\tfor (const key in request.headers)\n\t\t\t\t\t\t_header[key] = request.headers.get(key)!\n\n\t\t\t\t\tif (validator.headers.Check(_header) === false)\n\t\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t\t'header',\n\t\t\t\t\t\t\tvalidator.headers,\n\t\t\t\t\t\t\t_header\n\t\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\tif (validator.params?.Check(context.params) === false)\n\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t'params',\n\t\t\t\t\t\tvalidator.params,\n\t\t\t\t\t\tcontext.params\n\t\t\t\t\t)\n\n\t\t\t\tif (validator.query?.Check(context.query) === false)\n\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t'query',\n\t\t\t\t\t\tvalidator.query,\n\t\t\t\t\t\tcontext.query\n\t\t\t\t\t)\n\n\t\t\t\tif (validator.cookie) {\n\t\t\t\t\tconst cookieValue: Record<string, unknown> = {}\n\t\t\t\t\tfor (const [key, value] of Object.entries(context.cookie))\n\t\t\t\t\t\tcookieValue[key] = value.value\n\n\t\t\t\t\tif (validator.cookie?.Check(cookieValue) === false)\n\t\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t\t'cookie',\n\t\t\t\t\t\t\tvalidator.cookie,\n\t\t\t\t\t\t\tcookieValue\n\t\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\tif (validator.body?.Check(body) === false)\n\t\t\t\t\tthrow new ValidationError('body', validator.body, body)\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < hooks.beforeHandle.length; i++) {\n\t\t\t\tlet response = hooks.beforeHandle[i].fn(context)\n\t\t\t\tif (response instanceof Promise) response = await response\n\n\t\t\t\t// `false` is a falsey value, check for undefined instead\n\t\t\t\tif (response !== undefined) {\n\t\t\t\t\t;(\n\t\t\t\t\t\tcontext as Context & {\n\t\t\t\t\t\t\tresponse: unknown\n\t\t\t\t\t\t}\n\t\t\t\t\t).response = response\n\n\t\t\t\t\tfor (let i = 0; i < hooks.afterHandle.length; i++) {\n\t\t\t\t\t\tlet newResponse = hooks.afterHandle[i].fn(\n\t\t\t\t\t\t\tcontext as Context & {\n\t\t\t\t\t\t\t\tresponse: unknown\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)\n\t\t\t\t\t\tif (newResponse instanceof Promise)\n\t\t\t\t\t\t\tnewResponse = await newResponse\n\n\t\t\t\t\t\tif (newResponse) response = newResponse\n\t\t\t\t\t}\n\n\t\t\t\t\tconst result = mapEarlyResponse(response, context.set)\n\t\t\t\t\tif (result) return result\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet response = handle(context)\n\t\t\tif (response instanceof Promise) response = await response\n\n\t\t\tif (!hooks.afterHandle.length) {\n\t\t\t\tconst responseValidator = validator?.response?.[response.status]\n\n\t\t\t\tif (responseValidator?.Check(response) === false)\n\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t'response',\n\t\t\t\t\t\tresponseValidator,\n\t\t\t\t\t\tresponse\n\t\t\t\t\t)\n\t\t\t} else {\n\t\t\t\t;(\n\t\t\t\t\tcontext as Context & {\n\t\t\t\t\t\tresponse: unknown\n\t\t\t\t\t}\n\t\t\t\t).response = response\n\n\t\t\t\tfor (let i = 0; i < hooks.afterHandle.length; i++) {\n\t\t\t\t\tlet newResponse = hooks.afterHandle[i].fn(\n\t\t\t\t\t\tcontext as Context & {\n\t\t\t\t\t\t\tresponse: unknown\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t\tif (newResponse instanceof Promise)\n\t\t\t\t\t\tnewResponse = await newResponse\n\n\t\t\t\t\tconst result = mapEarlyResponse(newResponse, context.set)\n\t\t\t\t\tif (result !== undefined) {\n\t\t\t\t\t\tconst responseValidator =\n\t\t\t\t\t\t\tvalidator?.response?.[response.status]\n\n\t\t\t\t\t\tif (responseValidator?.Check(result) === false)\n\t\t\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t\t\t'response',\n\t\t\t\t\t\t\t\tresponseValidator,\n\t\t\t\t\t\t\t\tresult\n\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\treturn result\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (context.set.cookie && cookieMeta?.sign) {\n\t\t\t\tconst secret = !cookieMeta.secrets\n\t\t\t\t\t? undefined\n\t\t\t\t\t: typeof cookieMeta.secrets === 'string'\n\t\t\t\t\t? cookieMeta.secrets\n\t\t\t\t\t: cookieMeta.secrets[0]\n\n\t\t\t\tif (cookieMeta.sign === true)\n\t\t\t\t\tfor (const [key, cookie] of Object.entries(\n\t\t\t\t\t\tcontext.set.cookie\n\t\t\t\t\t))\n\t\t\t\t\t\tcontext.set.cookie[key].value = await signCookie(\n\t\t\t\t\t\t\tcookie.value as any,\n\t\t\t\t\t\t\t'${secret}'\n\t\t\t\t\t\t)\n\t\t\t\telse {\n\t\t\t\t\t// @ts-expect-error private\n\t\t\t\t\tconst properties = validator?.cookie?.schema?.properties\n\n\t\t\t\t\tfor (const name of cookieMeta.sign) {\n\t\t\t\t\t\tif (!(name in properties))\n\t\t\t\t\t\t\tcontinue\n\n\t\t\t\t\t\tif (context.set.cookie[name]?.value) {\n\t\t\t\t\t\t\tcontext.set.cookie[name].value = await signCookie(\n\t\t\t\t\t\t\t\tcontext.set.cookie[name].value as any,\n\t\t\t\t\t\t\t\tsecret as any\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn mapResponse(response, context.set)\n\t\t} catch (error) {\n\t\t\tif ((error as ElysiaErrors).status)\n\t\t\t\tset.status = (error as ElysiaErrors).status\n\n\t\t\t// @ts-expect-error private\n\t\t\treturn app.handleError(context, error)\n\t\t} finally {\n\t\t\tfor (const onResponse of app.event.onResponse)\n\t\t\t\tawait onResponse.fn(context)\n\t\t}\n\t}\n\nexport const createDynamicErrorHandler =\n\t(app: Elysia<any, any, any, any, any, any, any, any>) =>\n\tasync (context: Context, error: ElysiaErrors) => {\n\t\tconst errorContext = Object.assign(context, { error, code: error.code })\n\t\terrorContext.set = context.set\n\n\t\tfor (let i = 0; i < app.event.error.length; i++) {\n\t\t\tconst hook = app.event.error[i]\n\t\t\tlet response = hook.fn(errorContext as any)\n\t\t\tif (response instanceof Promise) response = await response\n\t\t\tif (response !== undefined && response !== null)\n\t\t\t\treturn mapResponse(response, context.set)\n\t\t}\n\n\t\treturn new Response(\n\t\t\ttypeof error.cause === 'string' ? error.cause : error.message,\n\t\t\t{\n\t\t\t\theaders: context.set.headers,\n\t\t\t\tstatus: error.status ?? 500\n\t\t\t}\n\t\t)\n\t}\n",
  "import {\n\tDateOptions,\n\tNumberOptions,\n\tTDate,\n\tTUnsafe,\n\tTypeRegistry\n} from '@sinclair/typebox'\nimport { TypeSystem } from '@sinclair/typebox/system'\nimport {\n\tType,\n\ttype SchemaOptions,\n\ttype TNull,\n\ttype TUnion,\n\ttype TSchema,\n\ttype TUndefined,\n\tTProperties,\n\tObjectOptions,\n\tTObject,\n\tTNumber,\n\tTBoolean,\n\tFormatRegistry\n} from '@sinclair/typebox'\n\nimport { type TypeCheck } from '@sinclair/typebox/compiler'\nimport { Value } from '@sinclair/typebox/value'\nimport { fullFormats } from './formats'\n\nimport type { CookieOptions } from './cookies'\nimport { ValidationError } from './error'\nimport type { MaybeArray } from './types'\n\nconst isISO8601 =\n\t/(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))/\nconst isFormalDate =\n\t/(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)\\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s\\d{2}\\s\\d{4}\\s\\d{2}:\\d{2}:\\d{2}\\sGMT(?:\\+|-)\\d{4}\\s\\([^)]+\\)/\nconst isShortenDate =\n\t/^(?:(?:(?:(?:0?[1-9]|[12][0-9]|3[01])[/\\s-](?:0?[1-9]|1[0-2])[/\\s-](?:19|20)\\d{2})|(?:(?:19|20)\\d{2}[/\\s-](?:0?[1-9]|1[0-2])[/\\s-](?:0?[1-9]|[12][0-9]|3[01]))))(?:\\s(?:1[012]|0?[1-9]):[0-5][0-9](?::[0-5][0-9])?(?:\\s[AP]M)?)?$/\n\nconst _validateDate = fullFormats.date\nconst _validateDateTime = fullFormats['date-time']\n\nif (!FormatRegistry.Has('date'))\n\tTypeSystem.Format('date', (value: string) => {\n\t\t// Remove quote from stringified date\n\t\tconst temp = value.replace(/\"/g, '')\n\n\t\tif (\n\t\t\tisISO8601.test(temp) ||\n\t\t\tisFormalDate.test(temp) ||\n\t\t\tisShortenDate.test(temp) ||\n\t\t\t_validateDate(temp)\n\t\t) {\n\t\t\tconst date = new Date(temp)\n\t\t\tif (!Number.isNaN(date.getTime())) return true\n\t\t}\n\n\t\treturn false\n\t})\n\nif (!FormatRegistry.Has('date-time'))\n\tTypeSystem.Format('date-time', (value: string) => {\n\t\t// Remove quote from stringified date\n\t\tconst temp = value.replace(/\"/g, '')\n\n\t\tif (\n\t\t\tisISO8601.test(temp) ||\n\t\t\tisFormalDate.test(temp) ||\n\t\t\tisShortenDate.test(temp) ||\n\t\t\t_validateDateTime(temp)\n\t\t) {\n\t\t\tconst date = new Date(temp)\n\t\t\tif (!Number.isNaN(date.getTime())) return true\n\t\t}\n\n\t\treturn false\n\t})\n\nObject.entries(fullFormats).forEach((formatEntry) => {\n\tconst [formatName, formatValue] = formatEntry\n\n\tif (!FormatRegistry.Has(formatName)) {\n\t\tif (formatValue instanceof RegExp)\n\t\t\tTypeSystem.Format(formatName, (value) => formatValue.test(value))\n\t\telse if (typeof formatValue === 'function')\n\t\t\tTypeSystem.Format(formatName, formatValue)\n\t}\n})\n\nconst t = Object.assign({}, Type)\n\nexport namespace ElysiaTypeOptions {\n\texport type Numeric = NumberOptions\n\n\texport type FileUnit = number | `${number}${'k' | 'm'}`\n\n\texport interface File extends SchemaOptions {\n\t\ttype?: MaybeArray<\n\t\t\t| (string & {})\n\t\t\t| 'image'\n\t\t\t| 'image/jpeg'\n\t\t\t| 'image/png'\n\t\t\t| 'image/gif'\n\t\t\t| 'image/tiff'\n\t\t\t| 'image/x-icon'\n\t\t\t| 'image/svg'\n\t\t\t| 'image/webp'\n\t\t\t| 'image/avif'\n\t\t\t| 'audio'\n\t\t\t| 'audio/mpeg'\n\t\t\t| 'audio/x-ms-wma'\n\t\t\t| 'audio/vnd.rn-realaudio'\n\t\t\t| 'audio/x-wav'\n\t\t\t| 'video'\n\t\t\t| 'video/mpeg'\n\t\t\t| 'video/mp4'\n\t\t\t| 'video/quicktime'\n\t\t\t| 'video/x-ms-wmv'\n\t\t\t| 'video/x-msvideo'\n\t\t\t| 'video/x-flv'\n\t\t\t| 'video/webm'\n\t\t\t| 'text'\n\t\t\t| 'text/css'\n\t\t\t| 'text/csv'\n\t\t\t| 'text/html'\n\t\t\t| 'text/javascript'\n\t\t\t| 'text/plain'\n\t\t\t| 'text/xml'\n\t\t\t| 'application'\n\t\t\t| 'application/ogg'\n\t\t\t| 'application/pdf'\n\t\t\t| 'application/xhtml'\n\t\t\t| 'application/html'\n\t\t\t| 'application/json'\n\t\t\t| 'application/ld+json'\n\t\t\t| 'application/xml'\n\t\t\t| 'application/zip'\n\t\t\t| 'font'\n\t\t\t| 'font/woff2'\n\t\t\t| 'font/woff'\n\t\t\t| 'font/ttf'\n\t\t\t| 'font/otf'\n\t\t>\n\t\tminSize?: FileUnit\n\t\tmaxSize?: FileUnit\n\t}\n\n\texport interface Files extends File {\n\t\tminItems?: number\n\t\tmaxItems?: number\n\t}\n\n\texport interface CookieValidatorOption<T extends Object = {}>\n\t\textends ObjectOptions,\n\t\t\tCookieOptions {\n\t\t/**\n\t\t * Secret key for signing cookie\n\t\t *\n\t\t * If array is passed, will use Key Rotation.\n\t\t *\n\t\t * Key rotation is when an encryption key is retired\n\t\t * and replaced by generating a new cryptographic key.\n\t\t */\n\t\tsecrets?: string | string[]\n\t\t/**\n\t\t * Specified cookie name to be signed globally\n\t\t */\n\t\tsign?: Readonly<(keyof T | (string & {}))[]>\n\t}\n}\n\nconst parseFileUnit = (size: ElysiaTypeOptions.FileUnit) => {\n\tif (typeof size === 'string')\n\t\tswitch (size.slice(-1)) {\n\t\t\tcase 'k':\n\t\t\t\treturn +size.slice(0, size.length - 1) * 1024\n\n\t\t\tcase 'm':\n\t\t\t\treturn +size.slice(0, size.length - 1) * 1048576\n\n\t\t\tdefault:\n\t\t\t\treturn +size\n\t\t}\n\n\treturn size\n}\n\nconst validateFile = (options: ElysiaTypeOptions.File, value: any) => {\n\tif (!(value instanceof Blob)) return false\n\n\tif (options.minSize && value.size < parseFileUnit(options.minSize))\n\t\treturn false\n\n\tif (options.maxSize && value.size > parseFileUnit(options.maxSize))\n\t\treturn false\n\n\tif (options.extension)\n\t\tif (typeof options.extension === 'string') {\n\t\t\tif (!value.type.startsWith(options.extension)) return false\n\t\t} else {\n\t\t\tfor (let i = 0; i < options.extension.length; i++)\n\t\t\t\tif (value.type.startsWith(options.extension[i])) return true\n\n\t\t\treturn false\n\t\t}\n\n\treturn true\n}\n\ntype ElysiaFile = (\n\toptions?: Partial<ElysiaTypeOptions.Files> | undefined\n) => TUnsafe<File>\n\nconst File: ElysiaFile =\n\t(TypeRegistry.Get('Files') as unknown as ElysiaFile) ??\n\tTypeSystem.Type<File, ElysiaTypeOptions.File>('File', validateFile)\n\ntype ElysiaFiles = (\n\toptions?: Partial<ElysiaTypeOptions.Files> | undefined\n) => TUnsafe<File[]>\n\nconst Files: ElysiaFiles =\n\t(TypeRegistry.Get('Files') as unknown as ElysiaFiles) ??\n\tTypeSystem.Type<File[], ElysiaTypeOptions.Files>(\n\t\t'Files',\n\t\t(options, value) => {\n\t\t\tif (!Array.isArray(value)) return validateFile(options, value)\n\n\t\t\tif (options.minItems && value.length < options.minItems)\n\t\t\t\treturn false\n\n\t\t\tif (options.maxItems && value.length > options.maxItems)\n\t\t\t\treturn false\n\n\t\t\tfor (let i = 0; i < value.length; i++)\n\t\t\t\tif (!validateFile(options, value[i])) return false\n\n\t\t\treturn true\n\t\t}\n\t)\n\nif (!FormatRegistry.Has('numeric'))\n\tFormatRegistry.Set('numeric', (value) => !!value && !isNaN(+value))\n\nif (!FormatRegistry.Has('boolean'))\n\tFormatRegistry.Set(\n\t\t'boolean',\n\t\t(value) => value === 'true' || value === 'false'\n\t)\n\nif (!FormatRegistry.Has('ObjectString'))\n\tFormatRegistry.Set('ObjectString', (value) => {\n\t\tlet start = value.charCodeAt(0)\n\n\t\t// If starts with ' ', '\\t', '\\n', then trim first\n\t\tif (start === 9 || start === 10 || start === 32)\n\t\t\tstart = value.trimStart().charCodeAt(0)\n\n\t\tif (start !== 123 && start !== 91) return false\n\n\t\ttry {\n\t\t\tJSON.parse(value)\n\n\t\t\treturn true\n\t\t} catch {\n\t\t\treturn false\n\t\t}\n\t})\n\nexport const ElysiaType = {\n\tNumeric: (property?: NumberOptions) => {\n\t\tconst schema = Type.Number(property)\n\n\t\treturn t\n\t\t\t.Transform(\n\t\t\t\tt.Union(\n\t\t\t\t\t[\n\t\t\t\t\t\tt.String({\n\t\t\t\t\t\t\tformat: 'numeric',\n\t\t\t\t\t\t\tdefault: 0\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tt.Number(property)\n\t\t\t\t\t],\n\t\t\t\t\tproperty\n\t\t\t\t)\n\t\t\t)\n\t\t\t.Decode((value) => {\n\t\t\t\tconst number = +value\n\t\t\t\tif (isNaN(number)) return value\n\n\t\t\t\tif (property && !Value.Check(schema, number))\n\t\t\t\t\tthrow new ValidationError('property', schema, number)\n\n\t\t\t\treturn number\n\t\t\t})\n\t\t\t.Encode((value) => value) as any as TNumber\n\t},\n\tDate: (property?: DateOptions) => {\n\t\tconst schema = Type.Date(property)\n\n\t\treturn t\n\t\t\t.Transform(\n\t\t\t\tt.Union(\n\t\t\t\t\t[\n\t\t\t\t\t\tType.Date(property),\n\t\t\t\t\t\tt.String({\n\t\t\t\t\t\t\tformat: 'date',\n\t\t\t\t\t\t\tdefault: new Date().toISOString()\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tt.String({\n\t\t\t\t\t\t\tformat: 'date-time',\n\t\t\t\t\t\t\tdefault: new Date().toISOString()\n\t\t\t\t\t\t})\n\t\t\t\t\t],\n\t\t\t\t\tproperty\n\t\t\t\t)\n\t\t\t)\n\t\t\t.Decode((value) => {\n\t\t\t\tif (value instanceof Date) return value\n\n\t\t\t\tconst date = new Date(value)\n\n\t\t\t\tif (!Value.Check(schema, date))\n\t\t\t\t\tthrow new ValidationError('property', schema, date)\n\n\t\t\t\treturn date\n\t\t\t})\n\t\t\t.Encode((value) => {\n\t\t\t\tif (typeof value === 'string') return new Date(value)\n\n\t\t\t\treturn value\n\t\t\t}) as any as TDate\n\t},\n\tBooleanString: (property?: SchemaOptions) => {\n\t\tconst schema = Type.Boolean(property)\n\n\t\treturn t\n\t\t\t.Transform(\n\t\t\t\tt.Union(\n\t\t\t\t\t[\n\t\t\t\t\t\tt.String({\n\t\t\t\t\t\t\tformat: 'boolean',\n\t\t\t\t\t\t\tdefault: false\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tt.Boolean(property)\n\t\t\t\t\t],\n\t\t\t\t\tproperty\n\t\t\t\t)\n\t\t\t)\n\t\t\t.Decode((value) => {\n\t\t\t\tif (typeof value === 'string') return value === 'true'\n\n\t\t\t\tif (property && !Value.Check(schema, value))\n\t\t\t\t\tthrow new ValidationError('property', schema, value)\n\n\t\t\t\treturn value\n\t\t\t})\n\t\t\t.Encode((value) => value) as any as TBoolean\n\t},\n\tObjectString: <T extends TProperties = {}>(\n\t\tproperties: T = {} as T,\n\t\toptions?: ObjectOptions\n\t) => {\n\t\tconst schema = t.Object(properties, options)\n\t\tconst defaultValue = JSON.stringify(Value.Create(schema))\n\n\t\treturn t\n\t\t\t.Transform(\n\t\t\t\tt.Union([\n\t\t\t\t\tt.String({\n\t\t\t\t\t\tformat: 'ObjectString',\n\t\t\t\t\t\tdefault: defaultValue\n\t\t\t\t\t}),\n\t\t\t\t\tschema\n\t\t\t\t])\n\t\t\t)\n\t\t\t.Decode((value) => {\n\t\t\t\tif (typeof value === 'string') {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvalue = JSON.parse(value as string)\n\t\t\t\t\t} catch {\n\t\t\t\t\t\tthrow new ValidationError('property', schema, value)\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!Value.Check(schema, value))\n\t\t\t\t\t\tthrow new ValidationError('property', schema, value)\n\n\t\t\t\t\treturn value\n\t\t\t\t}\n\n\t\t\t\treturn value\n\t\t\t})\n\t\t\t.Encode((value) => {\n\t\t\t\tif (typeof value === 'string')\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvalue = JSON.parse(value as string)\n\t\t\t\t\t} catch {\n\t\t\t\t\t\tthrow new ValidationError('property', schema, value)\n\t\t\t\t\t}\n\n\t\t\t\tif (!Value.Check(schema, value))\n\t\t\t\t\tthrow new ValidationError('property', schema, value)\n\n\t\t\t\treturn JSON.stringify(value)\n\t\t\t}) as any as TObject<T>\n\t},\n\tFile,\n\tFiles: (options: ElysiaTypeOptions.Files = {}) =>\n\t\tt\n\t\t\t.Transform(Files(options))\n\t\t\t.Decode((value) => {\n\t\t\t\tif (Array.isArray(value)) return value\n\t\t\t\treturn [value]\n\t\t\t})\n\t\t\t.Encode((value) => value),\n\tNullable: <T extends TSchema>(schema: T): TUnion<[T, TNull]> =>\n\t\tt.Union([t.Null(), schema]) as any,\n\t/**\n\t * Allow Optional, Nullable and Undefined\n\t */\n\tMaybeEmpty: <T extends TSchema>(schema: T): TUnion<[T, TUndefined]> =>\n\t\tt.Union([t.Null(), t.Undefined(), schema]) as any,\n\tCookie: <T extends TProperties>(\n\t\tproperties: T,\n\t\t{\n\t\t\tdomain,\n\t\t\texpires,\n\t\t\thttpOnly,\n\t\t\tmaxAge,\n\t\t\tpath,\n\t\t\tpriority,\n\t\t\tsameSite,\n\t\t\tsecure,\n\t\t\tsecrets,\n\t\t\tsign,\n\t\t\t...options\n\t\t}: ElysiaTypeOptions.CookieValidatorOption<T> = {}\n\t) => {\n\t\tconst v = t.Object(properties, options)\n\n\t\tv.config = {\n\t\t\tdomain,\n\t\t\texpires,\n\t\t\thttpOnly,\n\t\t\tmaxAge,\n\t\t\tpath,\n\t\t\tpriority,\n\t\t\tsameSite,\n\t\t\tsecure,\n\t\t\tsecrets,\n\t\t\tsign\n\t\t}\n\n\t\treturn v\n\t}\n} as const\n\nexport type TCookie = (typeof ElysiaType)['Cookie']\n\ndeclare module '@sinclair/typebox' {\n\tinterface JavaScriptTypeBuilder {\n\t\tBooleanString: typeof ElysiaType.BooleanString\n\t\tObjectString: typeof ElysiaType.ObjectString\n\t\t// @ts-ignore\n\t\tNumeric: typeof ElysiaType.Numeric\n\t\t// @ts-ignore\n\t\tFile: typeof ElysiaType.File\n\t\t// @ts-ignore\n\t\tFiles: typeof ElysiaType.Files\n\t\tNullable: typeof ElysiaType.Nullable\n\t\tMaybeEmpty: typeof ElysiaType.MaybeEmpty\n\t\tCookie: typeof ElysiaType.Cookie\n\t}\n\n\tinterface SchemaOptions {\n\t\terror?:\n\t\t\t| string\n\t\t\t| ((\n\t\t\t\t\ttype: string,\n\t\t\t\t\tvalidator: TypeCheck<any>,\n\t\t\t\t\tvalue: unknown\n\t\t\t  ) => string | void)\n\t}\n}\n\n/**\n * A Boolean string\n *\n * Will be parse to Boolean\n */\nt.BooleanString = ElysiaType.BooleanString\n\nt.ObjectString = ElysiaType.ObjectString\n\n/**\n * A Numeric string\n *\n * Will be parse to Number\n */\nt.Numeric = ElysiaType.Numeric\n\nt.File = (arg = {}) =>\n\tElysiaType.File({\n\t\tdefault: 'File',\n\t\t...arg,\n\t\textension: arg?.type,\n\t\ttype: 'string',\n\t\tformat: 'binary'\n\t})\n\nt.Files = (arg = {}) =>\n\tElysiaType.Files({\n\t\t...arg,\n\t\telysiaMeta: 'Files',\n\t\tdefault: 'Files',\n\t\textension: arg?.type,\n\t\ttype: 'array',\n\t\titems: {\n\t\t\t...arg,\n\t\t\tdefault: 'Files',\n\t\t\ttype: 'string',\n\t\t\tformat: 'binary'\n\t\t}\n\t})\n\nt.Nullable = (schema) => ElysiaType.Nullable(schema)\nt.MaybeEmpty = ElysiaType.MaybeEmpty\n\nt.Cookie = ElysiaType.Cookie\nt.Date = ElysiaType.Date\n\nexport { t }\n\nexport {\n\tTypeSystemPolicy,\n\tTypeSystem,\n\tTypeSystemDuplicateFormat,\n\tTypeSystemDuplicateTypeKind\n} from '@sinclair/typebox/system'\nexport { TypeCompiler, TypeCheck } from '@sinclair/typebox/compiler'\n\n// type Template =\n// \t| string\n// \t| number\n// \t| bigint\n// \t| boolean\n// \t| StringConstructor\n// \t| NumberConstructor\n// \t| undefined\n\n// type Join<A> = A extends Readonly<[infer First, ...infer Rest]>\n// \t? (\n// \t\t\tFirst extends Readonly<Template[]>\n// \t\t\t\t? First[number]\n// \t\t\t\t: First extends StringConstructor\n// \t\t\t\t? string\n// \t\t\t\t: First extends NumberConstructor\n// \t\t\t\t? `${number}`\n// \t\t\t\t: First\n// \t  ) extends infer A\n// \t\t? Rest extends []\n// \t\t\t? A extends undefined\n// \t\t\t\t? NonNullable<A> | ''\n// \t\t\t\t: A\n// \t\t\t: // @ts-ignore\n// \t\t\tA extends undefined\n// \t\t\t? `${NonNullable<A>}${Join<Rest>}` | ''\n// \t\t\t: // @ts-ignore\n// \t\t\t  `${A}${Join<Rest>}`\n// \t\t: ''\n// \t: ''\n\n// const template = <\n// \tconst T extends Readonly<(Template | Readonly<Template[]>)[]>\n// >(\n// \t...p: T\n// ): Join<T> => {\n// \treturn a as any\n// }\n\n// const create =\n// \t<const T extends string>(t: T): ((t: T) => void) =>\n// \t(t) =>\n// \t\tt\n\n// const optional = <\n// \tconst T extends Readonly<(Template | Readonly<Template[]>)[]>\n// >(\n// \t...p: T\n// ): T | undefined => {\n// \treturn undefined\n// }\n\n// template.optional = optional\n\n// const hi = create(\n// \ttemplate(\n// \t\t['seminar', 'millennium'],\n// \t\t':',\n// \t\t['Rio', 'Yuuka', 'Noa', 'Koyuki'],\n// \t\ttemplate.optional(template(',', ['Rio', 'Yuuka', 'Noa', 'Koyuki'])),\n// \t\ttemplate.optional(template(',', ['Rio', 'Yuuka', 'Noa', 'Koyuki'])),\n// \t\ttemplate.optional(template(',', ['Rio', 'Yuuka', 'Noa', 'Koyuki']))\n// \t)\n// )\n\n// hi(`seminar:Noa,Koyuki,Yuuka`)\n\n// const a = TypeCompiler.Compile(t.String())\n\n// console.log(v.Decode.toString())\n\n// const T = t.Transform(v.schema)\n// \t.Decode((value) => new Date(value)) // required: number to Date\n// \t.Encode((value) => value.getTime()) // required: Date to number\n\n// const decoded = Value.Decode(T, 0) // const decoded = Date(1970-01-01T00:00:00.000Z)\n// const encoded = Value.Encode(T, decoded)\n",
  "/**\n * ? Fork of ajv-formats without ajv as dependencies\n *\n * @see https://github.com/ajv-validator/ajv-formats/blob/master/src/formats.ts\n **/\n\n/* eslint-disable no-control-regex */\nexport type FormatName =\n\t| 'date'\n\t| 'time'\n\t| 'date-time'\n\t| 'iso-time'\n\t| 'iso-date-time'\n\t| 'duration'\n\t| 'uri'\n\t| 'uri-reference'\n\t| 'uri-template'\n\t| 'url'\n\t| 'email'\n\t| 'hostname'\n\t| 'ipv4'\n\t| 'ipv6'\n\t| 'regex'\n\t| 'uuid'\n\t| 'json-pointer'\n\t| 'json-pointer-uri-fragment'\n\t| 'relative-json-pointer'\n\t| 'byte'\n\t| 'int32'\n\t| 'int64'\n\t| 'float'\n\t| 'double'\n\t| 'password'\n\t| 'binary'\n\nexport const fullFormats = {\n\t// date: http://tools.ietf.org/html/rfc3339#section-5.6\n\tdate,\n\t// date-time: http://tools.ietf.org/html/rfc3339#section-5.6\n\ttime: getTime(true),\n\t'date-time': getDateTime(true),\n\t'iso-time': getTime(false),\n\t'iso-date-time': getDateTime(false),\n\t// duration: https://tools.ietf.org/html/rfc3339#appendix-A\n\tduration:\n\t\t/^P(?!$)((\\d+Y)?(\\d+M)?(\\d+D)?(T(?=\\d)(\\d+H)?(\\d+M)?(\\d+S)?)?|(\\d+W)?)$/,\n\turi,\n\t'uri-reference':\n\t\t/^(?:[a-z][a-z0-9+\\-.]*:)?(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'\"()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\\?(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,\n\t// uri-template: https://tools.ietf.org/html/rfc6570\n\t'uri-template':\n\t\t/^(?:(?:[^\\x00-\\x20\"'<>%\\\\^`{|}]|%[0-9a-f]{2})|\\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?)*\\})*$/i,\n\t// For the source: https://gist.github.com/dperini/729294\n\t// For test cases: https://mathiasbynens.be/demo/url-regex\n\turl: /^(?:https?|ftp):\\/\\/(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)(?:\\.(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)*(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/iu,\n\temail: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,\n\thostname:\n\t\t/^(?=.{1,253}\\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\\.?$/i,\n\t// optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html\n\tipv4: /^(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)$/,\n\tipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))$/i,\n\tregex,\n\t// uuid: http://tools.ietf.org/html/rfc4122\n\tuuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,\n\t// JSON-pointer: https://tools.ietf.org/html/rfc6901\n\t// uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A\n\t'json-pointer': /^(?:\\/(?:[^~/]|~0|~1)*)*$/,\n\t'json-pointer-uri-fragment':\n\t\t/^#(?:\\/(?:[a-z0-9_\\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,\n\t// relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00\n\t'relative-json-pointer': /^(?:0|[1-9][0-9]*)(?:#|(?:\\/(?:[^~/]|~0|~1)*)*)$/,\n\t// the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types\n\t// byte: https://github.com/miguelmota/is-base64\n\tbyte,\n\t// signed 32 bit integer\n\tint32: { type: 'number', validate: validateInt32 },\n\t// signed 64 bit integer\n\tint64: { type: 'number', validate: validateInt64 },\n\t// C-type float\n\tfloat: { type: 'number', validate: validateNumber },\n\t// C-type double\n\tdouble: { type: 'number', validate: validateNumber },\n\t// hint to the UI to hide input strings\n\tpassword: true,\n\t// unchecked string payload\n\tbinary: true\n} as const\n\nfunction isLeapYear(year: number): boolean {\n\t// https://tools.ietf.org/html/rfc3339#appendix-C\n\treturn year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0)\n}\n\nconst DATE = /^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/\nconst DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\nfunction date(str: string): boolean {\n\t// full-date from http://tools.ietf.org/html/rfc3339#section-5.6\n\tconst matches: string[] | null = DATE.exec(str)\n\tif (!matches) return false\n\tconst year: number = +matches[1]\n\tconst month: number = +matches[2]\n\tconst day: number = +matches[3]\n\treturn (\n\t\tmonth >= 1 &&\n\t\tmonth <= 12 &&\n\t\tday >= 1 &&\n\t\tday <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month])\n\t)\n}\n\nconst TIME = /^(\\d\\d):(\\d\\d):(\\d\\d(?:\\.\\d+)?)(z|([+-])(\\d\\d)(?::?(\\d\\d))?)?$/i\n\nfunction getTime(strictTimeZone?: boolean): (str: string) => boolean {\n\treturn function time(str: string): boolean {\n\t\tconst matches: string[] | null = TIME.exec(str)\n\t\tif (!matches) return false\n\t\tconst hr: number = +matches[1]\n\t\tconst min: number = +matches[2]\n\t\tconst sec: number = +matches[3]\n\t\tconst tz: string | undefined = matches[4]\n\t\tconst tzSign: number = matches[5] === '-' ? -1 : 1\n\t\tconst tzH: number = +(matches[6] || 0)\n\t\tconst tzM: number = +(matches[7] || 0)\n\t\tif (tzH > 23 || tzM > 59 || (strictTimeZone && !tz)) return false\n\t\tif (hr <= 23 && min <= 59 && sec < 60) return true\n\t\t// leap second\n\t\tconst utcMin = min - tzM * tzSign\n\t\tconst utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0)\n\t\treturn (\n\t\t\t(utcHr === 23 || utcHr === -1) &&\n\t\t\t(utcMin === 59 || utcMin === -1) &&\n\t\t\tsec < 61\n\t\t)\n\t}\n}\n\nconst DATE_TIME_SEPARATOR = /t|\\s/i\nfunction getDateTime(strictTimeZone?: boolean): (str: string) => boolean {\n\tconst time = getTime(strictTimeZone)\n\n\treturn function date_time(str: string): boolean {\n\t\t// http://tools.ietf.org/html/rfc3339#section-5.6\n\t\tconst dateTime: string[] = str.split(DATE_TIME_SEPARATOR)\n\t\treturn dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1])\n\t}\n}\n\nconst NOT_URI_FRAGMENT = /\\/|:/\nconst URI =\n\t/^(?:[a-z][a-z0-9+\\-.]*:)(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\\?(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i\n\nfunction uri(str: string): boolean {\n\t// http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required \".\"\n\treturn NOT_URI_FRAGMENT.test(str) && URI.test(str)\n}\n\nconst BYTE =\n\t/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm\n\nfunction byte(str: string): boolean {\n\tBYTE.lastIndex = 0\n\treturn BYTE.test(str)\n}\n\nconst MIN_INT32 = -(2 ** 31)\nconst MAX_INT32 = 2 ** 31 - 1\n\nfunction validateInt32(value: number): boolean {\n\treturn Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32\n}\n\nfunction validateInt64(value: number): boolean {\n\t// JSON and javascript max Int is 2**53, so any int that passes isInteger is valid for Int64\n\treturn Number.isInteger(value)\n}\n\nfunction validateNumber(): boolean {\n\treturn true\n}\n\nconst Z_ANCHOR = /[^\\\\]\\\\Z/\nfunction regex(str: string): boolean {\n\tif (Z_ANCHOR.test(str)) return false\n\ttry {\n\t\tnew RegExp(str)\n\t\treturn true\n\t} catch (e) {\n\t\treturn false\n\t}\n}\n\n/**\n * @license\n * \n * MIT License\n * \n * Copyright (c) 2020 Evgeny Poberezkin\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n",
  "import {\n\tDateOptions,\n\tNumberOptions,\n\tTDate,\n\tTUnsafe,\n\tTypeRegistry\n} from '@sinclair/typebox'\nimport { TypeSystem } from '@sinclair/typebox/system'\nimport {\n\tType,\n\ttype SchemaOptions,\n\ttype TNull,\n\ttype TUnion,\n\ttype TSchema,\n\ttype TUndefined,\n\tTProperties,\n\tObjectOptions,\n\tTObject,\n\tTNumber,\n\tTBoolean,\n\tFormatRegistry\n} from '@sinclair/typebox'\n\nimport { type TypeCheck } from '@sinclair/typebox/compiler'\nimport { Value } from '@sinclair/typebox/value'\nimport { fullFormats } from './formats'\n\nimport type { CookieOptions } from './cookies'\nimport { ValidationError } from './error'\nimport type { MaybeArray } from './types'\n\nconst isISO8601 =\n\t/(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))/\nconst isFormalDate =\n\t/(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)\\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s\\d{2}\\s\\d{4}\\s\\d{2}:\\d{2}:\\d{2}\\sGMT(?:\\+|-)\\d{4}\\s\\([^)]+\\)/\nconst isShortenDate =\n\t/^(?:(?:(?:(?:0?[1-9]|[12][0-9]|3[01])[/\\s-](?:0?[1-9]|1[0-2])[/\\s-](?:19|20)\\d{2})|(?:(?:19|20)\\d{2}[/\\s-](?:0?[1-9]|1[0-2])[/\\s-](?:0?[1-9]|[12][0-9]|3[01]))))(?:\\s(?:1[012]|0?[1-9]):[0-5][0-9](?::[0-5][0-9])?(?:\\s[AP]M)?)?$/\n\nconst _validateDate = fullFormats.date\nconst _validateDateTime = fullFormats['date-time']\n\nif (!FormatRegistry.Has('date'))\n\tTypeSystem.Format('date', (value: string) => {\n\t\t// Remove quote from stringified date\n\t\tconst temp = value.replace(/\"/g, '')\n\n\t\tif (\n\t\t\tisISO8601.test(temp) ||\n\t\t\tisFormalDate.test(temp) ||\n\t\t\tisShortenDate.test(temp) ||\n\t\t\t_validateDate(temp)\n\t\t) {\n\t\t\tconst date = new Date(temp)\n\t\t\tif (!Number.isNaN(date.getTime())) return true\n\t\t}\n\n\t\treturn false\n\t})\n\nif (!FormatRegistry.Has('date-time'))\n\tTypeSystem.Format('date-time', (value: string) => {\n\t\t// Remove quote from stringified date\n\t\tconst temp = value.replace(/\"/g, '')\n\n\t\tif (\n\t\t\tisISO8601.test(temp) ||\n\t\t\tisFormalDate.test(temp) ||\n\t\t\tisShortenDate.test(temp) ||\n\t\t\t_validateDateTime(temp)\n\t\t) {\n\t\t\tconst date = new Date(temp)\n\t\t\tif (!Number.isNaN(date.getTime())) return true\n\t\t}\n\n\t\treturn false\n\t})\n\nObject.entries(fullFormats).forEach((formatEntry) => {\n\tconst [formatName, formatValue] = formatEntry\n\n\tif (!FormatRegistry.Has(formatName)) {\n\t\tif (formatValue instanceof RegExp)\n\t\t\tTypeSystem.Format(formatName, (value) => formatValue.test(value))\n\t\telse if (typeof formatValue === 'function')\n\t\t\tTypeSystem.Format(formatName, formatValue)\n\t}\n})\n\nconst t = Object.assign({}, Type)\n\nexport namespace ElysiaTypeOptions {\n\texport type Numeric = NumberOptions\n\n\texport type FileUnit = number | `${number}${'k' | 'm'}`\n\n\texport interface File extends SchemaOptions {\n\t\ttype?: MaybeArray<\n\t\t\t| (string & {})\n\t\t\t| 'image'\n\t\t\t| 'image/jpeg'\n\t\t\t| 'image/png'\n\t\t\t| 'image/gif'\n\t\t\t| 'image/tiff'\n\t\t\t| 'image/x-icon'\n\t\t\t| 'image/svg'\n\t\t\t| 'image/webp'\n\t\t\t| 'image/avif'\n\t\t\t| 'audio'\n\t\t\t| 'audio/mpeg'\n\t\t\t| 'audio/x-ms-wma'\n\t\t\t| 'audio/vnd.rn-realaudio'\n\t\t\t| 'audio/x-wav'\n\t\t\t| 'video'\n\t\t\t| 'video/mpeg'\n\t\t\t| 'video/mp4'\n\t\t\t| 'video/quicktime'\n\t\t\t| 'video/x-ms-wmv'\n\t\t\t| 'video/x-msvideo'\n\t\t\t| 'video/x-flv'\n\t\t\t| 'video/webm'\n\t\t\t| 'text'\n\t\t\t| 'text/css'\n\t\t\t| 'text/csv'\n\t\t\t| 'text/html'\n\t\t\t| 'text/javascript'\n\t\t\t| 'text/plain'\n\t\t\t| 'text/xml'\n\t\t\t| 'application'\n\t\t\t| 'application/ogg'\n\t\t\t| 'application/pdf'\n\t\t\t| 'application/xhtml'\n\t\t\t| 'application/html'\n\t\t\t| 'application/json'\n\t\t\t| 'application/ld+json'\n\t\t\t| 'application/xml'\n\t\t\t| 'application/zip'\n\t\t\t| 'font'\n\t\t\t| 'font/woff2'\n\t\t\t| 'font/woff'\n\t\t\t| 'font/ttf'\n\t\t\t| 'font/otf'\n\t\t>\n\t\tminSize?: FileUnit\n\t\tmaxSize?: FileUnit\n\t}\n\n\texport interface Files extends File {\n\t\tminItems?: number\n\t\tmaxItems?: number\n\t}\n\n\texport interface CookieValidatorOption<T extends Object = {}>\n\t\textends ObjectOptions,\n\t\t\tCookieOptions {\n\t\t/**\n\t\t * Secret key for signing cookie\n\t\t *\n\t\t * If array is passed, will use Key Rotation.\n\t\t *\n\t\t * Key rotation is when an encryption key is retired\n\t\t * and replaced by generating a new cryptographic key.\n\t\t */\n\t\tsecrets?: string | string[]\n\t\t/**\n\t\t * Specified cookie name to be signed globally\n\t\t */\n\t\tsign?: Readonly<(keyof T | (string & {}))[]>\n\t}\n}\n\nconst parseFileUnit = (size: ElysiaTypeOptions.FileUnit) => {\n\tif (typeof size === 'string')\n\t\tswitch (size.slice(-1)) {\n\t\t\tcase 'k':\n\t\t\t\treturn +size.slice(0, size.length - 1) * 1024\n\n\t\t\tcase 'm':\n\t\t\t\treturn +size.slice(0, size.length - 1) * 1048576\n\n\t\t\tdefault:\n\t\t\t\treturn +size\n\t\t}\n\n\treturn size\n}\n\nconst validateFile = (options: ElysiaTypeOptions.File, value: any) => {\n\tif (!(value instanceof Blob)) return false\n\n\tif (options.minSize && value.size < parseFileUnit(options.minSize))\n\t\treturn false\n\n\tif (options.maxSize && value.size > parseFileUnit(options.maxSize))\n\t\treturn false\n\n\tif (options.extension)\n\t\tif (typeof options.extension === 'string') {\n\t\t\tif (!value.type.startsWith(options.extension)) return false\n\t\t} else {\n\t\t\tfor (let i = 0; i < options.extension.length; i++)\n\t\t\t\tif (value.type.startsWith(options.extension[i])) return true\n\n\t\t\treturn false\n\t\t}\n\n\treturn true\n}\n\ntype ElysiaFile = (\n\toptions?: Partial<ElysiaTypeOptions.Files> | undefined\n) => TUnsafe<File>\n\nconst File: ElysiaFile =\n\t(TypeRegistry.Get('Files') as unknown as ElysiaFile) ??\n\tTypeSystem.Type<File, ElysiaTypeOptions.File>('File', validateFile)\n\ntype ElysiaFiles = (\n\toptions?: Partial<ElysiaTypeOptions.Files> | undefined\n) => TUnsafe<File[]>\n\nconst Files: ElysiaFiles =\n\t(TypeRegistry.Get('Files') as unknown as ElysiaFiles) ??\n\tTypeSystem.Type<File[], ElysiaTypeOptions.Files>(\n\t\t'Files',\n\t\t(options, value) => {\n\t\t\tif (!Array.isArray(value)) return validateFile(options, value)\n\n\t\t\tif (options.minItems && value.length < options.minItems)\n\t\t\t\treturn false\n\n\t\t\tif (options.maxItems && value.length > options.maxItems)\n\t\t\t\treturn false\n\n\t\t\tfor (let i = 0; i < value.length; i++)\n\t\t\t\tif (!validateFile(options, value[i])) return false\n\n\t\t\treturn true\n\t\t}\n\t)\n\nif (!FormatRegistry.Has('numeric'))\n\tFormatRegistry.Set('numeric', (value) => !!value && !isNaN(+value))\n\nif (!FormatRegistry.Has('boolean'))\n\tFormatRegistry.Set(\n\t\t'boolean',\n\t\t(value) => value === 'true' || value === 'false'\n\t)\n\nif (!FormatRegistry.Has('ObjectString'))\n\tFormatRegistry.Set('ObjectString', (value) => {\n\t\tlet start = value.charCodeAt(0)\n\n\t\t// If starts with ' ', '\\t', '\\n', then trim first\n\t\tif (start === 9 || start === 10 || start === 32)\n\t\t\tstart = value.trimStart().charCodeAt(0)\n\n\t\tif (start !== 123 && start !== 91) return false\n\n\t\ttry {\n\t\t\tJSON.parse(value)\n\n\t\t\treturn true\n\t\t} catch {\n\t\t\treturn false\n\t\t}\n\t})\n\nexport const ElysiaType = {\n\tNumeric: (property?: NumberOptions) => {\n\t\tconst schema = Type.Number(property)\n\n\t\treturn t\n\t\t\t.Transform(\n\t\t\t\tt.Union(\n\t\t\t\t\t[\n\t\t\t\t\t\tt.String({\n\t\t\t\t\t\t\tformat: 'numeric',\n\t\t\t\t\t\t\tdefault: 0\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tt.Number(property)\n\t\t\t\t\t],\n\t\t\t\t\tproperty\n\t\t\t\t)\n\t\t\t)\n\t\t\t.Decode((value) => {\n\t\t\t\tconst number = +value\n\t\t\t\tif (isNaN(number)) return value\n\n\t\t\t\tif (property && !Value.Check(schema, number))\n\t\t\t\t\tthrow new ValidationError('property', schema, number)\n\n\t\t\t\treturn number\n\t\t\t})\n\t\t\t.Encode((value) => value) as any as TNumber\n\t},\n\tDate: (property?: DateOptions) => {\n\t\tconst schema = Type.Date(property)\n\n\t\treturn t\n\t\t\t.Transform(\n\t\t\t\tt.Union(\n\t\t\t\t\t[\n\t\t\t\t\t\tType.Date(property),\n\t\t\t\t\t\tt.String({\n\t\t\t\t\t\t\tformat: 'date',\n\t\t\t\t\t\t\tdefault: new Date().toISOString()\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tt.String({\n\t\t\t\t\t\t\tformat: 'date-time',\n\t\t\t\t\t\t\tdefault: new Date().toISOString()\n\t\t\t\t\t\t})\n\t\t\t\t\t],\n\t\t\t\t\tproperty\n\t\t\t\t)\n\t\t\t)\n\t\t\t.Decode((value) => {\n\t\t\t\tif (value instanceof Date) return value\n\n\t\t\t\tconst date = new Date(value)\n\n\t\t\t\tif (!Value.Check(schema, date))\n\t\t\t\t\tthrow new ValidationError('property', schema, date)\n\n\t\t\t\treturn date\n\t\t\t})\n\t\t\t.Encode((value) => {\n\t\t\t\tif (typeof value === 'string') return new Date(value)\n\n\t\t\t\treturn value\n\t\t\t}) as any as TDate\n\t},\n\tBooleanString: (property?: SchemaOptions) => {\n\t\tconst schema = Type.Boolean(property)\n\n\t\treturn t\n\t\t\t.Transform(\n\t\t\t\tt.Union(\n\t\t\t\t\t[\n\t\t\t\t\t\tt.String({\n\t\t\t\t\t\t\tformat: 'boolean',\n\t\t\t\t\t\t\tdefault: false\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tt.Boolean(property)\n\t\t\t\t\t],\n\t\t\t\t\tproperty\n\t\t\t\t)\n\t\t\t)\n\t\t\t.Decode((value) => {\n\t\t\t\tif (typeof value === 'string') return value === 'true'\n\n\t\t\t\tif (property && !Value.Check(schema, value))\n\t\t\t\t\tthrow new ValidationError('property', schema, value)\n\n\t\t\t\treturn value\n\t\t\t})\n\t\t\t.Encode((value) => value) as any as TBoolean\n\t},\n\tObjectString: <T extends TProperties = {}>(\n\t\tproperties: T = {} as T,\n\t\toptions?: ObjectOptions\n\t) => {\n\t\tconst schema = t.Object(properties, options)\n\t\tconst defaultValue = JSON.stringify(Value.Create(schema))\n\n\t\treturn t\n\t\t\t.Transform(\n\t\t\t\tt.Union([\n\t\t\t\t\tt.String({\n\t\t\t\t\t\tformat: 'ObjectString',\n\t\t\t\t\t\tdefault: defaultValue\n\t\t\t\t\t}),\n\t\t\t\t\tschema\n\t\t\t\t])\n\t\t\t)\n\t\t\t.Decode((value) => {\n\t\t\t\tif (typeof value === 'string') {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvalue = JSON.parse(value as string)\n\t\t\t\t\t} catch {\n\t\t\t\t\t\tthrow new ValidationError('property', schema, value)\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!Value.Check(schema, value))\n\t\t\t\t\t\tthrow new ValidationError('property', schema, value)\n\n\t\t\t\t\treturn value\n\t\t\t\t}\n\n\t\t\t\treturn value\n\t\t\t})\n\t\t\t.Encode((value) => {\n\t\t\t\tif (typeof value === 'string')\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvalue = JSON.parse(value as string)\n\t\t\t\t\t} catch {\n\t\t\t\t\t\tthrow new ValidationError('property', schema, value)\n\t\t\t\t\t}\n\n\t\t\t\tif (!Value.Check(schema, value))\n\t\t\t\t\tthrow new ValidationError('property', schema, value)\n\n\t\t\t\treturn JSON.stringify(value)\n\t\t\t}) as any as TObject<T>\n\t},\n\tFile,\n\tFiles: (options: ElysiaTypeOptions.Files = {}) =>\n\t\tt\n\t\t\t.Transform(Files(options))\n\t\t\t.Decode((value) => {\n\t\t\t\tif (Array.isArray(value)) return value\n\t\t\t\treturn [value]\n\t\t\t})\n\t\t\t.Encode((value) => value),\n\tNullable: <T extends TSchema>(schema: T): TUnion<[T, TNull]> =>\n\t\tt.Union([t.Null(), schema]) as any,\n\t/**\n\t * Allow Optional, Nullable and Undefined\n\t */\n\tMaybeEmpty: <T extends TSchema>(schema: T): TUnion<[T, TUndefined]> =>\n\t\tt.Union([t.Null(), t.Undefined(), schema]) as any,\n\tCookie: <T extends TProperties>(\n\t\tproperties: T,\n\t\t{\n\t\t\tdomain,\n\t\t\texpires,\n\t\t\thttpOnly,\n\t\t\tmaxAge,\n\t\t\tpath,\n\t\t\tpriority,\n\t\t\tsameSite,\n\t\t\tsecure,\n\t\t\tsecrets,\n\t\t\tsign,\n\t\t\t...options\n\t\t}: ElysiaTypeOptions.CookieValidatorOption<T> = {}\n\t) => {\n\t\tconst v = t.Object(properties, options)\n\n\t\tv.config = {\n\t\t\tdomain,\n\t\t\texpires,\n\t\t\thttpOnly,\n\t\t\tmaxAge,\n\t\t\tpath,\n\t\t\tpriority,\n\t\t\tsameSite,\n\t\t\tsecure,\n\t\t\tsecrets,\n\t\t\tsign\n\t\t}\n\n\t\treturn v\n\t}\n} as const\n\nexport type TCookie = (typeof ElysiaType)['Cookie']\n\ndeclare module '@sinclair/typebox' {\n\tinterface JavaScriptTypeBuilder {\n\t\tBooleanString: typeof ElysiaType.BooleanString\n\t\tObjectString: typeof ElysiaType.ObjectString\n\t\t// @ts-ignore\n\t\tNumeric: typeof ElysiaType.Numeric\n\t\t// @ts-ignore\n\t\tFile: typeof ElysiaType.File\n\t\t// @ts-ignore\n\t\tFiles: typeof ElysiaType.Files\n\t\tNullable: typeof ElysiaType.Nullable\n\t\tMaybeEmpty: typeof ElysiaType.MaybeEmpty\n\t\tCookie: typeof ElysiaType.Cookie\n\t}\n\n\tinterface SchemaOptions {\n\t\terror?:\n\t\t\t| string\n\t\t\t| ((\n\t\t\t\t\ttype: string,\n\t\t\t\t\tvalidator: TypeCheck<any>,\n\t\t\t\t\tvalue: unknown\n\t\t\t  ) => string | void)\n\t}\n}\n\n/**\n * A Boolean string\n *\n * Will be parse to Boolean\n */\nt.BooleanString = ElysiaType.BooleanString\n\nt.ObjectString = ElysiaType.ObjectString\n\n/**\n * A Numeric string\n *\n * Will be parse to Number\n */\nt.Numeric = ElysiaType.Numeric\n\nt.File = (arg = {}) =>\n\tElysiaType.File({\n\t\tdefault: 'File',\n\t\t...arg,\n\t\textension: arg?.type,\n\t\ttype: 'string',\n\t\tformat: 'binary'\n\t})\n\nt.Files = (arg = {}) =>\n\tElysiaType.Files({\n\t\t...arg,\n\t\telysiaMeta: 'Files',\n\t\tdefault: 'Files',\n\t\textension: arg?.type,\n\t\ttype: 'array',\n\t\titems: {\n\t\t\t...arg,\n\t\t\tdefault: 'Files',\n\t\t\ttype: 'string',\n\t\t\tformat: 'binary'\n\t\t}\n\t})\n\nt.Nullable = (schema) => ElysiaType.Nullable(schema)\nt.MaybeEmpty = ElysiaType.MaybeEmpty\n\nt.Cookie = ElysiaType.Cookie\nt.Date = ElysiaType.Date\n\nexport { t }\n\nexport {\n\tTypeSystemPolicy,\n\tTypeSystem,\n\tTypeSystemDuplicateFormat,\n\tTypeSystemDuplicateTypeKind\n} from '@sinclair/typebox/system'\nexport { TypeCompiler, TypeCheck } from '@sinclair/typebox/compiler'\n\n// type Template =\n// \t| string\n// \t| number\n// \t| bigint\n// \t| boolean\n// \t| StringConstructor\n// \t| NumberConstructor\n// \t| undefined\n\n// type Join<A> = A extends Readonly<[infer First, ...infer Rest]>\n// \t? (\n// \t\t\tFirst extends Readonly<Template[]>\n// \t\t\t\t? First[number]\n// \t\t\t\t: First extends StringConstructor\n// \t\t\t\t? string\n// \t\t\t\t: First extends NumberConstructor\n// \t\t\t\t? `${number}`\n// \t\t\t\t: First\n// \t  ) extends infer A\n// \t\t? Rest extends []\n// \t\t\t? A extends undefined\n// \t\t\t\t? NonNullable<A> | ''\n// \t\t\t\t: A\n// \t\t\t: // @ts-ignore\n// \t\t\tA extends undefined\n// \t\t\t? `${NonNullable<A>}${Join<Rest>}` | ''\n// \t\t\t: // @ts-ignore\n// \t\t\t  `${A}${Join<Rest>}`\n// \t\t: ''\n// \t: ''\n\n// const template = <\n// \tconst T extends Readonly<(Template | Readonly<Template[]>)[]>\n// >(\n// \t...p: T\n// ): Join<T> => {\n// \treturn a as any\n// }\n\n// const create =\n// \t<const T extends string>(t: T): ((t: T) => void) =>\n// \t(t) =>\n// \t\tt\n\n// const optional = <\n// \tconst T extends Readonly<(Template | Readonly<Template[]>)[]>\n// >(\n// \t...p: T\n// ): T | undefined => {\n// \treturn undefined\n// }\n\n// template.optional = optional\n\n// const hi = create(\n// \ttemplate(\n// \t\t['seminar', 'millennium'],\n// \t\t':',\n// \t\t['Rio', 'Yuuka', 'Noa', 'Koyuki'],\n// \t\ttemplate.optional(template(',', ['Rio', 'Yuuka', 'Noa', 'Koyuki'])),\n// \t\ttemplate.optional(template(',', ['Rio', 'Yuuka', 'Noa', 'Koyuki'])),\n// \t\ttemplate.optional(template(',', ['Rio', 'Yuuka', 'Noa', 'Koyuki']))\n// \t)\n// )\n\n// hi(`seminar:Noa,Koyuki,Yuuka`)\n\n// const a = TypeCompiler.Compile(t.String())\n\n// console.log(v.Decode.toString())\n\n// const T = t.Transform(v.schema)\n// \t.Decode((value) => new Date(value)) // required: number to Date\n// \t.Encode((value) => value.getTime()) // required: Date to number\n\n// const decoded = Value.Decode(T, 0) // const decoded = Date(1970-01-01T00:00:00.000Z)\n// const encoded = Value.Encode(T, decoded)\n",
  "import type { Serve, Server, ServerWebSocket } from 'bun'\n\nimport { Memoirist } from 'memoirist'\nimport EventEmitter from 'eventemitter3'\nimport { type Static, type TSchema } from '@sinclair/typebox'\n\nimport { createTraceListener } from './trace'\nimport type { Context } from './context'\n\nimport { t, TypeCheck } from './type-system'\nimport { sucrose, sucroseTrace, type Sucrose } from './sucrose'\n\nimport { ElysiaWS, websocket } from './ws'\nimport type { WS } from './ws/types'\n\nimport {\n\tcloneInference,\n\tfnToContainer,\n\tlocalHookToLifeCycleStore,\n\tmergeDeep,\n\tPromiseGroup\n} from './utils'\nimport {\n\tcomposeHandler,\n\tcomposeGeneralHandler,\n\tcomposeErrorHandler,\n\tjitRoute\n} from './compose'\nimport {\n\tmergeHook,\n\tgetSchemaValidator,\n\tgetResponseSchemaValidator,\n\tchecksum,\n\tmergeLifeCycle,\n\tfilterGlobalHook,\n\tasHookType,\n\ttraceBackMacro,\n\treplaceUrlPath,\n\tisNumericString,\n\tcreateMacroManager,\n\tgetCookieValidator\n} from './utils'\n\nimport {\n\tcreateDynamicErrorHandler,\n\tcreateDynamicHandler,\n\ttype DynamicHandler\n} from './dynamic-handle'\n\nimport {\n\tERROR_CODE,\n\tisProduction,\n\tValidationError,\n\ttype ParseError,\n\ttype NotFoundError,\n\ttype InternalServerError\n} from './error'\n\nimport type {\n\tElysiaConfig,\n\tSingletonBase,\n\tDefinitionBase,\n\tHandler,\n\tComposedHandler,\n\tInputSchema,\n\tLocalHook,\n\tMergeSchema,\n\tRouteSchema,\n\tUnwrapRoute,\n\tInternalRoute,\n\tHTTPMethod,\n\tSchemaValidator,\n\tVoidHandler,\n\tPreHandler,\n\tBodyHandler,\n\tOptionalHandler,\n\tAfterHandler,\n\tErrorHandler,\n\tLifeCycleStore,\n\tMaybePromise,\n\tPrettify,\n\tPrettify2,\n\tListenCallback,\n\tAddPrefix,\n\tAddSuffix,\n\tAddPrefixCapitalize,\n\tAddSuffixCapitalize,\n\tTraceReporter,\n\tTraceHandler,\n\tMaybeArray,\n\tGracefulHandler,\n\tGetPathParameter,\n\tMapResponse,\n\tChecksum,\n\tMacroManager,\n\tBaseMacro,\n\tMacroToProperty,\n\tTransformHandler,\n\tMetadataBase,\n\tRouteBase,\n\tCreateEden,\n\tComposeElysiaResponse,\n\tInlineHandler,\n\tHookContainer,\n\tLifeCycleType,\n\tMacroQueue,\n\tEphemeralType,\n\tExcludeElysiaResponse\n} from './types'\nimport { isNotEmpty } from './handler'\n\ntype AnyElysia = Elysia<any, any, any, any, any, any, any, any>\n\n/**\n * ### Elysia Server\n * Main instance to create web server using Elysia\n *\n * ---\n * @example\n * ```typescript\n * import { Elysia } from 'elysia'\n *\n * new Elysia()\n *     .get(\"/\", () => \"Hello\")\n *     .listen(3000)\n * ```\n */\nexport default class Elysia<\n\tconst in out BasePath extends string = '',\n\tconst in out Scoped extends boolean = false,\n\tconst in out Singleton extends SingletonBase = {\n\t\tdecorator: {}\n\t\tstore: {}\n\t\tderive: {}\n\t\tresolve: {}\n\t},\n\tconst in out Definitions extends DefinitionBase = {\n\t\ttype: {}\n\t\terror: {}\n\t},\n\tconst in out Metadata extends MetadataBase = {\n\t\tschema: {}\n\t\tmacro: {}\n\t},\n\tconst out Routes extends RouteBase = {},\n\t// ? scoped\n\tconst in out Ephemeral extends EphemeralType = {\n\t\tderive: {}\n\t\tresolve: {}\n\t\tschema: {}\n\t},\n\t// ? local\n\tconst in out Volatile extends EphemeralType = {\n\t\tderive: {}\n\t\tresolve: {}\n\t\tschema: {}\n\t}\n> {\n\tconfig: ElysiaConfig<BasePath, Scoped>\n\n\tserver: Server | null = null\n\tprivate dependencies: Record<string, Checksum[]> = {}\n\tprivate reporter: TraceReporter = new EventEmitter()\n\n\t_routes: Routes = {} as any\n\n\t_types = {\n\t\tPrefix: '' as BasePath,\n\t\tScoped: false as Scoped,\n\t\tSingleton: {} as Singleton,\n\t\tDefinitions: {} as Definitions,\n\t\tMetadata: {} as Metadata\n\t}\n\n\t_ephemeral = {} as Ephemeral\n\t_volatile = {} as Volatile\n\n\tprotected singleton = {\n\t\tdecorator: {},\n\t\tstore: {},\n\t\tderive: {},\n\t\tresolve: {}\n\t} as Singleton\n\n\tget store(): Singleton['store'] {\n\t\treturn this.singleton.store\n\t}\n\n\tget decorator(): Singleton['decorator'] {\n\t\treturn this.singleton.decorator\n\t}\n\n\tget _scoped() {\n\t\treturn this.config.scoped as Scoped\n\t}\n\n\tprotected definitions = {\n\t\ttype: {} as Record<string, TSchema>,\n\t\terror: {} as Record<string, Error>\n\t}\n\n\tprotected extender = {\n\t\tmacros: <MacroQueue[]>[]\n\t}\n\n\tprotected validator: SchemaValidator | null = null\n\n\tevent: LifeCycleStore = {\n\t\tstart: [],\n\t\trequest: [],\n\t\tparse: [],\n\t\ttransform: [],\n\t\tbeforeHandle: [],\n\t\tafterHandle: [],\n\t\tmapResponse: [],\n\t\tonResponse: [],\n\t\ttrace: [],\n\t\terror: [],\n\t\tstop: []\n\t}\n\n\ttelemetry = {\n\t\tstack: undefined as string | undefined\n\t}\n\n\trouter = {\n\t\thttp: new Memoirist<ComposedHandler>(),\n\t\tws: new Memoirist<ComposedHandler>(),\n\t\t// Use in non-AOT mode\n\t\tdynamic: new Memoirist<DynamicHandler>(),\n\t\tstatic: {\n\t\t\thttp: {\n\t\t\t\thandlers: [] as ComposedHandler[],\n\t\t\t\tvariables: '',\n\t\t\t\tmap: {} as Record<\n\t\t\t\t\tstring,\n\t\t\t\t\t{\n\t\t\t\t\t\tcode: string\n\t\t\t\t\t\tall?: string\n\t\t\t\t\t}\n\t\t\t\t>,\n\t\t\t\tall: ''\n\t\t\t},\n\t\t\t// Static WS Router is consists of pathname and websocket handler index to compose\n\t\t\tws: {} as Record<string, number>\n\t\t},\n\t\thistory: [] as InternalRoute[]\n\t}\n\n\tprotected inference: {\n\t\tevent: Sucrose.Inference\n\t\ttrace: Sucrose.TraceInference\n\t} = {\n\t\tevent: {\n\t\t\tbody: false,\n\t\t\tcookie: false,\n\t\t\theaders: false,\n\t\t\tqueries: [],\n\t\t\tquery: false,\n\t\t\tset: false,\n\t\t\tunknownQueries: false\n\t\t},\n\t\ttrace: {\n\t\t\trequest: false,\n\t\t\tparse: false,\n\t\t\ttransform: false,\n\t\t\thandle: false,\n\t\t\tbeforeHandle: false,\n\t\t\tafterHandle: false,\n\t\t\terror: false,\n\t\t\tcontext: false,\n\t\t\tstore: false,\n\t\t\tset: false\n\t\t}\n\t}\n\n\tprivate promisedModules = new PromiseGroup()\n\n\tconstructor(config?: ElysiaConfig<BasePath, Scoped>) {\n\t\tif (config?.tags) {\n\t\t\tif (!config.detail)\n\t\t\t\tconfig.detail = {\n\t\t\t\t\ttags: config.tags\n\t\t\t\t}\n\t\t\telse config.detail.tags = config.tags\n\t\t}\n\n\t\tthis.config = {\n\t\t\tforceErrorEncapsulation: true,\n\t\t\tprefix: '',\n\t\t\taot: true,\n\t\t\tstrictPath: false,\n\t\t\tglobal: false,\n\t\t\tcookie: {},\n\t\t\tanalytic: false,\n\t\t\t...config,\n\t\t\texperimental: config?.experimental ?? {},\n\t\t\tseed: config?.seed === undefined ? '' : config?.seed\n\t\t} as any\n\n\t\tif (config?.analytic && (config?.name || config?.seed !== undefined))\n\t\t\tthis.telemetry.stack = new Error().stack\n\t}\n\n\tprivate getServer() {\n\t\treturn this.server\n\t}\n\n\tget routes(): InternalRoute[] {\n\t\treturn this.router.history\n\t}\n\n\tprotected routeTree = new Map<string, number>()\n\n\tprivate applyMacro(\n\t\tlocalHook: LocalHook<any, any, any, any, any, any, any>\n\t) {\n\t\tif (this.extender.macros.length) {\n\t\t\tconst manage = createMacroManager({\n\t\t\t\tglobalHook: this.event,\n\t\t\t\tlocalHook\n\t\t\t})\n\n\t\t\tconst manager: MacroManager = {\n\t\t\t\tevents: {\n\t\t\t\t\tglobal: this.event,\n\t\t\t\t\tlocal: localHook\n\t\t\t\t},\n\t\t\t\tonParse: manage('parse') as any,\n\t\t\t\tonTransform: manage('transform') as any,\n\t\t\t\tonBeforeHandle: manage('beforeHandle') as any,\n\t\t\t\tonAfterHandle: manage('afterHandle') as any,\n\t\t\t\tonResponse: manage('onResponse') as any,\n\t\t\t\tmapResponse: manage('mapResponse') as any,\n\t\t\t\tonError: manage('error') as any\n\t\t\t}\n\n\t\t\tfor (const macro of this.extender.macros)\n\t\t\t\ttraceBackMacro(macro.fn(manager), localHook)\n\t\t}\n\t}\n\n\tprivate add(\n\t\tmethod: HTTPMethod,\n\t\tpath: string,\n\t\thandle: Handler<any, any, any> | any,\n\t\tlocalHook?: LocalHook<any, any, any, any, any, any>,\n\t\t{ allowMeta = false, skipPrefix = false } = {\n\t\t\tallowMeta: false as boolean | undefined,\n\t\t\tskipPrefix: false as boolean | undefined\n\t\t}\n\t) {\n\t\tlocalHook = localHookToLifeCycleStore(localHook)\n\n\t\tif (path !== '' && path.charCodeAt(0) !== 47) path = '/' + path\n\n\t\tif (this.config.prefix && !skipPrefix && !this.config.scoped)\n\t\t\tpath = this.config.prefix + path\n\n\t\tif (localHook?.type)\n\t\t\tswitch (localHook.type) {\n\t\t\t\tcase 'text':\n\t\t\t\t\tlocalHook.type = 'text/plain'\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'json':\n\t\t\t\t\tlocalHook.type = 'application/json'\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'formdata':\n\t\t\t\t\tlocalHook.type = 'multipart/form-data'\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'urlencoded':\n\t\t\t\t\tlocalHook.type = 'application/x-www-form-urlencoded'\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'arrayBuffer':\n\t\t\t\t\tlocalHook.type = 'application/octet-stream'\n\t\t\t\t\tbreak\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak\n\t\t\t}\n\n\t\tconst models = this.definitions.type\n\n\t\tlet _body: TypeCheck<any> | undefined,\n\t\t\t_headers: TypeCheck<any> | undefined,\n\t\t\t_params: TypeCheck<any> | undefined,\n\t\t\t_query: TypeCheck<any> | undefined,\n\t\t\t_cookie: TypeCheck<any> | undefined,\n\t\t\t_response:\n\t\t\t\t| TypeCheck<any>\n\t\t\t\t| Record<string, TypeCheck<any>>\n\t\t\t\t| undefined\n\n\t\t// ? Clone is need because of JIT, so the context doesn't switch between instance\n\t\tconst dynamic = !this.config.aot\n\n\t\tconst cloned = {\n\t\t\tbody: localHook?.body ?? (this.validator?.body as any),\n\t\t\theaders: localHook?.headers ?? (this.validator?.headers as any),\n\t\t\tparams: localHook?.params ?? (this.validator?.params as any),\n\t\t\tquery: localHook?.query ?? (this.validator?.query as any),\n\t\t\tcookie: localHook?.cookie ?? (this.validator?.cookie as any),\n\t\t\tresponse: localHook?.response ?? (this.validator?.response as any)\n\t\t}\n\n\t\tconst cookieValidator = () =>\n\t\t\tcloned.cookie\n\t\t\t\t? getCookieValidator({\n\t\t\t\t\t\tvalidator: cloned.cookie,\n\t\t\t\t\t\tdefaultConfig: this.config.cookie,\n\t\t\t\t\t\tconfig: cloned.cookie?.config ?? {},\n\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\tmodels\n\t\t\t\t\t})\n\t\t\t\t: undefined\n\n\t\tconst normalize = this.config.normalize\n\n\t\tconst validator =\n\t\t\tthis.config.precompile === true ||\n\t\t\t(typeof this.config.precompile === 'object' &&\n\t\t\t\tthis.config.precompile.schema === true)\n\t\t\t\t? {\n\t\t\t\t\t\tbody: getSchemaValidator(cloned.body, {\n\t\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\t\tmodels,\n\t\t\t\t\t\t\tnormalize\n\t\t\t\t\t\t}),\n\t\t\t\t\t\theaders: getSchemaValidator(cloned.headers, {\n\t\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\t\tmodels,\n\t\t\t\t\t\t\tadditionalProperties: true\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tparams: getSchemaValidator(cloned.params, {\n\t\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\t\tmodels\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tquery: getSchemaValidator(cloned.query, {\n\t\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\t\tmodels,\n\t\t\t\t\t\t\tnormalize\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tcookie: cookieValidator(),\n\t\t\t\t\t\tresponse: getResponseSchemaValidator(cloned.response, {\n\t\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\t\tmodels,\n\t\t\t\t\t\t\tnormalize\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t: ({\n\t\t\t\t\t\tget body() {\n\t\t\t\t\t\t\tif (_body) return _body\n\n\t\t\t\t\t\t\treturn (_body = getSchemaValidator(cloned.body, {\n\t\t\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\t\t\tmodels,\n\t\t\t\t\t\t\t\tnormalize\n\t\t\t\t\t\t\t}))\n\t\t\t\t\t\t},\n\t\t\t\t\t\tget headers() {\n\t\t\t\t\t\t\tif (_headers) return _headers\n\n\t\t\t\t\t\t\treturn getSchemaValidator(cloned.headers, {\n\t\t\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\t\t\tmodels,\n\t\t\t\t\t\t\t\tadditionalProperties: true\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t},\n\t\t\t\t\t\tget params() {\n\t\t\t\t\t\t\tif (_params) return _params\n\n\t\t\t\t\t\t\treturn (_params = getSchemaValidator(\n\t\t\t\t\t\t\t\tcloned.params,\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\t\t\t\tmodels\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t))\n\t\t\t\t\t\t},\n\t\t\t\t\t\tget query() {\n\t\t\t\t\t\t\tif (_query) return _query\n\n\t\t\t\t\t\t\treturn (_query = getSchemaValidator(cloned.query, {\n\t\t\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\t\t\tmodels\n\t\t\t\t\t\t\t}))\n\t\t\t\t\t\t},\n\t\t\t\t\t\tget cookie() {\n\t\t\t\t\t\t\tif (_cookie) return _cookie\n\n\t\t\t\t\t\t\treturn (_cookie = cookieValidator())\n\t\t\t\t\t\t},\n\t\t\t\t\t\tget response() {\n\t\t\t\t\t\t\tif (_response) return _response\n\n\t\t\t\t\t\t\treturn (_response = getResponseSchemaValidator(\n\t\t\t\t\t\t\t\tcloned.response,\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\t\t\t\tmodels,\n\t\t\t\t\t\t\t\t\tnormalize\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t))\n\t\t\t\t\t\t}\n\t\t\t\t\t} as any)\n\n\t\tconst loosePath = path.endsWith('/')\n\t\t\t? path.slice(0, path.length - 1)\n\t\t\t: path + '/'\n\n\t\t// ! Init default [] for hooks if undefined\n\t\tlocalHook = mergeHook(localHook, {}, { allowMacro: true })\n\n\t\tif (localHook.tags) {\n\t\t\tif (!localHook.detail)\n\t\t\t\tlocalHook.detail = {\n\t\t\t\t\ttags: localHook.tags\n\t\t\t\t}\n\t\t\telse localHook.detail.tags = localHook.tags\n\t\t}\n\n\t\tif (isNotEmpty(this.config.detail))\n\t\t\tlocalHook.detail = mergeDeep(\n\t\t\t\tObject.assign({}, this.config.detail!),\n\t\t\t\tlocalHook.detail\n\t\t\t)\n\n\t\tthis.applyMacro(localHook)\n\n\t\tconst hooks = mergeHook(this.event, localHook)\n\n\t\tif (this.config.aot === false) {\n\t\t\tthis.router.dynamic.add(method, path, {\n\t\t\t\tvalidator,\n\t\t\t\thooks,\n\t\t\t\tcontent: localHook?.type as string,\n\t\t\t\thandle\n\t\t\t})\n\n\t\t\tif (this.config.strictPath === false) {\n\t\t\t\tthis.router.dynamic.add(method, loosePath, {\n\t\t\t\t\tvalidator,\n\t\t\t\t\thooks,\n\t\t\t\t\tcontent: localHook?.type as string,\n\t\t\t\t\thandle\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tthis.router.history.push({\n\t\t\t\tmethod,\n\t\t\t\tpath,\n\t\t\t\tcomposed: null,\n\t\t\t\thandler: handle,\n\t\t\t\thooks: hooks as any\n\t\t\t})\n\n\t\t\treturn\n\t\t}\n\n\t\tlet composed:\n\t\t\t| ((context: Context<any, any, any>) => MaybePromise<Response>)\n\t\t\t| undefined = undefined\n\n\t\tconst shouldPrecompile =\n\t\t\tthis.config.precompile === true ||\n\t\t\t(typeof this.config.precompile === 'object' &&\n\t\t\t\tthis.config.precompile.compose === true)\n\n\t\tconst appInference = cloneInference(this.inference)\n\n\t\tconst mainHandler = shouldPrecompile\n\t\t\t? composeHandler({\n\t\t\t\t\tapp: this,\n\t\t\t\t\tpath,\n\t\t\t\t\tmethod,\n\t\t\t\t\tlocalHook: mergeHook(localHook),\n\t\t\t\t\thooks,\n\t\t\t\t\tvalidator,\n\t\t\t\t\thandler: handle,\n\t\t\t\t\tallowMeta,\n\t\t\t\t\tappInference\n\t\t\t\t})\n\t\t\t: (((context: Context) => {\n\t\t\t\t\tif (composed) return composed(context)\n\n\t\t\t\t\treturn (composed = composeHandler({\n\t\t\t\t\t\tapp: this,\n\t\t\t\t\t\tpath,\n\t\t\t\t\t\tmethod,\n\t\t\t\t\t\tlocalHook: mergeHook(localHook),\n\t\t\t\t\t\thooks,\n\t\t\t\t\t\tvalidator,\n\t\t\t\t\t\thandler: handle,\n\t\t\t\t\t\tallowMeta,\n\t\t\t\t\t\tappInference\n\t\t\t\t\t}) as any)(context)\n\t\t\t\t}) as ComposedHandler)\n\n\t\tif (!shouldPrecompile)\n\t\t\tmainHandler.compose = () => {\n\t\t\t\treturn (mainHandler.composed = composeHandler({\n\t\t\t\t\tapp: this,\n\t\t\t\t\tpath,\n\t\t\t\t\tmethod,\n\t\t\t\t\tlocalHook: mergeHook(localHook),\n\t\t\t\t\thooks,\n\t\t\t\t\tvalidator,\n\t\t\t\t\thandler: handle,\n\t\t\t\t\tallowMeta,\n\t\t\t\t\tappInference\n\t\t\t\t}) as any)\n\t\t\t}\n\n\t\tlet routeIndex = this.router.history.length\n\n\t\tif (this.routeTree.has(method + path)) {\n\t\t\trouteIndex = this.router.history.findIndex(\n\t\t\t\t(route) => route.path === path && route.method === method\n\t\t\t)\n\n\t\t\tif (routeIndex !== -1) {\n\t\t\t\t// remove route previously defined\n\t\t\t\tconst removed = this.router.history.splice(routeIndex, 1)[0]\n\n\t\t\t\tif (\n\t\t\t\t\tremoved &&\n\t\t\t\t\tthis.routeTree.has(removed?.method + removed?.path)\n\t\t\t\t)\n\t\t\t\t\tthis.routeTree.delete(removed.method + removed.path)\n\t\t\t}\n\t\t}\n\n\t\tthis.routeTree.set(method + path, routeIndex)\n\t\tthis.router.history.push({\n\t\t\tmethod,\n\t\t\tpath,\n\t\t\tcomposed: mainHandler,\n\t\t\thandler: handle,\n\t\t\thooks: hooks as any\n\t\t})\n\n\t\tconst staticRouter = this.router.static.http\n\n\t\tif (method === '$INTERNALWS') {\n\t\t\tconst loose = this.config.strictPath\n\t\t\t\t? undefined\n\t\t\t\t: path.endsWith('/')\n\t\t\t\t\t? path.slice(0, path.length - 1)\n\t\t\t\t\t: path + '/'\n\n\t\t\tif (path.indexOf(':') === -1 && path.indexOf('*') === -1) {\n\t\t\t\tconst index = staticRouter.handlers.length\n\t\t\t\tstaticRouter.handlers.push(mainHandler)\n\n\t\t\t\tstaticRouter.variables += `const st${index} = staticRouter.handlers[${index}]\\n`\n\n\t\t\t\tthis.router.static.ws[path] = index\n\t\t\t\tif (loose) this.router.static.ws[loose] = index\n\t\t\t} else {\n\t\t\t\tthis.router.ws.add('ws', path, mainHandler)\n\t\t\t\tif (loose) this.router.ws.add('ws', loose, mainHandler)\n\t\t\t}\n\n\t\t\treturn\n\t\t}\n\n\t\tif (path.indexOf(':') === -1 && path.indexOf('*') === -1) {\n\t\t\tconst index = staticRouter.handlers.length\n\t\t\tstaticRouter.handlers.push(mainHandler)\n\n\t\t\tstaticRouter.variables += shouldPrecompile\n\t\t\t\t? `const st${index} = staticRouter.handlers[${index}]\\n`\n\t\t\t\t: `let st${index} = staticRouter.handlers[${index}]\\nlet stc${index}\\n`\n\n\t\t\tif (!staticRouter.map[path])\n\t\t\t\tstaticRouter.map[path] = {\n\t\t\t\t\tcode: ''\n\t\t\t\t}\n\n\t\t\tif (method === 'ALL')\n\t\t\t\tstaticRouter.map[path].all = shouldPrecompile\n\t\t\t\t\t? `default: return st${index}(ctx)\\n`\n\t\t\t\t\t: `default: ${jitRoute(index)}\\n`\n\t\t\telse\n\t\t\t\tstaticRouter.map[path].code = shouldPrecompile\n\t\t\t\t\t? `case '${method}': return st${index}(ctx)\\n${staticRouter.map[path].code}`\n\t\t\t\t\t: `case '${method}': ${jitRoute(index)}\\n${\n\t\t\t\t\t\t\tstaticRouter.map[path].code\n\t\t\t\t\t\t}`\n\n\t\t\tif (!this.config.strictPath) {\n\t\t\t\tif (!staticRouter.map[loosePath])\n\t\t\t\t\tstaticRouter.map[loosePath] = {\n\t\t\t\t\t\tcode: ''\n\t\t\t\t\t}\n\n\t\t\t\tif (method === 'ALL')\n\t\t\t\t\tstaticRouter.map[loosePath].all = shouldPrecompile\n\t\t\t\t\t\t? `default: return st${index}(ctx)\\n`\n\t\t\t\t\t\t: `default: ${jitRoute(index)}\\n`\n\t\t\t\telse\n\t\t\t\t\tstaticRouter.map[loosePath].code = shouldPrecompile\n\t\t\t\t\t\t? `case '${method}': return st${index}(ctx)\\n${staticRouter.map[loosePath].code}`\n\t\t\t\t\t\t: `case '${method}': ${jitRoute(index)}\\n${\n\t\t\t\t\t\t\t\tstaticRouter.map[loosePath].code\n\t\t\t\t\t\t\t}`\n\t\t\t}\n\t\t} else {\n\t\t\tthis.router.http.add(method, path, mainHandler)\n\n\t\t\tif (!this.config.strictPath)\n\t\t\t\tthis.router.http.add(\n\t\t\t\t\tmethod,\n\t\t\t\t\tpath.endsWith('/')\n\t\t\t\t\t\t? path.slice(0, path.length - 1)\n\t\t\t\t\t\t: path + '/',\n\t\t\t\t\tmainHandler\n\t\t\t\t)\n\t\t}\n\t}\n\n\tprivate setHeaders?: Context['set']['headers']\n\theaders(header: Context['set']['headers'] | undefined) {\n\t\tif (!header) return this\n\n\t\tif (!this.setHeaders) this.setHeaders = {}\n\n\t\tthis.setHeaders = mergeDeep(this.setHeaders, header)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### start | Life cycle event\n\t * Called after server is ready for serving\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onStart(({ url, port }) => {\n\t *         console.log(\"Running at ${url}:${port}\")\n\t *     })\n\t *     .listen(3000)\n\t * ```\n\t */\n\tonStart(handler: MaybeArray<GracefulHandler<this>>) {\n\t\tthis.on('start', handler as any)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### request | Life cycle event\n\t * Called on every new request is accepted\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onRequest(({ method, url }) => {\n\t *         saveToAnalytic({ method, url })\n\t *     })\n\t * ```\n\t */\n\tonRequest<const Schema extends RouteSchema>(\n\t\thandler: MaybeArray<\n\t\t\tPreHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMetadata['schema'] &\n\t\t\t\t\t\tEphemeral['schema'] &\n\t\t\t\t\t\tVolatile['schema']\n\t\t\t\t>,\n\t\t\t\tSingleton & {\n\t\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t\t}\n\t\t\t>\n\t\t>\n\t) {\n\t\tthis.on('request', handler as any)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### parse | Life cycle event\n\t * Callback function to handle body parsing\n\t *\n\t * If truthy value is returned, will be assigned to `context.body`\n\t * Otherwise will skip the callback and look for the next one.\n\t *\n\t * Equivalent to Express's body parser\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onParse((request, contentType) => {\n\t *         if(contentType === \"application/json\")\n\t *             return request.json()\n\t *     })\n\t * ```\n\t */\n\tonParse<const Schema extends RouteSchema>(\n\t\tparser: MaybeArray<\n\t\t\tBodyHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMetadata['schema'] &\n\t\t\t\t\t\tEphemeral['schema'] &\n\t\t\t\t\t\tVolatile['schema']\n\t\t\t\t>,\n\t\t\t\tSingleton & {\n\t\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t\t},\n\t\t\t\tBasePath\n\t\t\t>\n\t\t>\n\t): this\n\n\t/**\n\t * ### parse | Life cycle event\n\t * Callback function to handle body parsing\n\t *\n\t * If truthy value is returned, will be assigned to `context.body`\n\t * Otherwise will skip the callback and look for the next one.\n\t *\n\t * Equivalent to Express's body parser\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onParse((request, contentType) => {\n\t *         if(contentType === \"application/json\")\n\t *             return request.json()\n\t *     })\n\t * ```\n\t */\n\tonParse<const Schema extends RouteSchema, const Type extends LifeCycleType>(\n\t\toptions: { as?: Type },\n\t\tparser: MaybeArray<\n\t\t\tBodyHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMetadata['schema'] &\n\t\t\t\t\t\tEphemeral['schema'] &\n\t\t\t\t\t\tVolatile['schema']\n\t\t\t\t>,\n\t\t\t\tSingleton &\n\t\t\t\t\t('global' extends Type\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tderive: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tresolve: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['resolve'] & Volatile['resolve']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['derive']>\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['resolve']>\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t\t})\n\t\t\t>\n\t\t>\n\t): this\n\n\tonParse(\n\t\toptions: { as?: LifeCycleType } | MaybeArray<Function>,\n\t\thandler?: MaybeArray<Function>\n\t) {\n\t\tif (!handler) return this.on('parse', options as any)\n\n\t\treturn this.on(\n\t\t\toptions as { as?: LifeCycleType },\n\t\t\t'parse',\n\t\t\thandler as any\n\t\t)\n\t}\n\n\t/**\n\t * ### transform | Life cycle event\n\t * Assign or transform anything related to context before validation.\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onTransform(({ params }) => {\n\t *         if(params.id)\n\t *             params.id = +params.id\n\t *     })\n\t * ```\n\t */\n\tonTransform<const Schema extends RouteSchema>(\n\t\thandler: MaybeArray<\n\t\t\tTransformHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMetadata['schema'] &\n\t\t\t\t\t\tEphemeral['schema'] &\n\t\t\t\t\t\tVolatile['schema']\n\t\t\t\t>,\n\t\t\t\tSingleton & {\n\t\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t\t},\n\t\t\t\tBasePath\n\t\t\t>\n\t\t>\n\t): this\n\n\t/**\n\t * ### transform | Life cycle event\n\t * Assign or transform anything related to context before validation.\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onTransform(({ params }) => {\n\t *         if(params.id)\n\t *             params.id = +params.id\n\t *     })\n\t * ```\n\t */\n\tonTransform<\n\t\tconst Schema extends RouteSchema,\n\t\tconst Type extends LifeCycleType\n\t>(\n\t\toptions: { as?: Type },\n\t\thandler: MaybeArray<\n\t\t\tTransformHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMetadata['schema'] &\n\t\t\t\t\t\tEphemeral['schema'] &\n\t\t\t\t\t\tVolatile['schema']\n\t\t\t\t>,\n\t\t\t\tSingleton &\n\t\t\t\t\t('global' extends Type\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['derive']>\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['resolve']>\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\tderive: Partial<\n\t\t\t\t\t\t\t\t\t\tEphemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\tresolve: Partial<\n\t\t\t\t\t\t\t\t\t\tEphemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t})\n\t\t\t>\n\t\t>\n\t): this\n\n\tonTransform(\n\t\toptions: { as?: LifeCycleType } | MaybeArray<Function>,\n\t\thandler?: MaybeArray<Function>\n\t) {\n\t\tif (!handler) return this.on('transform', options as any)\n\n\t\treturn this.on(\n\t\t\toptions as { as?: LifeCycleType },\n\t\t\t'transform',\n\t\t\thandler as any\n\t\t)\n\t}\n\n\t/**\n\t * Derive new property for each request with access to `Context`.\n\t *\n\t * If error is thrown, the scope will skip to handling error instead.\n\t *\n\t * ---\n\t * @example\n\t * new Elysia()\n\t *     .state('counter', 1)\n\t *     .derive(({ store }) => ({\n\t *         increase() {\n\t *             store.counter++\n\t *         }\n\t *     }))\n\t */\n\tresolve<\n\t\tconst Resolver extends Record<string, unknown>,\n\t\tconst Type extends LifeCycleType\n\t>(\n\t\toptions: { as?: Type },\n\t\tresolver: (\n\t\t\tcontext: Prettify<\n\t\t\t\tContext<\n\t\t\t\t\tMetadata['schema'] &\n\t\t\t\t\t\tEphemeral['schema'] &\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\tSingleton &\n\t\t\t\t\t\t('global' extends Type\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tderive: Partial<\n\t\t\t\t\t\t\t\t\t\tEphemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\tresolve: Partial<\n\t\t\t\t\t\t\t\t\t\tEphemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\t\tPartial<Volatile['derive']>\n\t\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\t\tPartial<Volatile['resolve']>\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t>\n\t\t\t>\n\t\t) => MaybePromise<Resolver>\n\t): Type extends 'global'\n\t\t? Elysia<\n\t\t\t\tBasePath,\n\t\t\t\tScoped,\n\t\t\t\t{\n\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\tderive: Singleton['resolve']\n\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\tSingleton['resolve'] & ExcludeElysiaResponse<Resolver>\n\t\t\t\t\t>\n\t\t\t\t},\n\t\t\t\tDefinitions,\n\t\t\t\tMetadata,\n\t\t\t\tRoutes,\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\t\t: Type extends 'scoped'\n\t\t\t? Elysia<\n\t\t\t\t\tBasePath,\n\t\t\t\t\tScoped,\n\t\t\t\t\tSingleton,\n\t\t\t\t\tDefinitions,\n\t\t\t\t\tMetadata,\n\t\t\t\t\tRoutes,\n\t\t\t\t\t{\n\t\t\t\t\t\tderive: Ephemeral['resolve']\n\t\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\t\tEphemeral['resolve'] &\n\t\t\t\t\t\t\t\tExcludeElysiaResponse<Resolver>\n\t\t\t\t\t\t>\n\t\t\t\t\t\tschema: Ephemeral['schema']\n\t\t\t\t\t},\n\t\t\t\t\tVolatile\n\t\t\t\t>\n\t\t\t: Elysia<\n\t\t\t\t\tBasePath,\n\t\t\t\t\tScoped,\n\t\t\t\t\tSingleton,\n\t\t\t\t\tDefinitions,\n\t\t\t\t\tMetadata,\n\t\t\t\t\tRoutes,\n\t\t\t\t\tEphemeral,\n\t\t\t\t\t{\n\t\t\t\t\t\tderive: Volatile['resolve']\n\t\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\t\tVolatile['resolve'] &\n\t\t\t\t\t\t\t\tExcludeElysiaResponse<Resolver>\n\t\t\t\t\t\t>\n\t\t\t\t\t\tschema: Volatile['schema']\n\t\t\t\t\t}\n\t\t\t\t>\n\n\t/**\n\t * Derive new property for each request with access to `Context`.\n\t *\n\t * If error is thrown, the scope will skip to handling error instead.\n\t *\n\t * ---\n\t * @example\n\t * new Elysia()\n\t *     .state('counter', 1)\n\t *     .derive(({ store }) => ({\n\t *         increase() {\n\t *             store.counter++\n\t *         }\n\t *     }))\n\t */\n\tresolve<const Resolver extends Record<string, unknown>>(\n\t\tresolver: (\n\t\t\tcontext: Prettify<\n\t\t\t\tContext<\n\t\t\t\t\tMetadata['schema'] &\n\t\t\t\t\t\tEphemeral['schema'] &\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\tSingleton & {\n\t\t\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t\t\t},\n\t\t\t\t\tBasePath\n\t\t\t\t>\n\t\t\t>\n\t\t) => MaybePromise<Resolver>\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\t{\n\t\t\tderive: Volatile['resolve']\n\t\t\tresolve: Prettify<\n\t\t\t\tVolatile['resolve'] & ExcludeElysiaResponse<Resolver>\n\t\t\t>\n\t\t\tschema: Volatile['schema']\n\t\t}\n\t>\n\n\tresolve(\n\t\toptionsOrResolve: { as?: LifeCycleType } | Function,\n\t\tresolve?: Function\n\t) {\n\t\tif (!resolve) {\n\t\t\tresolve = optionsOrResolve as any\n\t\t\toptionsOrResolve = { as: 'local' }\n\t\t}\n\n\t\tconst hook: HookContainer = {\n\t\t\tsubType: 'resolve',\n\t\t\tfn: resolve!\n\t\t}\n\n\t\treturn this.onBeforeHandle(optionsOrResolve as any, hook as any) as any\n\t}\n\n\tmapResolve<const NewResolver extends Record<string, unknown>>(\n\t\tmapper: (\n\t\t\tcontext: Context<\n\t\t\t\tMetadata['schema'] & Ephemeral['schema'] & Volatile['schema'],\n\t\t\t\tSingleton & {\n\t\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t\t},\n\t\t\t\tBasePath\n\t\t\t>\n\t\t) => MaybePromise<NewResolver>\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\t{\n\t\t\tderive: Volatile['derive']\n\t\t\tresolve: NewResolver\n\t\t\tschema: Volatile['schema']\n\t\t}\n\t>\n\n\tmapResolve<\n\t\tconst NewResolver extends Record<string, unknown>,\n\t\tconst Type extends LifeCycleType\n\t>(\n\t\toptions: { as?: Type },\n\t\tmapper: (\n\t\t\tcontext: Context<\n\t\t\t\tMetadata['schema'] & Ephemeral['schema'] & Volatile['schema'],\n\t\t\t\tSingleton &\n\t\t\t\t\t('global' extends Type\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tderive: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tresolve: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['resolve'] & Volatile['resolve']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['derive']>\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['resolve']>\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t\t})\n\t\t\t>\n\t\t) => MaybePromise<NewResolver>\n\t): Type extends 'global'\n\t\t? Elysia<\n\t\t\t\tBasePath,\n\t\t\t\tScoped,\n\t\t\t\t{\n\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\tderive: Singleton['resolve']\n\t\t\t\t\tresolve: Awaited<NewResolver>\n\t\t\t\t},\n\t\t\t\tDefinitions,\n\t\t\t\tMetadata,\n\t\t\t\tRoutes,\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\t\t: Type extends 'scoped'\n\t\t\t? Elysia<\n\t\t\t\t\tBasePath,\n\t\t\t\t\tScoped,\n\t\t\t\t\tSingleton,\n\t\t\t\t\tDefinitions,\n\t\t\t\t\tMetadata,\n\t\t\t\t\tRoutes,\n\t\t\t\t\t{\n\t\t\t\t\t\tderive: Ephemeral['resolve']\n\t\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\t\tEphemeral['resolve'] &\n\t\t\t\t\t\t\t\tExcludeElysiaResponse<NewResolver>\n\t\t\t\t\t\t>\n\t\t\t\t\t\tschema: Ephemeral['schema']\n\t\t\t\t\t},\n\t\t\t\t\tVolatile\n\t\t\t\t>\n\t\t\t: Elysia<\n\t\t\t\t\tBasePath,\n\t\t\t\t\tScoped,\n\t\t\t\t\tSingleton,\n\t\t\t\t\tDefinitions,\n\t\t\t\t\tMetadata,\n\t\t\t\t\tRoutes,\n\t\t\t\t\tEphemeral,\n\t\t\t\t\t{\n\t\t\t\t\t\tderive: Volatile['resolve']\n\t\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\t\tVolatile['resolve'] &\n\t\t\t\t\t\t\t\tExcludeElysiaResponse<NewResolver>\n\t\t\t\t\t\t>\n\t\t\t\t\t\tschema: Volatile['schema']\n\t\t\t\t\t}\n\t\t\t\t>\n\n\tmapResolve(\n\t\toptionsOrResolve: Function | { as?: LifeCycleType },\n\t\tmapper?: Function\n\t) {\n\t\tif (!mapper) {\n\t\t\tmapper = optionsOrResolve as any\n\t\t\toptionsOrResolve = { as: 'local' }\n\t\t}\n\n\t\tconst hook: HookContainer = {\n\t\t\tsubType: 'resolve',\n\t\t\tfn: mapper!\n\t\t}\n\n\t\treturn this.onBeforeHandle(optionsOrResolve as any, hook as any) as any\n\t}\n\n\t/**\n\t * ### Before Handle | Life cycle event\n\t * Execute after validation and before the main route handler.\n\t *\n\t * If truthy value is returned, will be assigned as `Response` and skip the main handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onBeforeHandle(({ params: { id }, status }) => {\n\t *         if(id && !isExisted(id)) {\n\t * \t           status(401)\n\t *\n\t *             return \"Unauthorized\"\n\t * \t       }\n\t *     })\n\t * ```\n\t */\n\tonBeforeHandle<const Schema extends RouteSchema>(\n\t\thandler: MaybeArray<\n\t\t\tOptionalHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMetadata['schema'] &\n\t\t\t\t\t\tEphemeral['schema'] &\n\t\t\t\t\t\tVolatile['schema']\n\t\t\t\t>,\n\t\t\t\tSingleton & {\n\t\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t\t}\n\t\t\t>\n\t\t>\n\t): this\n\n\t/**\n\t * ### Before Handle | Life cycle event\n\t * Execute after validation and before the main route handler.\n\t *\n\t * If truthy value is returned, will be assigned as `Response` and skip the main handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onBeforeHandle(({ params: { id }, status }) => {\n\t *         if(id && !isExisted(id)) {\n\t * \t           status(401)\n\t *\n\t *             return \"Unauthorized\"\n\t * \t       }\n\t *     })\n\t * ```\n\t */\n\tonBeforeHandle<\n\t\tconst Schema extends RouteSchema,\n\t\tconst Type extends LifeCycleType\n\t>(\n\t\toptions: { as?: Type },\n\t\thandler: MaybeArray<\n\t\t\tOptionalHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMetadata['schema'] &\n\t\t\t\t\t\tEphemeral['schema'] &\n\t\t\t\t\t\tVolatile['schema']\n\t\t\t\t>,\n\t\t\t\tSingleton &\n\t\t\t\t\t('global' extends Type\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tderive: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tresolve: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['resolve'] & Volatile['resolve']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['derive']>\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['resolve']>\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t\t}),\n\t\t\t\tBasePath\n\t\t\t>\n\t\t>\n\t): this\n\n\tonBeforeHandle(\n\t\toptions: { as?: LifeCycleType } | MaybeArray<Function>,\n\t\thandler?: MaybeArray<Function>\n\t) {\n\t\tif (!handler) return this.on('beforeHandle', options as any)\n\n\t\treturn this.on(\n\t\t\toptions as { as?: LifeCycleType },\n\t\t\t'beforeHandle',\n\t\t\thandler as any\n\t\t)\n\t}\n\n\t/**\n\t * ### After Handle | Life cycle event\n\t * Intercept request **after** main handler is called.\n\t *\n\t * If truthy value is returned, will be assigned as `Response`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onAfterHandle((context, response) => {\n\t *         if(typeof response === \"object\")\n\t *             return JSON.stringify(response)\n\t *     })\n\t * ```\n\t */\n\tonAfterHandle<const Schema extends RouteSchema>(\n\t\thandler: MaybeArray<\n\t\t\tAfterHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMetadata['schema'] &\n\t\t\t\t\t\tEphemeral['schema'] &\n\t\t\t\t\t\tVolatile['schema']\n\t\t\t\t>,\n\t\t\t\tSingleton & {\n\t\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t\t},\n\t\t\t\tBasePath\n\t\t\t>\n\t\t>\n\t): this\n\n\t/**\n\t * ### After Handle | Life cycle event\n\t * Intercept request **after** main handler is called.\n\t *\n\t * If truthy value is returned, will be assigned as `Response`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onAfterHandle((context, response) => {\n\t *         if(typeof response === \"object\")\n\t *             return JSON.stringify(response)\n\t *     })\n\t * ```\n\t */\n\tonAfterHandle<\n\t\tconst Schema extends RouteSchema,\n\t\tconst Type extends LifeCycleType\n\t>(\n\t\toptions: { as?: LifeCycleType },\n\t\thandler: MaybeArray<\n\t\t\tAfterHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMetadata['schema'] &\n\t\t\t\t\t\tEphemeral['schema'] &\n\t\t\t\t\t\tVolatile['schema']\n\t\t\t\t>,\n\t\t\t\tSingleton &\n\t\t\t\t\t('global' extends Type\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tderive: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tresolve: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['resolve'] & Volatile['resolve']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['derive']>\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['resolve']>\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t\t})\n\t\t\t>\n\t\t>\n\t): this\n\n\tonAfterHandle(\n\t\toptions: { as?: LifeCycleType } | MaybeArray<Function>,\n\t\thandler?: MaybeArray<Function>\n\t) {\n\t\tif (!handler) return this.on('afterHandle', options as any)\n\n\t\treturn this.on(\n\t\t\toptions as { as?: LifeCycleType },\n\t\t\t'afterHandle',\n\t\t\thandler as any\n\t\t)\n\t}\n\n\t/**\n\t * ### After Handle | Life cycle event\n\t * Intercept request **after** main handler is called.\n\t *\n\t * If truthy value is returned, will be assigned as `Response`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .mapResponse((context, response) => {\n\t *         if(typeof response === \"object\")\n\t *             return JSON.stringify(response)\n\t *     })\n\t * ```\n\t */\n\tmapResponse<const Schema extends RouteSchema>(\n\t\thandler: MaybeArray<\n\t\t\tMapResponse<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMetadata['schema'] &\n\t\t\t\t\t\tEphemeral['schema'] &\n\t\t\t\t\t\tVolatile['schema']\n\t\t\t\t>,\n\t\t\t\tSingleton & {\n\t\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t\t},\n\t\t\t\tBasePath\n\t\t\t>\n\t\t>\n\t): this\n\n\t/**\n\t * ### After Handle | Life cycle event\n\t * Intercept request **after** main handler is called.\n\t *\n\t * If truthy value is returned, will be assigned as `Response`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .mapResponse((context, response) => {\n\t *         if(typeof response === \"object\")\n\t *             return JSON.stringify(response)\n\t *     })\n\t * ```\n\t */\n\tmapResponse<const Schema extends RouteSchema, Type extends LifeCycleType>(\n\t\toptions: { as?: Type },\n\t\thandler: MaybeArray<\n\t\t\tMapResponse<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMetadata['schema'] &\n\t\t\t\t\t\tEphemeral['schema'] &\n\t\t\t\t\t\tVolatile['schema']\n\t\t\t\t>,\n\t\t\t\tSingleton &\n\t\t\t\t\t('global' extends Type\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tderive: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tresolve: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['resolve'] & Volatile['resolve']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['derive']>\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['resolve']>\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t\t})\n\t\t\t>\n\t\t>\n\t): this\n\n\tmapResponse(\n\t\toptions: { as?: LifeCycleType } | MaybeArray<Function>,\n\t\thandler?: MaybeArray<Function>\n\t) {\n\t\tif (!handler) return this.on('mapResponse', options as any)\n\n\t\treturn this.on(\n\t\t\toptions as { as?: LifeCycleType },\n\t\t\t'mapResponse',\n\t\t\thandler as any\n\t\t)\n\t}\n\n\t/**\n\t * ### response | Life cycle event\n\t * Called when handler is executed\n\t * Good for analytic metrics\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onError(({ code }) => {\n\t *         if(code === \"NOT_FOUND\")\n\t *             return \"Path not found :(\"\n\t *     })\n\t * ```\n\t */\n\n\tonResponse<const Schema extends RouteSchema>(\n\t\thandler: MaybeArray<\n\t\t\tVoidHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMetadata['schema'] &\n\t\t\t\t\t\tEphemeral['schema'] &\n\t\t\t\t\t\tVolatile['schema']\n\t\t\t\t>,\n\t\t\t\tSingleton & {\n\t\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t\t}\n\t\t\t>\n\t\t>\n\t): this\n\n\t/**\n\t * ### response | Life cycle event\n\t * Called when handler is executed\n\t * Good for analytic metrics\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onError(({ code }) => {\n\t *         if(code === \"NOT_FOUND\")\n\t *             return \"Path not found :(\"\n\t *     })\n\t * ```\n\t */\n\n\tonResponse<\n\t\tconst Schema extends RouteSchema,\n\t\tconst Type extends LifeCycleType\n\t>(\n\t\toptions: { as?: Type },\n\t\thandler: MaybeArray<\n\t\t\tVoidHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMetadata['schema'] &\n\t\t\t\t\t\tEphemeral['schema'] &\n\t\t\t\t\t\tVolatile['schema']\n\t\t\t\t>,\n\t\t\t\tSingleton &\n\t\t\t\t\t('global' extends Type\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tderive: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tresolve: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['resolve'] & Volatile['resolve']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['derive']>\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['resolve']>\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t\t})\n\t\t\t>\n\t\t>\n\t): this\n\n\tonResponse(\n\t\toptions: { as?: LifeCycleType } | MaybeArray<Function>,\n\t\thandler?: MaybeArray<Function>\n\t) {\n\t\tif (!handler) return this.on('response', options as any)\n\n\t\treturn this.on(\n\t\t\toptions as { as?: LifeCycleType },\n\t\t\t'response',\n\t\t\thandler as any\n\t\t)\n\t}\n\n\t/**\n\t * ### After Handle | Life cycle event\n\t * Intercept request **after** main handler is called.\n\t *\n\t * If truthy value is returned, will be assigned as `Response`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onAfterHandle((context, response) => {\n\t *         if(typeof response === \"object\")\n\t *             return JSON.stringify(response)\n\t *     })\n\t * ```\n\t */\n\ttrace<const Schema extends RouteSchema>(\n\t\thandler: MaybeArray<TraceHandler<Schema, Singleton>>\n\t): this\n\n\t/**\n\t * ### After Handle | Life cycle event\n\t * Intercept request **after** main handler is called.\n\t *\n\t * If truthy value is returned, will be assigned as `Response`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onAfterHandle((context, response) => {\n\t *         if(typeof response === \"object\")\n\t *             return JSON.stringify(response)\n\t *     })\n\t * ```\n\t */\n\ttrace<const Schema extends RouteSchema>(\n\t\toptions: { as?: LifeCycleType },\n\t\thandler: MaybeArray<TraceHandler<Schema, Singleton>>\n\t): this\n\n\t/**\n\t * ### After Handle | Life cycle event\n\t * Intercept request **after** main handler is called.\n\t *\n\t * If truthy value is returned, will be assigned as `Response`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onAfterHandle((context, response) => {\n\t *         if(typeof response === \"object\")\n\t *             return JSON.stringify(response)\n\t *     })\n\t * ```\n\t */\n\ttrace(\n\t\toptions: { as?: LifeCycleType } | MaybeArray<Function>,\n\t\thandler?: MaybeArray<Function>\n\t) {\n\t\tif (!handler) {\n\t\t\thandler = options as MaybeArray<Function>\n\t\t\toptions = { as: 'local' }\n\t\t}\n\n\t\tif (!Array.isArray(handler)) handler = [handler] as Function[]\n\n\t\tfor (const fn of handler)\n\t\t\tthis.reporter.on(\n\t\t\t\t'event',\n\t\t\t\tcreateTraceListener(\n\t\t\t\t\t() => this.reporter,\n\t\t\t\t\tthis.event.trace.length,\n\t\t\t\t\tfn as any\n\t\t\t\t)\n\t\t\t)\n\n\t\tthis.on(options as { as?: LifeCycleType }, 'trace', handler as any)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Register errors\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * class CustomError extends Error {\n\t *     constructor() {\n\t *         super()\n\t *     }\n\t * }\n\t *\n\t * new Elysia()\n\t *     .error('CUSTOM_ERROR', CustomError)\n\t * ```\n\t */\n\terror<\n\t\tconst Errors extends Record<\n\t\t\tstring,\n\t\t\t{\n\t\t\t\tprototype: Error\n\t\t\t}\n\t\t>\n\t>(\n\t\terrors: Errors\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\t{\n\t\t\ttype: Definitions['type']\n\t\t\terror: Definitions['error'] & {\n\t\t\t\t[K in keyof Errors]: Errors[K] extends {\n\t\t\t\t\tprototype: infer LiteralError extends Error\n\t\t\t\t}\n\t\t\t\t\t? LiteralError\n\t\t\t\t\t: Errors[K]\n\t\t\t}\n\t\t},\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * Register errors\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * class CustomError extends Error {\n\t *     constructor() {\n\t *         super()\n\t *     }\n\t * }\n\t *\n\t * new Elysia()\n\t *     .error({\n\t *         CUSTOM_ERROR: CustomError\n\t *     })\n\t * ```\n\t */\n\terror<\n\t\tName extends string,\n\t\tconst CustomError extends {\n\t\t\tprototype: Error\n\t\t}\n\t>(\n\t\tname: Name,\n\t\terrors: CustomError\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\t{\n\t\t\ttype: Definitions['type']\n\t\t\terror: Definitions['error'] & {\n\t\t\t\t[name in Name]: CustomError extends {\n\t\t\t\t\tprototype: infer LiteralError extends Error\n\t\t\t\t}\n\t\t\t\t\t? LiteralError\n\t\t\t\t\t: CustomError\n\t\t\t}\n\t\t},\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * Register errors\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * class CustomError extends Error {\n\t *     constructor() {\n\t *         super()\n\t *     }\n\t * }\n\t *\n\t * new Elysia()\n\t *     .error('CUSTOM_ERROR', CustomError)\n\t * ```\n\t */\n\terror<const NewErrors extends Record<string, Error>>(\n\t\tmapper: (decorators: Definitions['error']) => NewErrors\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\t{\n\t\t\ttype: Definitions['type']\n\t\t\terror: {\n\t\t\t\t[K in keyof NewErrors]: NewErrors[K] extends {\n\t\t\t\t\tprototype: infer LiteralError extends Error\n\t\t\t\t}\n\t\t\t\t\t? LiteralError\n\t\t\t\t\t: never\n\t\t\t}\n\t\t},\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\terror(\n\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\tname:\n\t\t\t| string\n\t\t\t| Record<\n\t\t\t\t\tstring,\n\t\t\t\t\t{\n\t\t\t\t\t\tprototype: Error\n\t\t\t\t\t}\n\t\t\t  >\n\t\t\t| Function,\n\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\terror?: {\n\t\t\tprototype: Error\n\t\t}\n\t): AnyElysia {\n\t\tswitch (typeof name) {\n\t\t\tcase 'string':\n\t\t\t\t// @ts-ignore\n\t\t\t\terror.prototype[ERROR_CODE] = name\n\n\t\t\t\t// @ts-ignore\n\t\t\t\tthis.definitions.error[name] = error\n\n\t\t\t\treturn this\n\n\t\t\tcase 'function':\n\t\t\t\tthis.definitions.error = name(this.definitions.error)\n\n\t\t\t\treturn this as any\n\t\t}\n\n\t\tfor (const [code, error] of Object.entries(name)) {\n\t\t\t// @ts-ignore\n\t\t\terror.prototype[ERROR_CODE] = code as any\n\n\t\t\tthis.definitions.error[code] = error as any\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### Error | Life cycle event\n\t * Called when error is thrown during processing request\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onError(({ code }) => {\n\t *         if(code === \"NOT_FOUND\")\n\t *             return \"Path not found :(\"\n\t *     })\n\t * ```\n\t */\n\tonError<const Schema extends RouteSchema>(\n\t\thandler: ErrorHandler<\n\t\t\tDefinitions['error'],\n\t\t\tMergeSchema<\n\t\t\t\tSchema,\n\t\t\t\tMetadata['schema'] & Ephemeral['schema'] & Volatile['schema']\n\t\t\t>,\n\t\t\tSingleton,\n\t\t\tEphemeral,\n\t\t\tVolatile\n\t\t>\n\t): this\n\n\t/**\n\t * ### Error | Life cycle event\n\t * Called when error is thrown during processing request\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onError(({ code }) => {\n\t *         if(code === \"NOT_FOUND\")\n\t *             return \"Path not found :(\"\n\t *     })\n\t * ```\n\t */\n\tonError<const Schema extends RouteSchema>(\n\t\toptions: { as?: LifeCycleType },\n\t\thandler: ErrorHandler<\n\t\t\tDefinitions['error'],\n\t\t\tMergeSchema<\n\t\t\t\tSchema,\n\t\t\t\tMetadata['schema'] & Ephemeral['schema'] & Volatile['schema']\n\t\t\t>,\n\t\t\tSingleton,\n\t\t\tEphemeral,\n\t\t\tVolatile\n\t\t>\n\t): this\n\n\t/**\n\t * ### Error | Life cycle event\n\t * Called when error is thrown during processing request\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onError(({ code }) => {\n\t *         if(code === \"NOT_FOUND\")\n\t *             return \"Path not found :(\"\n\t *     })\n\t * ```\n\t */\n\tonError(\n\t\toptions: { as?: LifeCycleType } | MaybeArray<Function>,\n\t\thandler?: MaybeArray<Function>\n\t) {\n\t\tif (!handler) return this.on('error', options as any)\n\n\t\treturn this.on(\n\t\t\toptions as { as?: LifeCycleType },\n\t\t\t'error',\n\t\t\thandler as any\n\t\t)\n\t}\n\n\t/**\n\t * ### stop | Life cycle event\n\t * Called after server stop serving request\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onStop((app) => {\n\t *         cleanup()\n\t *     })\n\t * ```\n\t */\n\tonStop(handler: MaybeArray<GracefulHandler<this>>) {\n\t\tthis.on('stop', handler as any)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### on\n\t * Syntax sugar for attaching life cycle event by name\n\t *\n\t * Does the exact same thing as `.on[Event]()`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .on('error', ({ code }) => {\n\t *         if(code === \"NOT_FOUND\")\n\t *             return \"Path not found :(\"\n\t *     })\n\t * ```\n\t */\n\ton<Event extends keyof LifeCycleStore>(\n\t\ttype: Exclude<Event, 'onResponse'> | 'response',\n\t\thandlers: MaybeArray<\n\t\t\tExtract<LifeCycleStore[Event], HookContainer[]>[0]['fn']\n\t\t>\n\t): this\n\n\t/**\n\t * ### on\n\t * Syntax sugar for attaching life cycle event by name\n\t *\n\t * Does the exact same thing as `.on[Event]()`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .on('error', ({ code }) => {\n\t *         if(code === \"NOT_FOUND\")\n\t *             return \"Path not found :(\"\n\t *     })\n\t * ```\n\t */\n\ton<const Event extends keyof LifeCycleStore>(\n\t\toptions: { as?: LifeCycleType },\n\t\ttype: Exclude<Event, 'onResponse'> | 'response',\n\t\thandlers: MaybeArray<Extract<LifeCycleStore[Event], Function[]>[0]>\n\t): this\n\n\ton(\n\t\toptionsOrType: { as?: LifeCycleType } | string,\n\t\ttypeOrHandlers: MaybeArray<Function | HookContainer> | string,\n\t\thandlers?: MaybeArray<Function | HookContainer>\n\t) {\n\t\tlet type: Exclude<keyof LifeCycleStore, 'onResponse'> | 'onResponse'\n\n\t\tswitch (typeof optionsOrType) {\n\t\t\tcase 'string':\n\t\t\t\ttype = optionsOrType as any\n\t\t\t\thandlers = typeOrHandlers as any\n\n\t\t\t\tbreak\n\n\t\t\tcase 'object':\n\t\t\t\ttype = typeOrHandlers as any\n\t\t\t\tbreak\n\t\t}\n\n\t\t// @ts-expect-error possible user error, leave it on\n\t\tif (type === 'response') type = 'onResponse'\n\n\t\tif (Array.isArray(handlers)) handlers = fnToContainer(handlers)\n\t\telse {\n\t\t\tif (typeof handlers === 'function')\n\t\t\t\thandlers = [\n\t\t\t\t\t{\n\t\t\t\t\t\tfn: handlers\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\telse handlers = [handlers!]\n\t\t}\n\n\t\tconst handles = handlers as HookContainer[]\n\n\t\tfor (const handle of handles)\n\t\t\thandle.scope =\n\t\t\t\ttypeof optionsOrType === 'string'\n\t\t\t\t\t? 'local'\n\t\t\t\t\t: optionsOrType?.as ?? 'local'\n\n\t\tif (type === 'trace')\n\t\t\tsucroseTrace(\n\t\t\t\thandles.map((x) => x.fn) as TraceHandler[],\n\t\t\t\tthis.inference.trace\n\t\t\t)\n\t\telse\n\t\t\tsucrose(\n\t\t\t\t{\n\t\t\t\t\t[type]: handles.map((x) => x.fn)\n\t\t\t\t},\n\t\t\t\tthis.inference.event\n\t\t\t)\n\n\t\tfor (const handle of handles) {\n\t\t\tconst fn = asHookType(handle, 'global', { skipIfHasType: true })\n\n\t\t\tswitch (type) {\n\t\t\t\tcase 'start':\n\t\t\t\t\tthis.event.start.push(fn as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'request':\n\t\t\t\t\tthis.event.request.push(fn as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'parse':\n\t\t\t\t\tthis.event.parse.push(fn as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'transform':\n\t\t\t\t\tthis.event.transform.push(fn as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'beforeHandle':\n\t\t\t\t\tthis.event.beforeHandle.push(fn as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'afterHandle':\n\t\t\t\t\tthis.event.afterHandle.push(fn as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'mapResponse':\n\t\t\t\t\tthis.event.mapResponse.push(fn as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'onResponse':\n\t\t\t\t\tthis.event.onResponse.push(fn as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'trace':\n\t\t\t\t\tthis.event.trace.push(fn as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'error':\n\t\t\t\t\tthis.event.error.push(fn as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'stop':\n\t\t\t\t\tthis.event.stop.push(fn as any)\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\treturn this\n\t}\n\n\tpropagate(): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tPrettify2<Ephemeral & Volatile>,\n\t\t{\n\t\t\tderive: {}\n\t\t\tresolve: {}\n\t\t\tschema: {}\n\t\t}\n\t> {\n\t\t/**\n\t\t * Since it's a plugin, which means that ephemeral is demoted to volatile.\n\t\t * Which  means there's no volatile and all previous ephemeral become volatile\n\t\t * We can just promote back without worry\n\t\t */\n\t\tconst promoteEvent = (events: (HookContainer | Function)[]) => {\n\t\t\tfor (const event of events) {\n\t\t\t\tif ('scope' in event && event.scope === 'local')\n\t\t\t\t\tevent.scope = 'scoped'\n\t\t\t}\n\t\t}\n\n\t\tpromoteEvent(this.event.parse)\n\t\tpromoteEvent(this.event.transform)\n\t\tpromoteEvent(this.event.beforeHandle)\n\t\tpromoteEvent(this.event.afterHandle)\n\t\tpromoteEvent(this.event.mapResponse)\n\t\tpromoteEvent(this.event.onResponse)\n\t\tpromoteEvent(this.event.trace)\n\t\tpromoteEvent(this.event.error)\n\n\t\treturn this as any\n\t}\n\n\tgroup<\n\t\tconst Prefix extends string,\n\t\tconst NewElysia extends Elysia<any, any, any, any, any, any, any, any>\n\t>(\n\t\tprefix: Prefix,\n\t\trun: (\n\t\t\tgroup: Elysia<\n\t\t\t\t`${BasePath}${Prefix}`,\n\t\t\t\tScoped,\n\t\t\t\tSingleton,\n\t\t\t\tDefinitions,\n\t\t\t\tMetadata,\n\t\t\t\t{},\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\t\t) => NewElysia\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tPrettify<Routes & NewElysia['_routes']>,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\tgroup<\n\t\tconst Prefix extends string,\n\t\tconst NewElysia extends AnyElysia,\n\t\tconst Input extends InputSchema<\n\t\t\tExtract<keyof Definitions['type'], string>\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<Input, Definitions['type']>,\n\t\t\tMetadata['schema']\n\t\t>\n\t>(\n\t\tprefix: Prefix,\n\t\tschema: LocalHook<\n\t\t\tInput,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\tDefinitions['error'],\n\t\t\tMetadata['macro'],\n\t\t\t`${BasePath}${Prefix}`\n\t\t>,\n\t\trun: (\n\t\t\tgroup: Elysia<\n\t\t\t\t`${BasePath}${Prefix}`,\n\t\t\t\tfalse,\n\t\t\t\tSingleton,\n\t\t\t\tDefinitions,\n\t\t\t\t{\n\t\t\t\t\tschema: Schema\n\t\t\t\t\tmacro: Metadata['macro']\n\t\t\t\t},\n\t\t\t\t{},\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\t\t) => NewElysia\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes & NewElysia['_routes'],\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * ### group\n\t * Encapsulate and group path with prefix\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .group('/v1', app => app\n\t *         .get('/', () => 'Hi')\n\t *         .get('/name', () => 'Elysia')\n\t *     })\n\t * ```\n\t */\n\tgroup(\n\t\tprefix: string,\n\t\tschemaOrRun:\n\t\t\t| LocalHook<any, any, any, any, any, any>\n\t\t\t| ((group: AnyElysia) => AnyElysia),\n\t\trun?: (group: AnyElysia) => AnyElysia\n\t): AnyElysia {\n\t\tconst instance = new Elysia({\n\t\t\t...this.config,\n\t\t\tprefix: ''\n\t\t})\n\n\t\tinstance.singleton = { ...this.singleton }\n\t\tinstance.definitions = { ...this.definitions }\n\t\tinstance.getServer = () => this.server\n\t\tinstance.inference = cloneInference(this.inference)\n\n\t\tconst isSchema = typeof schemaOrRun === 'object'\n\t\tconst sandbox = (isSchema ? run! : schemaOrRun)(instance)\n\t\tthis.singleton = mergeDeep(this.singleton, instance.singleton) as any\n\t\tthis.definitions = mergeDeep(this.definitions, instance.definitions)\n\n\t\tif (sandbox.event.request.length)\n\t\t\tthis.event.request = [\n\t\t\t\t...(this.event.request || []),\n\t\t\t\t...((sandbox.event.request || []) as any)\n\t\t\t]\n\n\t\tif (sandbox.event.onResponse.length)\n\t\t\tthis.event.onResponse = [\n\t\t\t\t...(this.event.onResponse || []),\n\t\t\t\t...((sandbox.event.onResponse || []) as any)\n\t\t\t]\n\n\t\tthis.model(sandbox.definitions.type)\n\n\t\tObject.values(instance.router.history).forEach(\n\t\t\t({ method, path, handler, hooks }) => {\n\t\t\t\tpath = (isSchema ? '' : this.config.prefix) + prefix + path\n\n\t\t\t\tif (isSchema) {\n\t\t\t\t\tconst hook = schemaOrRun\n\t\t\t\t\tconst localHook = hooks as LocalHook<\n\t\t\t\t\t\tany,\n\t\t\t\t\t\tany,\n\t\t\t\t\t\tany,\n\t\t\t\t\t\tany,\n\t\t\t\t\t\tany,\n\t\t\t\t\t\tany,\n\t\t\t\t\t\tany\n\t\t\t\t\t>\n\n\t\t\t\t\tthis.add(\n\t\t\t\t\t\tmethod,\n\t\t\t\t\t\tpath,\n\t\t\t\t\t\thandler,\n\t\t\t\t\t\tmergeHook(hook, {\n\t\t\t\t\t\t\t...(localHook || {}),\n\t\t\t\t\t\t\terror: !localHook.error\n\t\t\t\t\t\t\t\t? sandbox.event.error\n\t\t\t\t\t\t\t\t: Array.isArray(localHook.error)\n\t\t\t\t\t\t\t\t\t? [\n\t\t\t\t\t\t\t\t\t\t\t...(localHook.error || {}),\n\t\t\t\t\t\t\t\t\t\t\t...(sandbox.event.error || {})\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t: [\n\t\t\t\t\t\t\t\t\t\t\tlocalHook.error,\n\t\t\t\t\t\t\t\t\t\t\t...(sandbox.event.error || {})\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t})\n\t\t\t\t\t)\n\t\t\t\t} else {\n\t\t\t\t\tthis.add(\n\t\t\t\t\t\tmethod,\n\t\t\t\t\t\tpath,\n\t\t\t\t\t\thandler,\n\t\t\t\t\t\tmergeHook(\n\t\t\t\t\t\t\thooks as LocalHook<any, any, any, any, any, any>,\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\terror: sandbox.event.error\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t),\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tskipPrefix: true\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\t\t)\n\n\t\treturn this as any\n\t}\n\n\tguard<\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tExtract<keyof Definitions['type'], string>\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tMetadata['schema']\n\t\t>\n\t>(\n\t\thook: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\tDefinitions['error'],\n\t\t\tMetadata['macro'],\n\t\t\tBasePath\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\t{\n\t\t\tderive: Volatile['resolve']\n\t\t\tresolve: Volatile['resolve']\n\t\t\tschema: MergeSchema<\n\t\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\t\tMetadata['schema'] & Ephemeral['schema'] & Volatile['schema']\n\t\t\t>\n\t\t}\n\t>\n\n\tguard<\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tExtract<keyof Definitions['type'], string>\n\t\t>,\n\t\tconst NewElysia extends AnyElysia,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tMetadata['schema']\n\t\t>\n\t>(\n\t\trun: (\n\t\t\tgroup: Elysia<\n\t\t\t\tBasePath,\n\t\t\t\tScoped,\n\t\t\t\tSingleton,\n\t\t\t\tDefinitions,\n\t\t\t\t{\n\t\t\t\t\tschema: Prettify<Schema>\n\t\t\t\t\tmacro: Metadata['macro']\n\t\t\t\t},\n\t\t\t\t{},\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\t\t) => NewElysia\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tPrettify<Routes & NewElysia['_routes']>,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\tguard<\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tExtract<keyof Definitions['type'], string>\n\t\t>,\n\t\tconst NewElysia extends AnyElysia,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tMetadata['schema']\n\t\t>\n\t>(\n\t\tschema: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\tDefinitions['error'],\n\t\t\tMetadata['macro'],\n\t\t\t''\n\t\t>,\n\t\trun: (\n\t\t\tgroup: Elysia<\n\t\t\t\tBasePath,\n\t\t\t\tScoped,\n\t\t\t\tSingleton,\n\t\t\t\tDefinitions,\n\t\t\t\t{\n\t\t\t\t\tschema: Prettify<Schema>\n\t\t\t\t\tmacro: Metadata['macro']\n\t\t\t\t},\n\t\t\t\t{},\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\t\t) => NewElysia\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tPrettify<Routes & NewElysia['_routes']>,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * ### guard\n\t * Encapsulate and pass hook into all child handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .guard({\n\t *          schema: {\n\t *              body: t.Object({\n\t *                  username: t.String(),\n\t *                  password: t.String()\n\t *              })\n\t *          }\n\t *     }, app => app\n\t *         .get(\"/\", () => 'Hi')\n\t *         .get(\"/name\", () => 'Elysia')\n\t *     })\n\t * ```\n\t */\n\tguard(\n\t\thook:\n\t\t\t| LocalHook<any, any, any, any, any, any, any>\n\t\t\t| ((group: AnyElysia) => AnyElysia),\n\t\trun?: (group: AnyElysia) => AnyElysia\n\t): AnyElysia {\n\t\tif (!run) {\n\t\t\tif (typeof hook === 'object') {\n\t\t\t\tthis.applyMacro(hook)\n\t\t\t\tthis.event = mergeLifeCycle(this.event, hook)\n\t\t\t\tthis.validator = {\n\t\t\t\t\tbody: hook.body ?? this.validator?.body,\n\t\t\t\t\theaders: hook.headers ?? this.validator?.headers,\n\t\t\t\t\tparams: hook.params ?? this.validator?.params,\n\t\t\t\t\tquery: hook.query ?? this.validator?.query,\n\t\t\t\t\tresponse: hook.response ?? this.validator?.response,\n\t\t\t\t\tcookie: hook.cookie ?? this.validator?.cookie\n\t\t\t\t}\n\n\t\t\t\tif (hook.detail) {\n\t\t\t\t\tif (this.config.detail)\n\t\t\t\t\t\tthis.config.detail = mergeDeep(\n\t\t\t\t\t\t\tObject.assign({}, this.config.detail),\n\t\t\t\t\t\t\thook.detail\n\t\t\t\t\t\t)\n\t\t\t\t\telse this.config.detail = hook.detail\n\t\t\t\t}\n\n\t\t\t\tif (hook?.tags) {\n\t\t\t\t\tif (!this.config.detail)\n\t\t\t\t\t\tthis.config.detail = {\n\t\t\t\t\t\t\ttags: hook.tags\n\t\t\t\t\t\t}\n\t\t\t\t\telse this.config.detail.tags = hook.tags\n\t\t\t\t}\n\n\t\t\t\treturn this\n\t\t\t}\n\n\t\t\treturn this.guard({}, hook)\n\t\t}\n\n\t\tconst instance = new Elysia({\n\t\t\t...this.config,\n\t\t\tprefix: ''\n\t\t})\n\t\tinstance.singleton = { ...this.singleton }\n\t\tinstance.definitions = { ...this.definitions }\n\t\tinstance.inference = cloneInference(this.inference)\n\n\t\tconst sandbox = run(instance)\n\t\tthis.singleton = mergeDeep(this.singleton, instance.singleton) as any\n\t\tthis.definitions = mergeDeep(this.definitions, instance.definitions)\n\n\t\t// ? Inject getServer for websocket and trace (important, do not remove)\n\t\tsandbox.getServer = () => this.server\n\n\t\tif (sandbox.event.request.length)\n\t\t\tthis.event.request = [\n\t\t\t\t...(this.event.request || []),\n\t\t\t\t...(sandbox.event.request || [])\n\t\t\t]\n\n\t\tif (sandbox.event.onResponse.length)\n\t\t\tthis.event.onResponse = [\n\t\t\t\t...(this.event.onResponse || []),\n\t\t\t\t...(sandbox.event.onResponse || [])\n\t\t\t]\n\n\t\tthis.model(sandbox.definitions.type)\n\n\t\tObject.values(instance.router.history).forEach(\n\t\t\t({ method, path, handler, hooks: localHook }) => {\n\t\t\t\tthis.add(\n\t\t\t\t\tmethod,\n\t\t\t\t\tpath,\n\t\t\t\t\thandler,\n\t\t\t\t\tmergeHook(\n\t\t\t\t\t\thook as LocalHook<any, any, any, any, any>,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t...((localHook || {}) as LocalHook<\n\t\t\t\t\t\t\t\tany,\n\t\t\t\t\t\t\t\tany,\n\t\t\t\t\t\t\t\tany,\n\t\t\t\t\t\t\t\tany,\n\t\t\t\t\t\t\t\tany\n\t\t\t\t\t\t\t>),\n\t\t\t\t\t\t\terror: !localHook.error\n\t\t\t\t\t\t\t\t? sandbox.event.error\n\t\t\t\t\t\t\t\t: Array.isArray(localHook.error)\n\t\t\t\t\t\t\t\t\t? [\n\t\t\t\t\t\t\t\t\t\t\t...(localHook.error || {}),\n\t\t\t\t\t\t\t\t\t\t\t...(sandbox.event.error || [])\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t: [\n\t\t\t\t\t\t\t\t\t\t\tlocalHook.error,\n\t\t\t\t\t\t\t\t\t\t\t...(sandbox.event.error || [])\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tallowMacro: true\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t}\n\t\t)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * Inline fn\n\t */\n\tuse<\n\t\tconst NewElysia extends AnyElysia,\n\t\tconst Param extends AnyElysia = this\n\t>(\n\t\tplugin: MaybePromise<(app: Param) => MaybePromise<NewElysia>>\n\t): NewElysia['_scoped'] extends false\n\t\t? Elysia<\n\t\t\t\tBasePath,\n\t\t\t\tScoped,\n\t\t\t\t// @ts-expect-error - This is truly ideal\n\t\t\t\tPrettify2<Singleton & NewElysia['_types']['Singleton']>,\n\t\t\t\tPrettify2<Definitions & NewElysia['_types']['Definitions']>,\n\t\t\t\tPrettify2<Metadata & NewElysia['_types']['Metadata']>,\n\t\t\t\tBasePath extends ``\n\t\t\t\t\t? Routes & NewElysia['_routes']\n\t\t\t\t\t: Routes & CreateEden<BasePath, NewElysia['_routes']>,\n\t\t\t\tPrettify2<Ephemeral & NewElysia['_ephemeral']>,\n\t\t\t\tPrettify2<Volatile & NewElysia['_volatile']>\n\t\t\t>\n\t\t: Elysia<\n\t\t\t\tBasePath,\n\t\t\t\tScoped,\n\t\t\t\tSingleton,\n\t\t\t\tDefinitions,\n\t\t\t\tMetadata,\n\t\t\t\tBasePath extends ``\n\t\t\t\t\t? Routes & NewElysia['_routes']\n\t\t\t\t\t: Routes & CreateEden<BasePath, NewElysia['_routes']>,\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\n\t/**\n\t * Entire Instance\n\t **/\n\tuse<const NewElysia extends AnyElysia>(\n\t\tinstance: MaybePromise<NewElysia>\n\t): NewElysia['_scoped'] extends false\n\t\t? Elysia<\n\t\t\t\tBasePath,\n\t\t\t\tScoped,\n\t\t\t\t// @ts-expect-error - This is truly ideal\n\t\t\t\tPrettify2<Singleton & NewElysia['_types']['Singleton']>,\n\t\t\t\tPrettify2<Definitions & NewElysia['_types']['Definitions']>,\n\t\t\t\tPrettify2<Metadata & NewElysia['_types']['Metadata']>,\n\t\t\t\tBasePath extends ``\n\t\t\t\t\t? Routes & NewElysia['_routes']\n\t\t\t\t\t: Routes & CreateEden<BasePath, NewElysia['_routes']>,\n\t\t\t\tEphemeral,\n\t\t\t\tPrettify2<Volatile & NewElysia['_ephemeral']>\n\t\t\t>\n\t\t: Elysia<\n\t\t\t\tBasePath,\n\t\t\t\tScoped,\n\t\t\t\tSingleton,\n\t\t\t\tDefinitions,\n\t\t\t\tMetadata,\n\t\t\t\tBasePath extends ``\n\t\t\t\t\t? Routes & NewElysia['_routes']\n\t\t\t\t\t: Routes & CreateEden<BasePath, NewElysia['_routes']>,\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\n\t/**\n\t * Import fn\n\t */\n\tuse<const NewElysia extends AnyElysia>(\n\t\tplugin: Promise<{\n\t\t\tdefault: (elysia: AnyElysia) => MaybePromise<NewElysia>\n\t\t}>\n\t): NewElysia['_scoped'] extends false\n\t\t? Elysia<\n\t\t\t\tBasePath,\n\t\t\t\tScoped,\n\t\t\t\t// @ts-expect-error - This is truly ideal\n\t\t\t\tPrettify2<Singleton & NewElysia['_types']['Singleton']>,\n\t\t\t\tPrettify2<Definitions & NewElysia['_types']['Definitions']>,\n\t\t\t\tPrettify2<Metadata & NewElysia['_types']['Metadata']>,\n\t\t\t\tBasePath extends ``\n\t\t\t\t\t? Routes & NewElysia['_routes']\n\t\t\t\t\t: Routes & CreateEden<BasePath, NewElysia['_routes']>,\n\t\t\t\tPrettify2<Ephemeral & NewElysia['_ephemeral']>,\n\t\t\t\tPrettify2<Volatile & NewElysia['_volatile']>\n\t\t\t>\n\t\t: Elysia<\n\t\t\t\tBasePath,\n\t\t\t\tScoped,\n\t\t\t\tSingleton,\n\t\t\t\tDefinitions,\n\t\t\t\tMetadata,\n\t\t\t\tBasePath extends ``\n\t\t\t\t\t? Routes & NewElysia['_routes']\n\t\t\t\t\t: Routes & CreateEden<BasePath, NewElysia['_routes']>,\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\n\t/**\n\t * Import entire instance\n\t */\n\tuse<const LazyLoadElysia extends AnyElysia>(\n\t\tplugin: Promise<{\n\t\t\tdefault: LazyLoadElysia\n\t\t}>\n\t): LazyLoadElysia['_scoped'] extends false\n\t\t? Elysia<\n\t\t\t\tBasePath,\n\t\t\t\tScoped,\n\t\t\t\t// @ts-expect-error - This is truly ideal\n\t\t\t\tPrettify2<Singleton & LazyLoadElysia['_types']['Singleton']>,\n\t\t\t\tPrettify2<\n\t\t\t\t\tDefinitions & LazyLoadElysia['_types']['Definitions']\n\t\t\t\t>,\n\t\t\t\tPrettify2<Metadata & LazyLoadElysia['_types']['Metadata']>,\n\t\t\t\tBasePath extends ``\n\t\t\t\t\t? Routes & LazyLoadElysia['_routes']\n\t\t\t\t\t: Routes & CreateEden<BasePath, LazyLoadElysia['_routes']>,\n\t\t\t\tEphemeral,\n\t\t\t\tPrettify2<Volatile & LazyLoadElysia['_ephemeral']>\n\t\t\t>\n\t\t: Elysia<\n\t\t\t\tBasePath,\n\t\t\t\tScoped,\n\t\t\t\tSingleton,\n\t\t\t\tDefinitions,\n\t\t\t\tMetadata,\n\t\t\t\tBasePath extends ``\n\t\t\t\t\t? Routes & LazyLoadElysia['_routes']\n\t\t\t\t\t: Routes & CreateEden<BasePath, LazyLoadElysia['_routes']>,\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\t/**\n\t * ### use\n\t * Merge separate logic of Elysia with current\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * const plugin = (app: Elysia) => app\n\t *     .get('/plugin', () => 'hi')\n\t *\n\t * new Elysia()\n\t *     .use(plugin)\n\t * ```\n\t */\n\tuse(\n\t\tplugin:\n\t\t\t| MaybePromise<AnyElysia>\n\t\t\t| MaybePromise<\n\t\t\t\t\tAnyElysia | ((app: AnyElysia) => MaybePromise<AnyElysia>)\n\t\t\t  >\n\t\t\t| Promise<{\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t| AnyElysia\n\t\t\t\t\t\t| ((app: AnyElysia) => MaybePromise<AnyElysia>)\n\t\t\t  }>,\n\t\toptions?: { scoped?: boolean }\n\t): AnyElysia {\n\t\tif (options?.scoped)\n\t\t\treturn this.guard({}, (app) => app.use(plugin as any))\n\n\t\tif (Array.isArray(plugin)) {\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-this-alias\n\t\t\tlet current = this\n\n\t\t\tfor (const p of plugin) current = this.use(p) as any\n\n\t\t\treturn current\n\t\t}\n\n\t\tif (plugin instanceof Promise) {\n\t\t\tthis.promisedModules.add(\n\t\t\t\tplugin\n\t\t\t\t\t.then((plugin) => {\n\t\t\t\t\t\tif (typeof plugin === 'function') return plugin(this)\n\n\t\t\t\t\t\tif (plugin instanceof Elysia) return this._use(plugin)\n\n\t\t\t\t\t\tif (typeof plugin.default === 'function')\n\t\t\t\t\t\t\treturn plugin.default(this)\n\n\t\t\t\t\t\tif (plugin.default instanceof Elysia)\n\t\t\t\t\t\t\treturn this._use(plugin.default)\n\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t'Invalid plugin type. Expected Elysia instance, function, or module with \"default\" as Elysia instance or function that returns Elysia instance.'\n\t\t\t\t\t\t)\n\t\t\t\t\t})\n\t\t\t\t\t.then((x) => x.compile())\n\t\t\t)\n\t\t\treturn this\n\t\t}\n\n\t\treturn this._use(plugin)\n\t}\n\n\tprivate _use(\n\t\tplugin: AnyElysia | ((app: AnyElysia) => MaybePromise<AnyElysia>)\n\t) {\n\t\tif (typeof plugin === 'function') {\n\t\t\tconst instance = plugin(this as unknown as any) as unknown as any\n\t\t\tif (instance instanceof Promise) {\n\t\t\t\tthis.promisedModules.add(\n\t\t\t\t\tinstance\n\t\t\t\t\t\t.then((plugin) => {\n\t\t\t\t\t\t\tif (plugin instanceof Elysia) {\n\t\t\t\t\t\t\t\tthis.compile()\n\n\t\t\t\t\t\t\t\t// Recompile async plugin routes\n\t\t\t\t\t\t\t\tfor (const {\n\t\t\t\t\t\t\t\t\tmethod,\n\t\t\t\t\t\t\t\t\tpath,\n\t\t\t\t\t\t\t\t\thandler,\n\t\t\t\t\t\t\t\t\thooks\n\t\t\t\t\t\t\t\t} of Object.values(plugin.router.history)) {\n\t\t\t\t\t\t\t\t\tthis.add(\n\t\t\t\t\t\t\t\t\t\tmethod,\n\t\t\t\t\t\t\t\t\t\tpath,\n\t\t\t\t\t\t\t\t\t\thandler,\n\t\t\t\t\t\t\t\t\t\tmergeHook(\n\t\t\t\t\t\t\t\t\t\t\thooks as LocalHook<\n\t\t\t\t\t\t\t\t\t\t\t\tany,\n\t\t\t\t\t\t\t\t\t\t\t\tany,\n\t\t\t\t\t\t\t\t\t\t\t\tany,\n\t\t\t\t\t\t\t\t\t\t\t\tany,\n\t\t\t\t\t\t\t\t\t\t\t\tany,\n\t\t\t\t\t\t\t\t\t\t\t\tany\n\t\t\t\t\t\t\t\t\t\t\t>,\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\terror: plugin.event.error\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treturn plugin\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (typeof plugin === 'function')\n\t\t\t\t\t\t\t\treturn plugin(\n\t\t\t\t\t\t\t\t\tthis as unknown as any\n\t\t\t\t\t\t\t\t) as unknown as Elysia\n\n\t\t\t\t\t\t\tif (typeof plugin.default === 'function')\n\t\t\t\t\t\t\t\treturn plugin.default(\n\t\t\t\t\t\t\t\t\tthis as unknown as any\n\t\t\t\t\t\t\t\t) as unknown as Elysia\n\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\treturn this._use(plugin)\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.then((x) => x.compile())\n\t\t\t\t)\n\t\t\t\treturn this as unknown as any\n\t\t\t}\n\n\t\t\treturn instance\n\t\t}\n\n\t\tif (plugin.promisedModules.size) {\n\t\t\tthis.promisedModules.add(\n\t\t\t\tplugin.modules\n\t\t\t\t\t.then(() => this._use(plugin))\n\t\t\t\t\t.then((x) => x.compile())\n\t\t\t)\n\t\t\treturn this\n\t\t}\n\n\t\tconst { name, seed } = plugin.config\n\n\t\tplugin.getServer = () => this.getServer()\n\n\t\t/**\n\t\t * Model and error is required for Swagger generation\n\t\t */\n\t\tplugin.model(this.definitions.type as any)\n\t\tplugin.error(this.definitions.error as any)\n\n\t\tconst isScoped = plugin.config.scoped as boolean\n\t\tif (isScoped) {\n\t\t\tif (name) {\n\t\t\t\tif (!(name in this.dependencies)) this.dependencies[name] = []\n\n\t\t\t\tconst current =\n\t\t\t\t\tseed !== undefined\n\t\t\t\t\t\t? checksum(name + JSON.stringify(seed))\n\t\t\t\t\t\t: 0\n\n\t\t\t\tif (\n\t\t\t\t\tthis.dependencies[name].some(\n\t\t\t\t\t\t({ checksum }) => current === checksum\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t\treturn this\n\n\t\t\t\tthis.dependencies[name].push(\n\t\t\t\t\t!this.config?.analytic\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tname: plugin.config.name,\n\t\t\t\t\t\t\t\tseed: plugin.config.seed,\n\t\t\t\t\t\t\t\tchecksum: current,\n\t\t\t\t\t\t\t\tdependencies: plugin.dependencies\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\tname: plugin.config.name,\n\t\t\t\t\t\t\t\tseed: plugin.config.seed,\n\t\t\t\t\t\t\t\tchecksum: current,\n\t\t\t\t\t\t\t\tdependencies: plugin.dependencies,\n\t\t\t\t\t\t\t\tstack: plugin.telemetry.stack,\n\t\t\t\t\t\t\t\troutes: plugin.router.history,\n\t\t\t\t\t\t\t\tdecorators: plugin.singleton.decorator,\n\t\t\t\t\t\t\t\tstore: plugin.singleton.store,\n\t\t\t\t\t\t\t\ttype: plugin.definitions.type,\n\t\t\t\t\t\t\t\terror: plugin.definitions.error,\n\t\t\t\t\t\t\t\tderive: plugin.event.transform\n\t\t\t\t\t\t\t\t\t.filter((x) => x.subType === 'derive')\n\t\t\t\t\t\t\t\t\t.map((x) => ({\n\t\t\t\t\t\t\t\t\t\tfn: x.fn.toString(),\n\t\t\t\t\t\t\t\t\t\tstack: new Error().stack ?? ''\n\t\t\t\t\t\t\t\t\t})),\n\t\t\t\t\t\t\t\tresolve: plugin.event.transform\n\t\t\t\t\t\t\t\t\t.filter((x) => x.subType === 'derive')\n\t\t\t\t\t\t\t\t\t.map((x) => ({\n\t\t\t\t\t\t\t\t\t\tfn: x.fn.toString(),\n\t\t\t\t\t\t\t\t\t\tstack: new Error().stack ?? ''\n\t\t\t\t\t\t\t\t\t}))\n\t\t\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\n\t\t\tplugin.extender.macros = this.extender.macros.concat(\n\t\t\t\tplugin.extender.macros\n\t\t\t)\n\n\t\t\tconst macroHashes = <(number | undefined)[]>[]\n\n\t\t\tfor (let i = 0; i < plugin.extender.macros.length; i++) {\n\t\t\t\tconst macro = this.extender.macros[i]\n\n\t\t\t\tif (macroHashes.includes(macro.checksum)) {\n\t\t\t\t\tplugin.extender.macros.splice(i, 1)\n\t\t\t\t\ti--\n\t\t\t\t}\n\n\t\t\t\tmacroHashes.push(macro.checksum)\n\t\t\t}\n\n\t\t\tplugin.onRequest((context) => {\n\t\t\t\tObject.assign(context, this.singleton.decorator)\n\t\t\t\tObject.assign(context.store, this.singleton.store)\n\t\t\t})\n\n\t\t\tif (plugin.event.trace.length)\n\t\t\t\tplugin.event.trace.push(...plugin.event.trace)\n\n\t\t\tif (!plugin.config.prefix)\n\t\t\t\tconsole.warn(\n\t\t\t\t\t\"It's recommended to use scoped instance with a prefix to prevent collision routing with other instance.\"\n\t\t\t\t)\n\n\t\t\tif (plugin.event.error.length)\n\t\t\t\tplugin.event.error.push(...this.event.error)\n\n\t\t\tif (plugin.config.aot) plugin.compile()\n\n\t\t\tif (isScoped === true && plugin.config.prefix) {\n\t\t\t\tthis.mount(plugin.config.prefix + '/', plugin.fetch)\n\n\t\t\t\t// Ensure that when using plugins routes are correctly showing up in the .routes property. Else plugins e.g. swagger will not correctly work.\n\t\t\t\t// This also avoids adding routes multiple times.\n\t\t\t\tfor (const route of plugin.router.history) {\n\t\t\t\t\tthis.routeTree.set(\n\t\t\t\t\t\troute.method + `${plugin.config.prefix}${route.path}`,\n\t\t\t\t\t\tthis.router.history.length\n\t\t\t\t\t)\n\n\t\t\t\t\tthis.router.history.push({\n\t\t\t\t\t\t...route,\n\t\t\t\t\t\tpath: `${plugin.config.prefix}${route.path}`,\n\t\t\t\t\t\thooks: mergeHook(route.hooks, {\n\t\t\t\t\t\t\terror: this.event.error\n\t\t\t\t\t\t})\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.mount(plugin.fetch)\n\n\t\t\t\tfor (const route of plugin.router.history) {\n\t\t\t\t\tthis.routeTree.set(\n\t\t\t\t\t\troute.method + `${plugin.config.prefix}${route.path}`,\n\t\t\t\t\t\tthis.router.history.length\n\t\t\t\t\t)\n\n\t\t\t\t\tthis.router.history.push({\n\t\t\t\t\t\t...route,\n\t\t\t\t\t\tpath: `${plugin.config.prefix}${route.path}`,\n\t\t\t\t\t\thooks: mergeHook(route.hooks, {\n\t\t\t\t\t\t\terror: this.event.error\n\t\t\t\t\t\t})\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this\n\t\t} else {\n\t\t\tthis.headers(plugin.setHeaders)\n\n\t\t\tplugin.reporter = this.reporter\n\t\t\tfor (const trace of plugin.event.trace)\n\t\t\t\tif (trace.scope && trace.scope !== 'local')\n\t\t\t\t\tthis.trace(trace as any)\n\n\t\t\tif (name) {\n\t\t\t\tif (!(name in this.dependencies)) this.dependencies[name] = []\n\n\t\t\t\tconst current =\n\t\t\t\t\tseed !== undefined\n\t\t\t\t\t\t? checksum(name + JSON.stringify(seed))\n\t\t\t\t\t\t: 0\n\n\t\t\t\tif (\n\t\t\t\t\t!this.dependencies[name].some(\n\t\t\t\t\t\t({ checksum }) => current === checksum\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t\tthis.extender.macros = this.extender.macros.concat(\n\t\t\t\t\t\tplugin.extender.macros\n\t\t\t\t\t)\n\t\t\t} else {\n\t\t\t\tthis.extender.macros = this.extender.macros.concat(\n\t\t\t\t\tplugin.extender.macros\n\t\t\t\t)\n\t\t\t}\n\n\t\t\tconst macroHashes: number[] = []\n\n\t\t\tfor (let i = 0; i < this.extender.macros.length; i++) {\n\t\t\t\tconst macro = this.extender.macros[i]\n\n\t\t\t\tif (macro.checksum) {\n\t\t\t\t\tif (macroHashes.includes(macro.checksum)) {\n\t\t\t\t\t\tthis.extender.macros.splice(i, 1)\n\t\t\t\t\t\ti--\n\t\t\t\t\t}\n\n\t\t\t\t\tmacroHashes.push(macro.checksum)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.inference = {\n\t\t\t\tevent: {\n\t\t\t\t\tbody:\n\t\t\t\t\t\tthis.inference.event.body ||\n\t\t\t\t\t\tplugin.inference.event.body,\n\t\t\t\t\tcookie:\n\t\t\t\t\t\tthis.inference.event.cookie ||\n\t\t\t\t\t\tplugin.inference.event.cookie,\n\t\t\t\t\theaders:\n\t\t\t\t\t\tthis.inference.event.headers ||\n\t\t\t\t\t\tplugin.inference.event.headers,\n\t\t\t\t\tqueries: [\n\t\t\t\t\t\t...this.inference.event.queries,\n\t\t\t\t\t\t...plugin.inference.event.queries\n\t\t\t\t\t],\n\t\t\t\t\tquery:\n\t\t\t\t\t\tthis.inference.event.query ||\n\t\t\t\t\t\tplugin.inference.event.query,\n\t\t\t\t\tset: this.inference.event.set || plugin.inference.event.set,\n\t\t\t\t\tunknownQueries:\n\t\t\t\t\t\tthis.inference.event.unknownQueries ||\n\t\t\t\t\t\tplugin.inference.event.unknownQueries\n\t\t\t\t},\n\t\t\t\ttrace: {\n\t\t\t\t\trequest:\n\t\t\t\t\t\tthis.inference.trace.request ||\n\t\t\t\t\t\tplugin.inference.trace.request,\n\t\t\t\t\tparse:\n\t\t\t\t\t\tthis.inference.trace.parse ||\n\t\t\t\t\t\tplugin.inference.trace.parse,\n\t\t\t\t\ttransform:\n\t\t\t\t\t\tthis.inference.trace.transform ||\n\t\t\t\t\t\tplugin.inference.trace.transform,\n\t\t\t\t\thandle:\n\t\t\t\t\t\tthis.inference.trace.handle ||\n\t\t\t\t\t\tplugin.inference.trace.handle,\n\t\t\t\t\tbeforeHandle:\n\t\t\t\t\t\tthis.inference.trace.beforeHandle ||\n\t\t\t\t\t\tplugin.inference.trace.beforeHandle,\n\t\t\t\t\tafterHandle:\n\t\t\t\t\t\tthis.inference.trace.afterHandle ||\n\t\t\t\t\t\tplugin.inference.trace.afterHandle,\n\t\t\t\t\terror:\n\t\t\t\t\t\tthis.inference.trace.error ||\n\t\t\t\t\t\tplugin.inference.trace.error,\n\t\t\t\t\tcontext:\n\t\t\t\t\t\tthis.inference.trace.context ||\n\t\t\t\t\t\tplugin.inference.trace.context,\n\t\t\t\t\tstore:\n\t\t\t\t\t\tthis.inference.trace.store ||\n\t\t\t\t\t\tplugin.inference.trace.store,\n\t\t\t\t\tset: this.inference.trace.set || plugin.inference.trace.set\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.decorate(plugin.singleton.decorator)\n\t\tthis.state(plugin.singleton.store)\n\t\tthis.model(plugin.definitions.type)\n\t\tthis.error(plugin.definitions.error as any)\n\n\t\tfor (const { method, path, handler, hooks } of Object.values(\n\t\t\tplugin.router.history\n\t\t)) {\n\t\t\tthis.add(\n\t\t\t\tmethod,\n\t\t\t\tpath,\n\t\t\t\thandler,\n\t\t\t\tmergeHook(\n\t\t\t\t\thooks as LocalHook<any, any, any, any, any, any, any>,\n\t\t\t\t\t{\n\t\t\t\t\t\terror: plugin.event.error\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t)\n\t\t}\n\n\t\tif (!isScoped)\n\t\t\tif (name) {\n\t\t\t\tif (!(name in this.dependencies)) this.dependencies[name] = []\n\n\t\t\t\tconst current =\n\t\t\t\t\tseed !== undefined\n\t\t\t\t\t\t? checksum(name + JSON.stringify(seed))\n\t\t\t\t\t\t: 0\n\n\t\t\t\tif (\n\t\t\t\t\tthis.dependencies[name].some(\n\t\t\t\t\t\t({ checksum }) => current === checksum\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t\treturn this\n\n\t\t\t\tthis.dependencies[name].push(\n\t\t\t\t\t!this.config?.analytic\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tname: plugin.config.name,\n\t\t\t\t\t\t\t\tseed: plugin.config.seed,\n\t\t\t\t\t\t\t\tchecksum: current,\n\t\t\t\t\t\t\t\tdependencies: plugin.dependencies\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\tname: plugin.config.name,\n\t\t\t\t\t\t\t\tseed: plugin.config.seed,\n\t\t\t\t\t\t\t\tchecksum: current,\n\t\t\t\t\t\t\t\tdependencies: plugin.dependencies,\n\t\t\t\t\t\t\t\tstack: plugin.telemetry.stack,\n\t\t\t\t\t\t\t\troutes: plugin.router.history,\n\t\t\t\t\t\t\t\tdecorators: plugin.singleton,\n\t\t\t\t\t\t\t\tstore: plugin.singleton.store,\n\t\t\t\t\t\t\t\ttype: plugin.definitions.type,\n\t\t\t\t\t\t\t\terror: plugin.definitions.error,\n\t\t\t\t\t\t\t\tderive: plugin.event.transform\n\t\t\t\t\t\t\t\t\t.filter((x) => x?.subType === 'derive')\n\t\t\t\t\t\t\t\t\t.map((x) => ({\n\t\t\t\t\t\t\t\t\t\tfn: x.toString(),\n\t\t\t\t\t\t\t\t\t\tstack: new Error().stack ?? ''\n\t\t\t\t\t\t\t\t\t})),\n\t\t\t\t\t\t\t\tresolve: plugin.event.transform\n\t\t\t\t\t\t\t\t\t.filter((x) => x?.subType === 'resolve')\n\t\t\t\t\t\t\t\t\t.map((x) => ({\n\t\t\t\t\t\t\t\t\t\tfn: x.toString(),\n\t\t\t\t\t\t\t\t\t\tstack: new Error().stack ?? ''\n\t\t\t\t\t\t\t\t\t}))\n\t\t\t\t\t\t\t}\n\t\t\t\t)\n\n\t\t\t\tthis.event = mergeLifeCycle(\n\t\t\t\t\tthis.event,\n\t\t\t\t\tfilterGlobalHook(plugin.event),\n\t\t\t\t\tcurrent\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\tthis.event = mergeLifeCycle(\n\t\t\t\t\tthis.event,\n\t\t\t\t\tfilterGlobalHook(plugin.event)\n\t\t\t\t)\n\t\t\t}\n\n\t\treturn this\n\t}\n\n\tmacro<const NewMacro extends BaseMacro>(\n\t\tmacro: (\n\t\t\troute: MacroManager<\n\t\t\t\tMetadata['schema'] & Ephemeral['schema'] & Volatile['schema'],\n\t\t\t\tSingleton & {\n\t\t\t\t\tderive: Partial<Ephemeral['derive'] & Volatile['derive']>\n\t\t\t\t\tresolve: Partial<Ephemeral['resolve'] & Volatile['resolve']>\n\t\t\t\t},\n\t\t\t\tDefinitions['error']\n\t\t\t>\n\t\t) => NewMacro\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\tDefinitions,\n\t\t{\n\t\t\tschema: Metadata['schema']\n\t\t\tmacro: Metadata['macro'] & Partial<MacroToProperty<NewMacro>>\n\t\t},\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tconst hook: MacroQueue = {\n\t\t\tchecksum: checksum(\n\t\t\t\tJSON.stringify({\n\t\t\t\t\tname: this.config.name,\n\t\t\t\t\tseed: this.config.seed,\n\t\t\t\t\tcontent: macro.toString()\n\t\t\t\t})\n\t\t\t),\n\t\t\tfn: macro as any\n\t\t}\n\n\t\tthis.extender.macros.push(hook)\n\n\t\treturn this as any\n\t}\n\n\tmount(\n\t\thandle: ((request: Request) => MaybePromise<Response>) | AnyElysia\n\t): this\n\tmount(\n\t\tpath: string,\n\t\thandle: ((request: Request) => MaybePromise<Response>) | AnyElysia\n\t): this\n\n\tmount(\n\t\tpath:\n\t\t\t| string\n\t\t\t| ((request: Request) => MaybePromise<Response>)\n\t\t\t| AnyElysia,\n\t\thandle?: ((request: Request) => MaybePromise<Response>) | AnyElysia\n\t) {\n\t\tif (\n\t\t\tpath instanceof Elysia ||\n\t\t\ttypeof path === 'function' ||\n\t\t\tpath.length === 0 ||\n\t\t\tpath === '/'\n\t\t) {\n\t\t\tconst run =\n\t\t\t\ttypeof path === 'function'\n\t\t\t\t\t? path\n\t\t\t\t\t: path instanceof Elysia\n\t\t\t\t\t\t? path.compile().fetch\n\t\t\t\t\t\t: handle instanceof Elysia\n\t\t\t\t\t\t\t? handle.compile().fetch\n\t\t\t\t\t\t\t: handle!\n\n\t\t\tconst handler: Handler<any, any> = async ({ request, path }) =>\n\t\t\t\trun(\n\t\t\t\t\tnew Request(\n\t\t\t\t\t\treplaceUrlPath(request.url, path || '/'),\n\t\t\t\t\t\trequest\n\t\t\t\t\t)\n\t\t\t\t)\n\n\t\t\tthis.all(\n\t\t\t\t'/*',\n\t\t\t\thandler as any,\n\t\t\t\t{\n\t\t\t\t\ttype: 'none'\n\t\t\t\t} as any\n\t\t\t)\n\n\t\t\treturn this\n\t\t}\n\n\t\tconst length = path.length\n\n\t\tif (handle instanceof Elysia) handle = handle.compile().fetch\n\n\t\tconst handler: Handler<any, any> = async ({ request, path }) =>\n\t\t\t(handle as Function)!(\n\t\t\t\tnew Request(\n\t\t\t\t\treplaceUrlPath(request.url, path.slice(length) || '/'),\n\t\t\t\t\trequest\n\t\t\t\t)\n\t\t\t)\n\n\t\tthis.all(\n\t\t\tpath,\n\t\t\thandler as any,\n\t\t\t{\n\t\t\t\ttype: 'none'\n\t\t\t} as any\n\t\t)\n\n\t\tthis.all(\n\t\t\tpath + (path.endsWith('/') ? '*' : '/*'),\n\t\t\thandler as any,\n\t\t\t{\n\t\t\t\ttype: 'none'\n\t\t\t} as any\n\t\t)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### get\n\t * Register handler for path with method [GET]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .get('/', () => 'hi')\n\t *     .get('/with-hook', () => 'hi', {\n\t *         response: t.String()\n\t *     })\n\t * ```\n\t */\n\tget<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['type'] & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tMetadata['schema'] & Ephemeral['schema'] & Volatile['schema']\n\t\t>,\n\t\tconst Handle extends InlineHandler<\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\t`${BasePath}${Path extends '/' ? '' : Path}`\n\t\t>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\tDefinitions['error'],\n\t\t\tMetadata['macro'],\n\t\t\t`${BasePath}${Path extends '/' ? '/index' : Path}`\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\t`${BasePath & string}${Path extends '/' ? '/index' : Path}`,\n\t\t\t\t{\n\t\t\t\t\tget: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: undefined extends Schema['params']\n\t\t\t\t\t\t\t? Record<GetPathParameter<Path>, string>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: ComposeElysiaResponse<\n\t\t\t\t\t\t\tSchema['response'],\n\t\t\t\t\t\t\tHandle\n\t\t\t\t\t\t>\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis.add('GET', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### post\n\t * Register handler for path with method [POST]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .post('/', () => 'hi')\n\t *     .post('/with-hook', () => 'hi', {\n\t *         response: t.String()\n\t *     })\n\t * ```\n\t */\n\tpost<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['type'] & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tMetadata['schema'] & Ephemeral['schema'] & Volatile['schema']\n\t\t>,\n\t\tconst Handle extends InlineHandler<\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\t`${BasePath}${Path extends '/' ? '/index' : Path}`\n\t\t>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\tDefinitions['error'],\n\t\t\tMetadata['macro'],\n\t\t\t`${BasePath}${Path extends '/' ? '/index' : Path}`\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\t`${BasePath & string}${Path extends '/' ? '/index' : Path}`,\n\t\t\t\t{\n\t\t\t\t\tpost: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: undefined extends Schema['params']\n\t\t\t\t\t\t\t? Record<GetPathParameter<Path>, string>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: ComposeElysiaResponse<\n\t\t\t\t\t\t\tSchema['response'],\n\t\t\t\t\t\t\tHandle\n\t\t\t\t\t\t>\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis.add('POST', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### put\n\t * Register handler for path with method [PUT]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .put('/', () => 'hi')\n\t *     .put('/with-hook', () => 'hi', {\n\t *         response: t.String()\n\t *     })\n\t * ```\n\t */\n\tput<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['type'] & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tMetadata['schema'] & Ephemeral['schema'] & Volatile['schema']\n\t\t>,\n\t\tconst Handle extends InlineHandler<\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\t`${BasePath}${Path extends '/' ? '/index' : Path}`\n\t\t>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\tDefinitions['error'],\n\t\t\tMetadata['macro'],\n\t\t\t`${BasePath}${Path extends '/' ? '/index' : Path}`\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\t`${BasePath & string}${Path extends '/' ? '/index' : Path}`,\n\t\t\t\t{\n\t\t\t\t\tput: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: undefined extends Schema['params']\n\t\t\t\t\t\t\t? Record<GetPathParameter<Path>, string>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: ComposeElysiaResponse<\n\t\t\t\t\t\t\tSchema['response'],\n\t\t\t\t\t\t\tHandle\n\t\t\t\t\t\t>\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis.add('PUT', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### patch\n\t * Register handler for path with method [PATCH]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .patch('/', () => 'hi')\n\t *     .patch('/with-hook', () => 'hi', {\n\t *         response: t.String()\n\t *     })\n\t * ```\n\t */\n\tpatch<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['type'] & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tMetadata['schema'] & Ephemeral['schema'] & Volatile['schema']\n\t\t>,\n\t\tconst Handle extends InlineHandler<\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\t`${BasePath}${Path extends '/' ? '/index' : Path}`\n\t\t>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\tDefinitions['error'],\n\t\t\tMetadata['macro'],\n\t\t\t`${BasePath}${Path extends '/' ? '/index' : Path}`\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\t`${BasePath & string}${Path extends '/' ? '/index' : Path}`,\n\t\t\t\t{\n\t\t\t\t\tpatch: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: undefined extends Schema['params']\n\t\t\t\t\t\t\t? Record<GetPathParameter<Path>, string>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: ComposeElysiaResponse<\n\t\t\t\t\t\t\tSchema['response'],\n\t\t\t\t\t\t\tHandle\n\t\t\t\t\t\t>\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis.add('PATCH', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### delete\n\t * Register handler for path with method [DELETE]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .delete('/', () => 'hi')\n\t *     .delete('/with-hook', () => 'hi', {\n\t *         response: t.String()\n\t *     })\n\t * ```\n\t */\n\tdelete<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['type'] & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tMetadata['schema'] & Ephemeral['schema'] & Volatile['schema']\n\t\t>,\n\t\tconst Handle extends InlineHandler<\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\t`${BasePath}${Path extends '/' ? '/index' : Path}`\n\t\t>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\tDefinitions['error'],\n\t\t\tMetadata['macro'],\n\t\t\t`${BasePath}${Path extends '/' ? '/index' : Path}`\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\t`${BasePath & string}${Path extends '/' ? '/index' : Path}`,\n\t\t\t\t{\n\t\t\t\t\tdelete: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: undefined extends Schema['params']\n\t\t\t\t\t\t\t? Record<GetPathParameter<Path>, string>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: ComposeElysiaResponse<\n\t\t\t\t\t\t\tSchema['response'],\n\t\t\t\t\t\t\tHandle\n\t\t\t\t\t\t>\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis.add('DELETE', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### options\n\t * Register handler for path with method [POST]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .options('/', () => 'hi')\n\t *     .options('/with-hook', () => 'hi', {\n\t *         response: t.String()\n\t *     })\n\t * ```\n\t */\n\toptions<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['type'] & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tMetadata['schema'] & Ephemeral['schema'] & Volatile['schema']\n\t\t>,\n\t\tconst Handle extends InlineHandler<\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\t`${BasePath}${Path extends '/' ? '/index' : Path}`\n\t\t>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\tDefinitions['error'],\n\t\t\tMetadata['macro'],\n\t\t\t`${BasePath}${Path extends '/' ? '/index' : Path}`\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\t`${BasePath & string}${Path extends '/' ? '/index' : Path}`,\n\t\t\t\t{\n\t\t\t\t\toptions: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: undefined extends Schema['params']\n\t\t\t\t\t\t\t? Record<GetPathParameter<Path>, string>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: ComposeElysiaResponse<\n\t\t\t\t\t\t\tSchema['response'],\n\t\t\t\t\t\t\tHandle\n\t\t\t\t\t\t>\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis.add('OPTIONS', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### all\n\t * Register handler for path with method [ALL]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .all('/', () => 'hi')\n\t *     .all('/with-hook', () => 'hi', {\n\t *         response: t.String()\n\t *     })\n\t * ```\n\t */\n\tall<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['type'] & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tMetadata['schema'] & Ephemeral['schema'] & Volatile['schema']\n\t\t>,\n\t\tconst Handle extends InlineHandler<\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\t`${BasePath}${Path extends '/' ? '/index' : Path}`\n\t\t>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\tDefinitions['error'],\n\t\t\tMetadata['macro'],\n\t\t\t`${BasePath}${Path extends '/' ? '/index' : Path}`\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\t`${BasePath & string}${Path extends '/' ? '/index' : Path}`,\n\t\t\t\t{\n\t\t\t\t\t[method in string]: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: undefined extends Schema['params']\n\t\t\t\t\t\t\t? Record<GetPathParameter<Path>, string>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: ComposeElysiaResponse<\n\t\t\t\t\t\t\tSchema['response'],\n\t\t\t\t\t\t\tHandle\n\t\t\t\t\t\t>\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis.add('ALL', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### head\n\t * Register handler for path with method [HEAD]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .head('/', () => 'hi')\n\t *     .head('/with-hook', () => 'hi', {\n\t *         response: t.String()\n\t *     })\n\t * ```\n\t */\n\thead<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['type'] & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tMetadata['schema'] & Ephemeral['schema'] & Volatile['schema']\n\t\t>,\n\t\tconst Handle extends InlineHandler<\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\t`${BasePath}${Path extends '/' ? '/index' : Path}`\n\t\t>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\tDefinitions['error'],\n\t\t\tMetadata['macro'],\n\t\t\t`${BasePath}${Path extends '/' ? '/index' : Path}`\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\t`${BasePath & string}${Path extends '/' ? '/index' : Path}`,\n\t\t\t\t{\n\t\t\t\t\thead: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: undefined extends Schema['params']\n\t\t\t\t\t\t\t? Record<GetPathParameter<Path>, string>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: ComposeElysiaResponse<\n\t\t\t\t\t\t\tSchema['response'],\n\t\t\t\t\t\t\tHandle\n\t\t\t\t\t\t>\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis.add('HEAD', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### connect\n\t * Register handler for path with method [CONNECT]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .connect('/', () => 'hi')\n\t *     .connect('/with-hook', () => 'hi', {\n\t *         response: t.String()\n\t *     })\n\t * ```\n\t */\n\tconnect<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['type'] & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tMetadata['schema'] & Ephemeral['schema'] & Volatile['schema']\n\t\t>,\n\t\tconst Handle extends InlineHandler<\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\t`${BasePath}${Path extends '/' ? '/index' : Path}`\n\t\t>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\tDefinitions['error'],\n\t\t\tMetadata['macro'],\n\t\t\t`${BasePath}${Path extends '/' ? '/index' : Path}`\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\t`${BasePath & string}${Path extends '/' ? '/index' : Path}`,\n\t\t\t\t{\n\t\t\t\t\tconnect: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: undefined extends Schema['params']\n\t\t\t\t\t\t\t? Record<GetPathParameter<Path>, string>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: ComposeElysiaResponse<\n\t\t\t\t\t\t\tSchema['response'],\n\t\t\t\t\t\t\tHandle\n\t\t\t\t\t\t>\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis.add('CONNECT', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### route\n\t * Register handler for path with method [ROUTE]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .route('/', () => 'hi')\n\t *     .route('/with-hook', () => 'hi', {\n\t *         response: t.String()\n\t *     })\n\t * ```\n\t */\n\troute<\n\t\tconst Method extends HTTPMethod,\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['type'] & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tMetadata['schema'] & Ephemeral['schema'] & Volatile['schema']\n\t\t>,\n\t\tconst Handle extends InlineHandler<\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\t`${BasePath}${Path extends '/' ? '/index' : Path}`\n\t\t>\n\t>(\n\t\tmethod: Method,\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\tDefinitions['error'],\n\t\t\tMetadata['macro'],\n\t\t\t`${BasePath}${Path extends '/' ? '/index' : Path}`\n\t\t> & {\n\t\t\tconfig: {\n\t\t\t\tallowMeta?: boolean\n\t\t\t}\n\t\t}\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\t`${BasePath & string}${Path extends '/' ? '/index' : Path}`,\n\t\t\t\t{\n\t\t\t\t\t[method in Method]: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: undefined extends Schema['params']\n\t\t\t\t\t\t\t? Record<GetPathParameter<Path>, string>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: ComposeElysiaResponse<\n\t\t\t\t\t\t\tSchema['response'],\n\t\t\t\t\t\t\tHandle\n\t\t\t\t\t\t>\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis.add(method.toUpperCase(), path, handler as any, hook, hook?.config)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### ws\n\t * Register handler for path with method [ws]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .ws('/', {\n\t *         message(ws, message) {\n\t *             ws.send(message)\n\t *         }\n\t *     })\n\t * ```\n\t */\n\tws<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['type'] & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tMetadata['schema']\n\t\t>\n\t>(\n\t\tpath: Path,\n\t\toptions: WS.LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\tDefinitions['error'],\n\t\t\tMetadata['macro'],\n\t\t\t`${BasePath}${Path extends '/' ? '/index' : Path}`\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\t`${BasePath}${Path extends '/' ? '/index' : Path}`,\n\t\t\t\t{\n\t\t\t\t\tsubscribe: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: undefined extends Schema['params']\n\t\t\t\t\t\t\t? Record<GetPathParameter<Path>, string>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: Schema['response']\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tconst transform = options.transformMessage\n\t\t\t? Array.isArray(options.transformMessage)\n\t\t\t\t? options.transformMessage\n\t\t\t\t: [options.transformMessage]\n\t\t\t: undefined\n\n\t\tlet server: Server | null = null\n\n\t\tconst validateMessage = getSchemaValidator(options?.body, {\n\t\t\tmodels: this.definitions.type as Record<string, TSchema>,\n\t\t\tnormalize: this.config.normalize\n\t\t})\n\n\t\tconst validateResponse = getSchemaValidator(options?.response as any, {\n\t\t\tmodels: this.definitions.type as Record<string, TSchema>,\n\t\t\tnormalize: this.config.normalize\n\t\t})\n\n\t\tconst parseMessage = (message: any) => {\n\t\t\tif (typeof message === 'string') {\n\t\t\t\tconst start = message?.charCodeAt(0)\n\n\t\t\t\tif (start === 47 || start === 123)\n\t\t\t\t\ttry {\n\t\t\t\t\t\tmessage = JSON.parse(message)\n\t\t\t\t\t} catch {\n\t\t\t\t\t\t// Not empty\n\t\t\t\t\t}\n\t\t\t\telse if (isNumericString(message)) message = +message\n\t\t\t}\n\n\t\t\tif (transform?.length)\n\t\t\t\tfor (let i = 0; i < transform.length; i++) {\n\t\t\t\t\tconst temp = transform[i](message)\n\n\t\t\t\t\tif (temp !== undefined) message = temp\n\t\t\t\t}\n\n\t\t\treturn message\n\t\t}\n\n\t\tthis.route(\n\t\t\t'$INTERNALWS',\n\t\t\tpath as any,\n\t\t\t// @ts-expect-error\n\t\t\t(context) => {\n\t\t\t\t// ! Enable static code analysis just in case resolveUnknownFunction doesn't work, do not remove\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\t\t\tconst { set, path, qi, headers, query, params } = context\n\n\t\t\t\tif (server === null) server = this.getServer()\n\n\t\t\t\tif (\n\t\t\t\t\tserver?.upgrade<any>(context.request, {\n\t\t\t\t\t\theaders: (typeof options.upgrade === 'function'\n\t\t\t\t\t\t\t? options.upgrade(context as any as Context)\n\t\t\t\t\t\t\t: options.upgrade) as Bun.HeadersInit,\n\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\tvalidator: validateResponse,\n\t\t\t\t\t\t\topen(ws: ServerWebSocket<any>) {\n\t\t\t\t\t\t\t\toptions.open?.(new ElysiaWS(ws, context as any))\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tmessage: (ws: ServerWebSocket<any>, msg: any) => {\n\t\t\t\t\t\t\t\tconst message = parseMessage(msg)\n\n\t\t\t\t\t\t\t\tif (validateMessage?.Check(message) === false)\n\t\t\t\t\t\t\t\t\treturn void ws.send(\n\t\t\t\t\t\t\t\t\t\tnew ValidationError(\n\t\t\t\t\t\t\t\t\t\t\t'message',\n\t\t\t\t\t\t\t\t\t\t\tvalidateMessage,\n\t\t\t\t\t\t\t\t\t\t\tmessage\n\t\t\t\t\t\t\t\t\t\t).message as string\n\t\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\t\toptions.message?.(\n\t\t\t\t\t\t\t\t\tnew ElysiaWS(ws, context as any),\n\t\t\t\t\t\t\t\t\tmessage as any\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdrain(ws: ServerWebSocket<any>) {\n\t\t\t\t\t\t\t\toptions.drain?.(\n\t\t\t\t\t\t\t\t\tnew ElysiaWS(ws, context as any)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tclose(\n\t\t\t\t\t\t\t\tws: ServerWebSocket<any>,\n\t\t\t\t\t\t\t\tcode: number,\n\t\t\t\t\t\t\t\treason: string\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\toptions.close?.(\n\t\t\t\t\t\t\t\t\tnew ElysiaWS(ws, context as any),\n\t\t\t\t\t\t\t\t\tcode,\n\t\t\t\t\t\t\t\t\treason\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t\t\treturn\n\n\t\t\t\tset.status = 400\n\n\t\t\t\treturn 'Expected a websocket connection'\n\t\t\t},\n\t\t\t{\n\t\t\t\tbeforeHandle: options.beforeHandle,\n\t\t\t\ttransform: options.transform,\n\t\t\t\theaders: options.headers,\n\t\t\t\tparams: options.params,\n\t\t\t\tquery: options.query\n\t\t\t} as any\n\t\t)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### state\n\t * Assign global mutatable state accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .state({ counter: 0 })\n\t *     .get('/', (({ counter }) => ++counter)\n\t * ```\n\t */\n\tstate<const Name extends string | number | symbol, Value>(\n\t\tname: Name,\n\t\tvalue: Value\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\t{\n\t\t\tdecorator: Singleton['decorator']\n\t\t\tstore: Prettify<\n\t\t\t\tSingleton['store'] & {\n\t\t\t\t\t[name in Name]: Value\n\t\t\t\t}\n\t\t\t>\n\t\t\tderive: Singleton['derive']\n\t\t\tresolve: Singleton['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * ### state\n\t * Assign global mutatable state accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .state('counter', 0)\n\t *     .get('/', (({ counter }) => ++counter)\n\t * ```\n\t */\n\tstate<Store extends Record<string, unknown>>(\n\t\tstore: Store\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\t{\n\t\t\tdecorator: Singleton['decorator']\n\t\t\tstore: Prettify<Singleton['store'] & Store>\n\t\t\tderive: Singleton['derive']\n\t\t\tresolve: Singleton['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\tstate<NewStore extends Record<string, unknown>>(\n\t\tmapper: (decorators: Singleton['store']) => NewStore\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\t{\n\t\t\tdecorator: Singleton['decorator']\n\t\t\tstore: NewStore\n\t\t\tderive: Singleton['derive']\n\t\t\tresolve: Singleton['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * ### state\n\t * Assign global mutatable state accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .state('counter', 0)\n\t *     .get('/', (({ counter }) => ++counter)\n\t * ```\n\t */\n\tstate(\n\t\tname: string | number | symbol | Record<string, unknown> | Function,\n\t\tvalue?: unknown\n\t) {\n\t\tswitch (typeof name) {\n\t\t\tcase 'object':\n\t\t\t\tthis.singleton.store = mergeDeep(this.singleton.store, name)\n\n\t\t\t\treturn this as any\n\n\t\t\tcase 'function':\n\t\t\t\tthis.singleton.store = name(this.singleton.store)\n\n\t\t\t\treturn this as any\n\t\t}\n\n\t\tif (!(name in this.singleton.store)) {\n\t\t\t// eslint-disable-next-line no-extra-semi\n\t\t\t;(\n\t\t\t\tthis.singleton.store as Record<\n\t\t\t\t\tstring | number | symbol,\n\t\t\t\t\tunknown\n\t\t\t\t>\n\t\t\t)[name] = value\n\t\t}\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### decorate\n\t * Define custom method to `Context` accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .decorate('getDate', () => Date.now())\n\t *     .get('/', (({ getDate }) => getDate())\n\t * ```\n\t */\n\tdecorate<const Name extends string, const Value>(\n\t\tname: Name,\n\t\tvalue: Value\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\t{\n\t\t\tdecorator: Prettify<\n\t\t\t\tSingleton['decorator'] & {\n\t\t\t\t\t[name in Name]: Value\n\t\t\t\t}\n\t\t\t>\n\t\t\tstore: Singleton['store']\n\t\t\tderive: Singleton['derive']\n\t\t\tresolve: Singleton['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * ### decorate\n\t * Define custom method to `Context` accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .decorate('getDate', () => Date.now())\n\t *     .get('/', (({ getDate }) => getDate())\n\t * ```\n\t */\n\tdecorate<const NewDecorators extends Record<string, unknown>>(\n\t\tdecorators: NewDecorators\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\t{\n\t\t\tdecorator: Prettify<Singleton['decorator'] & NewDecorators>\n\t\t\tstore: Singleton['store']\n\t\t\tderive: Singleton['derive']\n\t\t\tresolve: Singleton['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\tdecorate<const NewDecorators extends Record<string, unknown>>(\n\t\tmapper: (decorators: Singleton['decorator']) => NewDecorators\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\t{\n\t\t\tdecorator: NewDecorators\n\t\t\tstore: Singleton['store']\n\t\t\tderive: Singleton['derive']\n\t\t\tresolve: Singleton['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * ### decorate\n\t * Define custom method to `Context` accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .decorate('getDate', () => Date.now())\n\t *     .get('/', (({ getDate }) => getDate())\n\t * ```\n\t */\n\tdecorate(\n\t\tname: string | Record<string, unknown> | Function,\n\t\tvalue?: unknown\n\t) {\n\t\tswitch (typeof name) {\n\t\t\tcase 'object':\n\t\t\t\tthis.singleton.decorator = mergeDeep(\n\t\t\t\t\tthis.singleton.decorator,\n\t\t\t\t\tname\n\t\t\t\t)\n\n\t\t\t\treturn this as any\n\n\t\t\tcase 'function':\n\t\t\t\tthis.singleton.decorator = name(this.singleton.decorator)\n\n\t\t\t\treturn this as any\n\t\t}\n\n\t\tif (!(name in this.singleton.decorator))\n\t\t\tthis.singleton.decorator[name] = value\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * Derive new property for each request with access to `Context`.\n\t *\n\t * If error is thrown, the scope will skip to handling error instead.\n\t *\n\t * ---\n\t * @example\n\t * new Elysia()\n\t *     .state('counter', 1)\n\t *     .derive(({ store }) => ({\n\t *         increase() {\n\t *             store.counter++\n\t *         }\n\t *     }))\n\t */\n\tderive<const Derivative extends Record<string, unknown>>(\n\t\ttransform: (\n\t\t\tcontext: Prettify<\n\t\t\t\tContext<\n\t\t\t\t\tMetadata['schema'] &\n\t\t\t\t\t\tEphemeral['schema'] &\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\tSingleton & {\n\t\t\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t\t\t}\n\t\t\t\t>\n\t\t\t>\n\t\t) => MaybePromise<Derivative>\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\t{\n\t\t\tderive: Prettify<\n\t\t\t\tVolatile['derive'] &\n\t\t\t\t\t// Exclude `return error`\n\t\t\t\t\tExcludeElysiaResponse<Derivative>\n\t\t\t>\n\t\t\tresolve: Volatile['resolve']\n\t\t\tschema: Volatile['schema']\n\t\t}\n\t>\n\n\t/**\n\t * Derive new property for each request with access to `Context`.\n\t *\n\t * If error is thrown, the scope will skip to handling error instead.\n\t *\n\t * ---\n\t * @example\n\t * new Elysia()\n\t *     .state('counter', 1)\n\t *     .derive(({ store }) => ({\n\t *         increase() {\n\t *             store.counter++\n\t *         }\n\t *     }))\n\t */\n\tderive<\n\t\tconst Derivative extends Record<string, unknown>,\n\t\tconst Type extends LifeCycleType\n\t>(\n\t\toptions: { as?: Type },\n\t\ttransform: (\n\t\t\tcontext: Prettify<\n\t\t\t\tContext<\n\t\t\t\t\tMetadata['schema'] &\n\t\t\t\t\t\tEphemeral['schema'] &\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\tSingleton &\n\t\t\t\t\t\t('global' extends Type\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tderive: Partial<\n\t\t\t\t\t\t\t\t\t\tEphemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\tresolve: Partial<\n\t\t\t\t\t\t\t\t\t\tEphemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\t\tPartial<Volatile['derive']>\n\t\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\t\tPartial<Volatile['resolve']>\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t\t\t}),\n\t\t\t\t\tBasePath\n\t\t\t\t>\n\t\t\t>\n\t\t) => MaybePromise<Derivative>\n\t): Type extends 'global'\n\t\t? Elysia<\n\t\t\t\tBasePath,\n\t\t\t\tScoped,\n\t\t\t\t{\n\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\tderive: Singleton['resolve']\n\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\tSingleton['resolve'] & ExcludeElysiaResponse<Derivative>\n\t\t\t\t\t>\n\t\t\t\t},\n\t\t\t\tDefinitions,\n\t\t\t\tMetadata,\n\t\t\t\tRoutes,\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\t\t: Type extends 'scoped'\n\t\t\t? Elysia<\n\t\t\t\t\tBasePath,\n\t\t\t\t\tScoped,\n\t\t\t\t\tSingleton,\n\t\t\t\t\tDefinitions,\n\t\t\t\t\tMetadata,\n\t\t\t\t\tRoutes,\n\t\t\t\t\t{\n\t\t\t\t\t\tderive: Ephemeral['resolve']\n\t\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\t\tEphemeral['resolve'] &\n\t\t\t\t\t\t\t\tExcludeElysiaResponse<Derivative>\n\t\t\t\t\t\t>\n\t\t\t\t\t\tschema: Ephemeral['schema']\n\t\t\t\t\t},\n\t\t\t\t\tVolatile\n\t\t\t\t>\n\t\t\t: Elysia<\n\t\t\t\t\tBasePath,\n\t\t\t\t\tScoped,\n\t\t\t\t\tSingleton,\n\t\t\t\t\tDefinitions,\n\t\t\t\t\tMetadata,\n\t\t\t\t\tRoutes,\n\t\t\t\t\tEphemeral,\n\t\t\t\t\t{\n\t\t\t\t\t\tderive: Volatile['resolve']\n\t\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\t\tVolatile['resolve'] &\n\t\t\t\t\t\t\t\tExcludeElysiaResponse<Derivative>\n\t\t\t\t\t\t>\n\t\t\t\t\t\tschema: Volatile['schema']\n\t\t\t\t\t}\n\t\t\t\t>\n\n\tderive(\n\t\toptionsOrTransform: { as?: LifeCycleType } | Function,\n\t\ttransform?: Function\n\t) {\n\t\tif (!transform) {\n\t\t\ttransform = optionsOrTransform as any\n\t\t\toptionsOrTransform = { as: 'local' }\n\t\t}\n\n\t\tconst hook: HookContainer = {\n\t\t\tsubType: 'derive',\n\t\t\tfn: transform!\n\t\t}\n\n\t\treturn this.onTransform(optionsOrTransform as any, hook as any) as any\n\t}\n\n\tmodel<const Name extends string, const Model extends TSchema>(\n\t\tname: Name,\n\t\tmodel: Model\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\t{\n\t\t\ttype: Prettify<\n\t\t\t\tDefinitions['type'] & { [name in Name]: Static<Model> }\n\t\t\t>\n\t\t\terror: Definitions['error']\n\t\t},\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\tmodel<const Recorder extends Record<string, TSchema>>(\n\t\trecord: Recorder\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\t{\n\t\t\ttype: Prettify<\n\t\t\t\tDefinitions['type'] & {\n\t\t\t\t\t[key in keyof Recorder]: Static<Recorder[key]>\n\t\t\t\t}\n\t\t\t>\n\t\t\terror: Definitions['error']\n\t\t},\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\tmodel<const NewType extends Record<string, TSchema>>(\n\t\tmapper: (decorators: {\n\t\t\t[type in keyof Definitions['type']]: ReturnType<\n\t\t\t\ttypeof t.Unsafe<Definitions['type'][type]>\n\t\t\t>\n\t\t}) => NewType\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\t{\n\t\t\ttype: { [x in keyof NewType]: Static<NewType[x]> }\n\t\t\terror: Definitions['error']\n\t\t},\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\tmodel(name: string | Record<string, TSchema> | Function, model?: TSchema) {\n\t\tswitch (typeof name) {\n\t\t\tcase 'object':\n\t\t\t\tObject.entries(name).forEach(([key, value]) => {\n\t\t\t\t\tif (!(key in this.definitions.type))\n\t\t\t\t\t\tthis.definitions.type[key] = value as TSchema\n\t\t\t\t})\n\n\t\t\t\treturn this\n\n\t\t\tcase 'function':\n\t\t\t\tthis.definitions.type = name(this.definitions.type)\n\n\t\t\t\treturn this as any\n\t\t}\n\n\t\t;(this.definitions.type as Record<string, TSchema>)[name] = model!\n\n\t\treturn this as any\n\t}\n\n\tmapDerive<const NewDerivative extends Record<string, unknown>>(\n\t\tmapper: (\n\t\t\tcontext: Context<\n\t\t\t\tMetadata['schema'] & Ephemeral['schema'] & Volatile['schema'],\n\t\t\t\tSingleton & {\n\t\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t\t},\n\t\t\t\tBasePath\n\t\t\t>\n\t\t) => MaybePromise<NewDerivative>\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\t{\n\t\t\tderive: NewDerivative\n\t\t\tresolve: Volatile['resolve']\n\t\t\tschema: Volatile['schema']\n\t\t}\n\t>\n\n\tmapDerive<\n\t\tconst NewDerivative extends Record<string, unknown>,\n\t\tconst Type extends LifeCycleType\n\t>(\n\t\toptions: { as?: Type },\n\t\tmapper: (\n\t\t\tcontext: Context<\n\t\t\t\tMetadata['schema'] & Ephemeral['schema'] & Volatile['schema'],\n\t\t\t\tSingleton &\n\t\t\t\t\t('global' extends Type\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tderive: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tresolve: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['resolve'] & Volatile['resolve']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['derive']>\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['resolve']>\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t\t}),\n\t\t\t\tBasePath\n\t\t\t>\n\t\t) => MaybePromise<NewDerivative>\n\t): Type extends 'global'\n\t\t? Elysia<\n\t\t\t\tBasePath,\n\t\t\t\tScoped,\n\t\t\t\t{\n\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\tderive: Singleton['resolve']\n\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\tSingleton['resolve'] &\n\t\t\t\t\t\t\tExcludeElysiaResponse<NewDerivative>\n\t\t\t\t\t>\n\t\t\t\t},\n\t\t\t\tDefinitions,\n\t\t\t\tMetadata,\n\t\t\t\tRoutes,\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\t\t: Type extends 'scoped'\n\t\t\t? Elysia<\n\t\t\t\t\tBasePath,\n\t\t\t\t\tScoped,\n\t\t\t\t\tSingleton,\n\t\t\t\t\tDefinitions,\n\t\t\t\t\tMetadata,\n\t\t\t\t\tRoutes,\n\t\t\t\t\t{\n\t\t\t\t\t\tderive: Ephemeral['resolve']\n\t\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\t\tEphemeral['resolve'] &\n\t\t\t\t\t\t\t\tExcludeElysiaResponse<NewDerivative>\n\t\t\t\t\t\t>\n\t\t\t\t\t\tschema: Ephemeral['schema']\n\t\t\t\t\t},\n\t\t\t\t\tVolatile\n\t\t\t\t>\n\t\t\t: Elysia<\n\t\t\t\t\tBasePath,\n\t\t\t\t\tScoped,\n\t\t\t\t\tSingleton,\n\t\t\t\t\tDefinitions,\n\t\t\t\t\tMetadata,\n\t\t\t\t\tRoutes,\n\t\t\t\t\tEphemeral,\n\t\t\t\t\t{\n\t\t\t\t\t\tderive: Volatile['resolve']\n\t\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\t\tVolatile['resolve'] &\n\t\t\t\t\t\t\t\tExcludeElysiaResponse<NewDerivative>\n\t\t\t\t\t\t>\n\t\t\t\t\t\tschema: Volatile['schema']\n\t\t\t\t\t}\n\t\t\t\t>\n\n\tmapDerive(\n\t\toptionsOrDerive: { as?: LifeCycleType } | Function,\n\t\tmapper?: Function\n\t) {\n\t\tif (!mapper) {\n\t\t\tmapper = optionsOrDerive as any\n\t\t\toptionsOrDerive = { as: 'local' }\n\t\t}\n\n\t\tconst hook: HookContainer = {\n\t\t\tsubType: 'derive',\n\t\t\tfn: mapper!\n\t\t}\n\n\t\treturn this.onTransform(optionsOrDerive as any, hook as any) as any\n\t}\n\n\taffix<\n\t\tconst Base extends 'prefix' | 'suffix',\n\t\tconst Type extends 'all' | 'decorator' | 'state' | 'model' | 'error',\n\t\tconst Word extends string\n\t>(\n\t\tbase: Base,\n\t\ttype: Type,\n\t\tword: Word\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\t{\n\t\t\tdecorator: Type extends 'decorator' | 'all'\n\t\t\t\t? 'prefix' extends Base\n\t\t\t\t\t? Word extends `${string}${'_' | '-' | ' '}`\n\t\t\t\t\t\t? AddPrefix<Word, Singleton['decorator']>\n\t\t\t\t\t\t: AddPrefixCapitalize<Word, Singleton['decorator']>\n\t\t\t\t\t: AddSuffixCapitalize<Word, Singleton['decorator']>\n\t\t\t\t: Singleton['decorator']\n\t\t\tstore: Type extends 'state' | 'all'\n\t\t\t\t? 'prefix' extends Base\n\t\t\t\t\t? Word extends `${string}${'_' | '-' | ' '}`\n\t\t\t\t\t\t? AddPrefix<Word, Singleton['store']>\n\t\t\t\t\t\t: AddPrefixCapitalize<Word, Singleton['store']>\n\t\t\t\t\t: AddSuffix<Word, Singleton['store']>\n\t\t\t\t: Singleton['store']\n\t\t\tderive: Type extends 'decorator' | 'all'\n\t\t\t\t? 'prefix' extends Base\n\t\t\t\t\t? Word extends `${string}${'_' | '-' | ' '}`\n\t\t\t\t\t\t? AddPrefix<Word, Singleton['derive']>\n\t\t\t\t\t\t: AddPrefixCapitalize<Word, Singleton['derive']>\n\t\t\t\t\t: AddSuffixCapitalize<Word, Singleton['derive']>\n\t\t\t\t: Singleton['derive']\n\t\t\tresolve: Type extends 'decorator' | 'all'\n\t\t\t\t? 'prefix' extends Base\n\t\t\t\t\t? Word extends `${string}${'_' | '-' | ' '}`\n\t\t\t\t\t\t? AddPrefix<Word, Singleton['resolve']>\n\t\t\t\t\t\t: AddPrefixCapitalize<Word, Singleton['resolve']>\n\t\t\t\t\t: AddSuffixCapitalize<Word, Singleton['resolve']>\n\t\t\t\t: Singleton['resolve']\n\t\t},\n\t\t{\n\t\t\ttype: Type extends 'model' | 'all'\n\t\t\t\t? 'prefix' extends Base\n\t\t\t\t\t? Word extends `${string}${'_' | '-' | ' '}`\n\t\t\t\t\t\t? AddPrefix<Word, Definitions['type']>\n\t\t\t\t\t\t: AddPrefixCapitalize<Word, Definitions['type']>\n\t\t\t\t\t: AddSuffixCapitalize<Word, Definitions['type']>\n\t\t\t\t: Definitions['type']\n\t\t\terror: Type extends 'error' | 'all'\n\t\t\t\t? 'prefix' extends Base\n\t\t\t\t\t? Word extends `${string}${'_' | '-' | ' '}`\n\t\t\t\t\t\t? AddPrefix<Word, Definitions['error']>\n\t\t\t\t\t\t: AddPrefixCapitalize<Word, Definitions['error']>\n\t\t\t\t\t: AddSuffixCapitalize<Word, Definitions['error']>\n\t\t\t\t: Definitions['error']\n\t\t},\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tif (word === '') return this as any\n\n\t\tconst delimieter = ['_', '-', ' ']\n\t\tconst capitalize = (word: string) =>\n\t\t\tword[0].toUpperCase() + word.slice(1)\n\n\t\tconst joinKey =\n\t\t\tbase === 'prefix'\n\t\t\t\t? (prefix: string, word: string) =>\n\t\t\t\t\t\tdelimieter.includes(prefix.at(-1) ?? '')\n\t\t\t\t\t\t\t? prefix + word\n\t\t\t\t\t\t\t: prefix + capitalize(word)\n\t\t\t\t: delimieter.includes(word.at(-1) ?? '')\n\t\t\t\t\t? (suffix: string, word: string) => word + suffix\n\t\t\t\t\t: (suffix: string, word: string) =>\n\t\t\t\t\t\t\tword + capitalize(suffix)\n\n\t\tconst remap = (type: 'decorator' | 'state' | 'model' | 'error') => {\n\t\t\tconst store: Record<string, any> = {}\n\n\t\t\tswitch (type) {\n\t\t\t\tcase 'decorator':\n\t\t\t\t\tfor (const key in this.singleton.decorator) {\n\t\t\t\t\t\tstore[joinKey(word, key)] =\n\t\t\t\t\t\t\tthis.singleton.decorator[key]\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.singleton.decorator = store\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'state':\n\t\t\t\t\tfor (const key in this.singleton.store)\n\t\t\t\t\t\tstore[joinKey(word, key)] = this.singleton.store[key]\n\n\t\t\t\t\tthis.singleton.store = store\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'model':\n\t\t\t\t\tfor (const key in this.definitions.type)\n\t\t\t\t\t\tstore[joinKey(word, key)] = this.definitions.type[key]\n\n\t\t\t\t\tthis.definitions.type = store\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'error':\n\t\t\t\t\tfor (const key in this.definitions.error)\n\t\t\t\t\t\tstore[joinKey(word, key)] = this.definitions.error[key]\n\n\t\t\t\t\tthis.definitions.error = store\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tconst types = Array.isArray(type) ? type : [type]\n\n\t\tfor (const type of types.some((x) => x === 'all')\n\t\t\t? ['decorator', 'state', 'model', 'error']\n\t\t\t: types)\n\t\t\tremap(type as 'decorator')\n\n\t\treturn this as any\n\t}\n\n\tprefix<\n\t\tconst Type extends 'all' | 'decorator' | 'state' | 'model' | 'error',\n\t\tconst Word extends string\n\t>(type: Type, word: Word) {\n\t\treturn this.affix('prefix', type, word)\n\t}\n\n\tsuffix<\n\t\tconst Type extends 'all' | 'decorator' | 'state' | 'model' | 'error',\n\t\tconst Word extends string\n\t>(type: Type, word: Word) {\n\t\treturn this.affix('suffix', type, word)\n\t}\n\n\tcompile() {\n\t\tthis.fetch = this.config.aot\n\t\t\t? composeGeneralHandler(this)\n\t\t\t: createDynamicHandler(this)\n\n\t\tif (typeof this.server?.reload === 'function')\n\t\t\tthis.server.reload({\n\t\t\t\t...(this.server || {}),\n\t\t\t\tfetch: this.fetch\n\t\t\t})\n\n\t\treturn this\n\t}\n\n\thandle = async (request: Request) => this.fetch(request)\n\n\t/**\n\t * Use handle can be either sync or async to save performance.\n\t *\n\t * Beside benchmark purpose, please use 'handle' instead.\n\t */\n\tfetch = (request: Request): MaybePromise<Response> => {\n\t\tif (process.env.NODE_ENV === 'production' && this.config.aot !== false)\n\t\t\tconsole.warn(\n\t\t\t\t\"Performance degradation found. Please call Elysia.compile() before using 'fetch'\"\n\t\t\t)\n\n\t\treturn (this.fetch = this.config.aot\n\t\t\t? composeGeneralHandler(this)\n\t\t\t: createDynamicHandler(this))(request)\n\t}\n\n\tprivate handleError = async (\n\t\tcontext: Partial<\n\t\t\tContext<\n\t\t\t\tMetadata['schema'] & Ephemeral['schema'] & Volatile['schema'],\n\t\t\t\tSingleton & {\n\t\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t\t},\n\t\t\t\tBasePath\n\t\t\t>\n\t\t> & {\n\t\t\trequest: Request\n\t\t},\n\t\terror:\n\t\t\t| Error\n\t\t\t| ValidationError\n\t\t\t| ParseError\n\t\t\t| NotFoundError\n\t\t\t| InternalServerError\n\t) =>\n\t\t(this.handleError = this.config.aot\n\t\t\t? composeErrorHandler(this)\n\t\t\t: createDynamicErrorHandler(this))(context, error)\n\n\tprivate outerErrorHandler = (error: Error) =>\n\t\tnew Response(error.message || error.name || 'Error', {\n\t\t\t// @ts-ignore\n\t\t\tstatus: error?.status ?? 500\n\t\t})\n\n\t/**\n\t * ### listen\n\t * Assign current instance to port and start serving\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .get(\"/\", () => 'hi')\n\t *     .listen(3000)\n\t * ```\n\t */\n\tlisten = (\n\t\toptions: string | number | Partial<Serve>,\n\t\tcallback?: ListenCallback\n\t) => {\n\t\tif (typeof Bun === 'undefined')\n\t\t\tthrow new Error(\n\t\t\t\t'.listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch'\n\t\t\t)\n\n\t\tthis.compile()\n\n\t\tif (typeof options === 'string') {\n\t\t\tif (!isNumericString(options))\n\t\t\t\tthrow new Error('Port must be a numeric value')\n\n\t\t\toptions = parseInt(options)\n\t\t}\n\n\t\tconst fetch = this.fetch\n\n\t\tconst serve =\n\t\t\ttypeof options === 'object'\n\t\t\t\t? ({\n\t\t\t\t\t\tdevelopment: !isProduction,\n\t\t\t\t\t\treusePort: true,\n\t\t\t\t\t\t...(this.config.serve || {}),\n\t\t\t\t\t\t...(options || {}),\n\t\t\t\t\t\twebsocket: {\n\t\t\t\t\t\t\t...(this.config.websocket || {}),\n\t\t\t\t\t\t\t...(websocket || {})\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfetch,\n\t\t\t\t\t\terror: this.outerErrorHandler\n\t\t\t\t\t} as Serve)\n\t\t\t\t: ({\n\t\t\t\t\t\tdevelopment: !isProduction,\n\t\t\t\t\t\treusePort: true,\n\t\t\t\t\t\t...(this.config.serve || {}),\n\t\t\t\t\t\twebsocket: {\n\t\t\t\t\t\t\t...(this.config.websocket || {}),\n\t\t\t\t\t\t\t...(websocket || {})\n\t\t\t\t\t\t},\n\t\t\t\t\t\tport: options,\n\t\t\t\t\t\tfetch,\n\t\t\t\t\t\terror: this.outerErrorHandler\n\t\t\t\t\t} as Serve)\n\n\t\tthis.server = Bun?.serve(serve)\n\n\t\tfor (let i = 0; i < this.event.start.length; i++)\n\t\t\tthis.event.start[i].fn(this)\n\n\t\tif (callback) callback(this.server!)\n\n\t\tprocess.on('beforeExit', () => {\n\t\t\tif (this.server) {\n\t\t\t\tthis.server.stop()\n\t\t\t\tthis.server = null\n\n\t\t\t\tfor (let i = 0; i < this.event.stop.length; i++)\n\t\t\t\t\tthis.event.stop[i].fn(this)\n\t\t\t}\n\t\t})\n\n\t\tthis.promisedModules.then(() => {\n\t\t\tBun?.gc(false)\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### stop\n\t * Stop server from serving\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * const app = new Elysia()\n\t *     .get(\"/\", () => 'hi')\n\t *     .listen(3000)\n\t *\n\t * // Sometime later\n\t * app.stop()\n\t * ```\n\t */\n\tstop = async () => {\n\t\tif (!this.server)\n\t\t\tthrow new Error(\n\t\t\t\t\"Elysia isn't running. Call `app.listen` to start the server.\"\n\t\t\t)\n\n\t\tif (this.server) {\n\t\t\tthis.server.stop()\n\t\t\tthis.server = null\n\n\t\t\tif (this.event.stop.length)\n\t\t\t\tfor (let i = 0; i < this.event.stop.length; i++)\n\t\t\t\t\tthis.event.stop[i].fn(this)\n\t\t}\n\t}\n\n\t/**\n\t * Wait until all lazy loaded modules all load is fully\n\t */\n\tget modules() {\n\t\treturn Promise.all(this.promisedModules.promises)\n\t}\n}\n\nexport { Elysia }\n\nexport { mapResponse, mapCompactResponse, mapEarlyResponse } from './handler'\nexport { t } from './type-system'\nexport { Cookie, type CookieOptions } from './cookies'\n\nexport {\n\tgetSchemaValidator,\n\tmergeHook,\n\tmergeObjectArray,\n\tgetResponseSchemaValidator,\n\tredirect,\n\tStatusMap,\n\tInvertedStatusMap\n} from './utils'\n\nexport {\n\terror,\n\tParseError,\n\tNotFoundError,\n\tValidationError,\n\tInternalServerError,\n\tInvalidCookieSignature,\n\tERROR_CODE,\n\tELYSIA_RESPONSE\n} from './error'\n\nexport type { Context, PreContext } from './context'\n\nexport type {\n\tEphemeralType,\n\tCreateEden,\n\tComposeElysiaResponse,\n\tElysiaConfig,\n\tSingletonBase,\n\tDefinitionBase,\n\tRouteBase,\n\tHandler,\n\tComposedHandler,\n\tInputSchema,\n\tLocalHook,\n\tMergeSchema,\n\tRouteSchema,\n\tUnwrapRoute,\n\tInternalRoute,\n\tHTTPMethod,\n\tSchemaValidator,\n\tVoidHandler,\n\tPreHandler,\n\tBodyHandler,\n\tOptionalHandler,\n\tErrorHandler,\n\tAfterHandler,\n\tLifeCycleEvent,\n\tTraceEvent,\n\tLifeCycleStore,\n\tLifeCycleType,\n\tMaybePromise,\n\tListenCallback,\n\tUnwrapSchema,\n\tTraceHandler,\n\tTraceProcess,\n\tTraceReporter,\n\tTraceStream,\n\tChecksum,\n\tDocumentDecoration,\n\tInferContext,\n\tInferHandler\n} from './types'\n\nexport type { Static, TSchema } from '@sinclair/typebox'\n"
  ],
  "mappings": "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AAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAI/C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EACjC,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GACxC,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EACpC,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAClC,EAAG,GAAI,GAAI,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",
  "debugId": "17CE3FCF910F72FE64756e2164756e21",
  "names": []
}